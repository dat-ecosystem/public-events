{"version":3,"file":"site.js","sources":["../node_modules/proposal-temporal/index.js","../src/relativeTime.js","../src/automatic.js","../src/live.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t  path: basedir,\n\t  exports: {},\n\t  require: function (path, base) {\n      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n    }\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction getCjsExportFromNamespace (n) {\n\treturn n && n['default'] || n;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nvar shams = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\nvar origSymbol = commonjsGlobal.Symbol;\n\n\nvar hasSymbols = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn shams();\n};\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nvar implementation = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\nvar functionBind = Function.prototype.bind || implementation;\n\n/* globals\n\tAtomics,\n\tSharedArrayBuffer,\n*/\n\nvar undefined$1;\n\nvar $TypeError = TypeError;\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () { throw new $TypeError(); };\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols$1 = hasSymbols();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\nvar generatorFunction =  undefined$1;\nvar asyncFunction =  undefined$1;\nvar asyncGenFunction =  undefined$1;\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,\n\t'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,\n\t'%ArrayIteratorPrototype%': hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,\n\t'%ArrayPrototype%': Array.prototype,\n\t'%ArrayProto_entries%': Array.prototype.entries,\n\t'%ArrayProto_forEach%': Array.prototype.forEach,\n\t'%ArrayProto_keys%': Array.prototype.keys,\n\t'%ArrayProto_values%': Array.prototype.values,\n\t'%AsyncFromSyncIteratorPrototype%': undefined$1,\n\t'%AsyncFunction%': asyncFunction,\n\t'%AsyncFunctionPrototype%':  undefined$1,\n\t'%AsyncGenerator%':  undefined$1,\n\t'%AsyncGeneratorFunction%': asyncGenFunction,\n\t'%AsyncGeneratorPrototype%':  undefined$1,\n\t'%AsyncIteratorPrototype%':  undefined$1,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,\n\t'%Boolean%': Boolean,\n\t'%BooleanPrototype%': Boolean.prototype,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,\n\t'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,\n\t'%Date%': Date,\n\t'%DatePrototype%': Date.prototype,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%ErrorPrototype%': Error.prototype,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%EvalErrorPrototype%': EvalError.prototype,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,\n\t'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,\n\t'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,\n\t'%Function%': Function,\n\t'%FunctionPrototype%': Function.prototype,\n\t'%Generator%':  undefined$1,\n\t'%GeneratorFunction%': generatorFunction,\n\t'%GeneratorPrototype%':  undefined$1,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,\n\t'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,\n\t'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,\n\t'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,\n\t'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined$1,\n\t'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),\n\t'%MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%NumberPrototype%': Number.prototype,\n\t'%Object%': Object,\n\t'%ObjectPrototype%': Object.prototype,\n\t'%ObjProto_toString%': Object.prototype.toString,\n\t'%ObjProto_valueOf%': Object.prototype.valueOf,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,\n\t'%PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,\n\t'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,\n\t'%Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,\n\t'%Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,\n\t'%Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,\n\t'%RangeError%': RangeError,\n\t'%RangeErrorPrototype%': RangeError.prototype,\n\t'%ReferenceError%': ReferenceError,\n\t'%ReferenceErrorPrototype%': ReferenceError.prototype,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,\n\t'%RegExp%': RegExp,\n\t'%RegExpPrototype%': RegExp.prototype,\n\t'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),\n\t'%SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,\n\t'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols$1 ? getProto(''[Symbol.iterator]()) : undefined$1,\n\t'%StringPrototype%': String.prototype,\n\t'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,\n\t'%SymbolPrototype%': hasSymbols$1 ? Symbol.prototype : undefined$1,\n\t'%SyntaxError%': SyntaxError,\n\t'%SyntaxErrorPrototype%': SyntaxError.prototype,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,\n\t'%TypeError%': $TypeError,\n\t'%TypeErrorPrototype%': $TypeError.prototype,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,\n\t'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,\n\t'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,\n\t'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,\n\t'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,\n\t'%URIError%': URIError,\n\t'%URIErrorPrototype%': URIError.prototype,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,\n\t'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,\n\t'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype\n};\n\n\nvar $replace = functionBind.call(Function.call, String.prototype.replace);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tif (!(name in INTRINSICS)) {\n\t\tthrow new SyntaxError('intrinsic ' + name + ' does not exist!');\n\t}\n\n\t// istanbul ignore if // hopefully this is impossible to test :-)\n\tif (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {\n\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t}\n\n\treturn INTRINSICS[name];\n};\n\nvar GetIntrinsic = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\n\tvar value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);\n\tfor (var i = 1; i < parts.length; i += 1) {\n\t\tif (value != null) {\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, parts[i]);\n\t\t\t\tif (!allowMissing && !(parts[i] in value)) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\tvalue = desc ? (desc.get || desc.value) : value[parts[i]];\n\t\t\t} else {\n\t\t\t\tvalue = value[parts[i]];\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);\n\nvar callBind = function callBind() {\n\treturn $reflectApply(functionBind, $call, arguments);\n};\n\nvar apply = function applyBind() {\n\treturn $reflectApply(functionBind, $apply, arguments);\n};\ncallBind.apply = apply;\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nvar callBound = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\nvar $test = GetIntrinsic('RegExp.prototype.test');\n\n\n\nvar regexTester = function regexTester(regex) {\n\treturn callBind($test, regex);\n};\n\nvar isPrimitive = function isPrimitive(value) {\n\treturn value === null || (typeof value !== 'function' && typeof value !== 'object');\n};\n\nvar isPrimitive$1 = function isPrimitive(value) {\n\treturn value === null || (typeof value !== 'function' && typeof value !== 'object');\n};\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t} catch (_) {\n\t\treflectApply = null;\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr$1 = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nvar isCallable = reflectApply\n\t? function isCallable(value) {\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr$1.call(value);\n\t\treturn strClass === fnClass || strClass === genClass;\n\t};\n\nvar getDay = Date.prototype.getDay;\nvar tryDateObject = function tryDateGetDayCall(value) {\n\ttry {\n\t\tgetDay.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar toStr$2 = Object.prototype.toString;\nvar dateClass = '[object Date]';\nvar hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nvar isDateObject = function isDateObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\treturn hasToStringTag$1 ? tryDateObject(value) : toStr$2.call(value) === dateClass;\n};\n\nvar isSymbol = createCommonjsModule(function (module) {\n\nvar toStr = Object.prototype.toString;\nvar hasSymbols$1 = hasSymbols();\n\nif (hasSymbols$1) {\n\tvar symToStr = Symbol.prototype.toString;\n\tvar symStringRegex = /^Symbol\\(.*\\)$/;\n\tvar isSymbolObject = function isRealSymbolObject(value) {\n\t\tif (typeof value.valueOf() !== 'symbol') {\n\t\t\treturn false;\n\t\t}\n\t\treturn symStringRegex.test(symToStr.call(value));\n\t};\n\n\tmodule.exports = function isSymbol(value) {\n\t\tif (typeof value === 'symbol') {\n\t\t\treturn true;\n\t\t}\n\t\tif (toStr.call(value) !== '[object Symbol]') {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\treturn isSymbolObject(value);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n} else {\n\n\tmodule.exports = function isSymbol(value) {\n\t\t// this environment does not support Symbols.\n\t\treturn false ;\n\t};\n}\n});\n\nvar hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';\n\n\n\n\n\n\nvar ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {\n\tif (typeof O === 'undefined' || O === null) {\n\t\tthrow new TypeError('Cannot call method on ' + O);\n\t}\n\tif (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {\n\t\tthrow new TypeError('hint must be \"string\" or \"number\"');\n\t}\n\tvar methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];\n\tvar method, result, i;\n\tfor (i = 0; i < methodNames.length; ++i) {\n\t\tmethod = O[methodNames[i]];\n\t\tif (isCallable(method)) {\n\t\t\tresult = method.call(O);\n\t\t\tif (isPrimitive$1(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\tthrow new TypeError('No default value');\n};\n\nvar GetMethod = function GetMethod(O, P) {\n\tvar func = O[P];\n\tif (func !== null && typeof func !== 'undefined') {\n\t\tif (!isCallable(func)) {\n\t\t\tthrow new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');\n\t\t}\n\t\treturn func;\n\t}\n\treturn void 0;\n};\n\n// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive\nvar es2015 = function ToPrimitive(input) {\n\tif (isPrimitive$1(input)) {\n\t\treturn input;\n\t}\n\tvar hint = 'default';\n\tif (arguments.length > 1) {\n\t\tif (arguments[1] === String) {\n\t\t\thint = 'string';\n\t\t} else if (arguments[1] === Number) {\n\t\t\thint = 'number';\n\t\t}\n\t}\n\n\tvar exoticToPrim;\n\tif (hasSymbols$2) {\n\t\tif (Symbol.toPrimitive) {\n\t\t\texoticToPrim = GetMethod(input, Symbol.toPrimitive);\n\t\t} else if (isSymbol(input)) {\n\t\t\texoticToPrim = Symbol.prototype.valueOf;\n\t\t}\n\t}\n\tif (typeof exoticToPrim !== 'undefined') {\n\t\tvar result = exoticToPrim.call(input, hint);\n\t\tif (isPrimitive$1(result)) {\n\t\t\treturn result;\n\t\t}\n\t\tthrow new TypeError('unable to convert exotic object to primitive');\n\t}\n\tif (hint === 'default' && (isDateObject(input) || isSymbol(input))) {\n\t\thint = 'string';\n\t}\n\treturn ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive\n\nvar ToPrimitive = function ToPrimitive(input) {\n\tif (arguments.length > 1) {\n\t\treturn es2015(input, arguments[1]);\n\t}\n\treturn es2015(input);\n};\n\nvar $TypeError$1 = GetIntrinsic('%TypeError%');\nvar $Number = GetIntrinsic('%Number%');\nvar $RegExp = GetIntrinsic('%RegExp%');\nvar $parseInteger = GetIntrinsic('%parseInt%');\n\n\n\n\n\nvar $strSlice = callBound('String.prototype.slice');\nvar isBinary = regexTester(/^0b[01]+$/i);\nvar isOctal = regexTester(/^0o[0-7]+$/i);\nvar isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);\nvar nonWS = ['\\u0085', '\\u200b', '\\ufffe'].join('');\nvar nonWSregex = new $RegExp('[' + nonWS + ']', 'g');\nvar hasNonWS = regexTester(nonWSregex);\n\n// whitespace from: https://es5.github.io/#x15.5.4.20\n// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324\nvar ws = [\n\t'\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003',\n\t'\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028',\n\t'\\u2029\\uFEFF'\n].join('');\nvar trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');\nvar $replace$1 = callBound('String.prototype.replace');\nvar $trim = function (value) {\n\treturn $replace$1(value, trimRegex, '');\n};\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-tonumber\n\nvar ToNumber = function ToNumber(argument) {\n\tvar value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);\n\tif (typeof value === 'symbol') {\n\t\tthrow new $TypeError$1('Cannot convert a Symbol value to a number');\n\t}\n\tif (typeof value === 'string') {\n\t\tif (isBinary(value)) {\n\t\t\treturn ToNumber($parseInteger($strSlice(value, 2), 2));\n\t\t} else if (isOctal(value)) {\n\t\t\treturn ToNumber($parseInteger($strSlice(value, 2), 8));\n\t\t} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {\n\t\t\treturn NaN;\n\t\t} else {\n\t\t\tvar trimmed = $trim(value);\n\t\t\tif (trimmed !== value) {\n\t\t\t\treturn ToNumber(trimmed);\n\t\t\t}\n\t\t}\n\t}\n\treturn $Number(value);\n};\n\n// https://www.ecma-international.org/ecma-262/5.1/#sec-8\n\nvar Type = function Type(x) {\n\tif (x === null) {\n\t\treturn 'Null';\n\t}\n\tif (typeof x === 'undefined') {\n\t\treturn 'Undefined';\n\t}\n\tif (typeof x === 'function' || typeof x === 'object') {\n\t\treturn 'Object';\n\t}\n\tif (typeof x === 'number') {\n\t\treturn 'Number';\n\t}\n\tif (typeof x === 'boolean') {\n\t\treturn 'Boolean';\n\t}\n\tif (typeof x === 'string') {\n\t\treturn 'String';\n\t}\n};\n\n// https://ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values\n\nvar Type$1 = function Type$1(x) {\n\tif (typeof x === 'symbol') {\n\t\treturn 'Symbol';\n\t}\n\treturn Type(x);\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison\n\nvar AbstractEqualityComparison = function AbstractEqualityComparison(x, y) {\n\tvar xType = Type$1(x);\n\tvar yType = Type$1(y);\n\tif (xType === yType) {\n\t\treturn x === y; // ES6+ specified this shortcut anyways.\n\t}\n\tif (x == null && y == null) {\n\t\treturn true;\n\t}\n\tif (xType === 'Number' && yType === 'String') {\n\t\treturn AbstractEqualityComparison(x, ToNumber(y));\n\t}\n\tif (xType === 'String' && yType === 'Number') {\n\t\treturn AbstractEqualityComparison(ToNumber(x), y);\n\t}\n\tif (xType === 'Boolean') {\n\t\treturn AbstractEqualityComparison(ToNumber(x), y);\n\t}\n\tif (yType === 'Boolean') {\n\t\treturn AbstractEqualityComparison(x, ToNumber(y));\n\t}\n\tif ((xType === 'String' || xType === 'Number' || xType === 'Symbol') && yType === 'Object') {\n\t\treturn AbstractEqualityComparison(x, ToPrimitive(y));\n\t}\n\tif (xType === 'Object' && (yType === 'String' || yType === 'Number' || yType === 'Symbol')) {\n\t\treturn AbstractEqualityComparison(ToPrimitive(x), y);\n\t}\n\treturn false;\n};\n\nvar _isNaN = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n\nvar $isNaN = Number.isNaN || function (a) { return a !== a; };\n\nvar _isFinite = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };\n\nvar $strSlice$1 = callBound('String.prototype.slice');\n\nvar isPrefixOf = function isPrefixOf(prefix, string) {\n\tif (prefix === string) {\n\t\treturn true;\n\t}\n\tif (prefix.length > string.length) {\n\t\treturn false;\n\t}\n\treturn $strSlice$1(string, 0, prefix.length) === prefix;\n};\n\nvar $Number$1 = GetIntrinsic('%Number%');\nvar $TypeError$2 = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/5.1/#sec-11.8.5\n\n// eslint-disable-next-line max-statements\nvar AbstractRelationalComparison = function AbstractRelationalComparison(x, y, LeftFirst) {\n\tif (Type$1(LeftFirst) !== 'Boolean') {\n\t\tthrow new $TypeError$2('Assertion failed: LeftFirst argument must be a Boolean');\n\t}\n\tvar px;\n\tvar py;\n\tif (LeftFirst) {\n\t\tpx = ToPrimitive(x, $Number$1);\n\t\tpy = ToPrimitive(y, $Number$1);\n\t} else {\n\t\tpy = ToPrimitive(y, $Number$1);\n\t\tpx = ToPrimitive(x, $Number$1);\n\t}\n\tvar bothStrings = Type$1(px) === 'String' && Type$1(py) === 'String';\n\tif (!bothStrings) {\n\t\tvar nx = ToNumber(px);\n\t\tvar ny = ToNumber(py);\n\t\tif (_isNaN(nx) || _isNaN(ny)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (_isFinite(nx) && _isFinite(ny) && nx === ny) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nx === 0 && ny === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nx === Infinity) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ny === Infinity) {\n\t\t\treturn true;\n\t\t}\n\t\tif (ny === -Infinity) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nx === -Infinity) {\n\t\t\treturn true;\n\t\t}\n\t\treturn nx < ny; // by now, these are both nonzero, finite, and not equal\n\t}\n\tif (isPrefixOf(py, px)) {\n\t\treturn false;\n\t}\n\tif (isPrefixOf(px, py)) {\n\t\treturn true;\n\t}\n\treturn px < py; // both strings, neither a prefix of the other. shortcut for steps c-f\n};\n\n// https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6\n\nvar StrictEqualityComparison = function StrictEqualityComparison(x, y) {\n\tvar xType = Type$1(x);\n\tvar yType = Type$1(y);\n\tif (xType !== yType) {\n\t\treturn false;\n\t}\n\tif (xType === 'Undefined' || xType === 'Null') {\n\t\treturn true;\n\t}\n\treturn x === y; // shortcut for steps 4-7\n};\n\nfunction inspect(obj) {\n    if (!obj || 'object' !== typeof obj) return String(obj);\n    if ('length' in obj && 'push' in obj && 'join' in obj) return String(obj);\n    var res = [];\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            res.push([ prop, String(obj[prop]) ].join(':'));\n        }\n    }\n    return '{ ' + res.join(', ') + ' }';\n}\n\nvar util = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  inspect: inspect\n});\n\nvar require$$0 = getCjsExportFromNamespace(util);\n\nvar util_inspect = require$$0.inspect;\n\nvar hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar match = String.prototype.match;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\n\nvar inspectCustom = util_inspect.custom;\nvar inspectSymbol = inspectCustom && isSymbol$1(inspectCustom) ? inspectCustom : null;\n\nvar objectInspect = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true` or `false`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('options \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        return String(obj);\n    }\n    if (typeof obj === 'bigint') { // eslint-disable-line valid-typeof\n        return String(obj) + 'n';\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = seen.slice();\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function') {\n        var name = nameOf(obj);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']';\n    }\n    if (isSymbol$1(obj)) {\n        var symString = Symbol.prototype.toString.call(obj);\n        return typeof obj === 'object' ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + String(obj.nodeName).toLowerCase();\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + String(obj.nodeName).toLowerCase() + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + xs.join(', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {\n            return obj[inspectSymbol]();\n        } else if (typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        mapForEach.call(obj, function (value, key) {\n            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n        });\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        setForEach.call(obj, function (value) {\n            setParts.push(inspect(value, obj));\n        });\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        if (ys.length === 0) { return '{}'; }\n        if (indent) {\n            return '{' + indentedJoin(ys, indent) + '}';\n        }\n        return '{ ' + ys.join(', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '\"' : \"'\";\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return String(s).replace(/\"/g, '&quot;');\n}\n\nfunction isArray(obj) { return toStr$3(obj) === '[object Array]'; }\nfunction isDate(obj) { return toStr$3(obj) === '[object Date]'; }\nfunction isRegExp(obj) { return toStr$3(obj) === '[object RegExp]'; }\nfunction isError(obj) { return toStr$3(obj) === '[object Error]'; }\nfunction isSymbol$1(obj) { return toStr$3(obj) === '[object Symbol]'; }\nfunction isString(obj) { return toStr$3(obj) === '[object String]'; }\nfunction isNumber(obj) { return toStr$3(obj) === '[object Number]'; }\nfunction isBigInt(obj) { return toStr$3(obj) === '[object BigInt]'; }\nfunction isBoolean(obj) { return toStr$3(obj) === '[object Boolean]'; }\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr$3(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;\n    }\n    // eslint-disable-next-line no-control-regex\n    var s = str.replace(/(['\\\\])/g, '\\\\$1').replace(/[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + n.toString(16);\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = Array(opts.indent + 1).join(' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: Array(depth + 1).join(baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + xs.join(',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if ((/[^\\w$]/).test(key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    return xs;\n}\n\nvar $apply$1 = GetIntrinsic('%Reflect.apply%', true) || callBound('%Function.prototype.apply%');\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-call\n\nvar Call = function Call(F, V) {\n\tvar args = arguments.length > 2 ? arguments[2] : [];\n\treturn $apply$1(F, V, args);\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-ispropertykey\n\nvar IsPropertyKey = function IsPropertyKey(argument) {\n\treturn typeof argument === 'string' || typeof argument === 'symbol';\n};\n\nvar $TypeError$3 = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n/**\n * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p\n * 1. Assert: Type(O) is Object.\n * 2. Assert: IsPropertyKey(P) is true.\n * 3. Return O.[[Get]](P, O).\n */\n\nvar Get = function Get(O, P) {\n\t// 7.3.1.1\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$3('Assertion failed: Type(O) is not Object');\n\t}\n\t// 7.3.1.2\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$3('Assertion failed: IsPropertyKey(P) is not true, got ' + objectInspect(P));\n\t}\n\t// 7.3.1.3\n\treturn O[P];\n};\n\nvar hasSymbols$3 = hasSymbols();\n\n\n\nvar $iterator = GetIntrinsic('%Symbol.iterator%', true);\nvar $stringSlice = callBound('String.prototype.slice');\n\nvar getIteratorMethod = function getIteratorMethod(ES, iterable) {\n\tvar usingIterator;\n\tif (hasSymbols$3) {\n\t\tusingIterator = ES.GetMethod(iterable, $iterator);\n\t} else if (ES.IsArray(iterable)) {\n\t\tusingIterator = function () {\n\t\t\tvar i = -1;\n\t\t\tvar arr = this; // eslint-disable-line no-invalid-this\n\t\t\treturn {\n\t\t\t\tnext: function () {\n\t\t\t\t\ti += 1;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: i >= arr.length,\n\t\t\t\t\t\tvalue: arr[i]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else if (ES.Type(iterable) === 'String') {\n\t\tusingIterator = function () {\n\t\t\tvar i = 0;\n\t\t\treturn {\n\t\t\t\tnext: function () {\n\t\t\t\t\tvar nextIndex = ES.AdvanceStringIndex(iterable, i, true);\n\t\t\t\t\tvar value = $stringSlice(iterable, i, nextIndex);\n\t\t\t\t\ti = nextIndex;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: nextIndex > iterable.length,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\treturn usingIterator;\n};\n\nvar $Math = GetIntrinsic('%Math%');\n\nvar $floor = $Math.floor;\nvar $abs = $Math.abs;\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isinteger\n\nvar IsInteger = function IsInteger(argument) {\n\tif (typeof argument !== 'number' || _isNaN(argument) || !_isFinite(argument)) {\n\t\treturn false;\n\t}\n\tvar abs = $abs(argument);\n\treturn $floor(abs) === abs;\n};\n\nvar $Math$1 = GetIntrinsic('%Math%');\nvar $Number$2 = GetIntrinsic('%Number%');\n\nvar maxSafeInteger = $Number$2.MAX_SAFE_INTEGER || $Math$1.pow(2, 53) - 1;\n\nvar $TypeError$4 = GetIntrinsic('%TypeError%');\n\nvar $charCodeAt = callBound('String.prototype.charCodeAt');\n\n// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex\n\nvar AdvanceStringIndex = function AdvanceStringIndex(S, index, unicode) {\n\tif (Type$1(S) !== 'String') {\n\t\tthrow new $TypeError$4('Assertion failed: `S` must be a String');\n\t}\n\tif (!IsInteger(index) || index < 0 || index > maxSafeInteger) {\n\t\tthrow new $TypeError$4('Assertion failed: `length` must be an integer >= 0 and <= 2**53');\n\t}\n\tif (Type$1(unicode) !== 'Boolean') {\n\t\tthrow new $TypeError$4('Assertion failed: `unicode` must be a Boolean');\n\t}\n\tif (!unicode) {\n\t\treturn index + 1;\n\t}\n\tvar length = S.length;\n\tif ((index + 1) >= length) {\n\t\treturn index + 1;\n\t}\n\n\tvar first = $charCodeAt(S, index);\n\tif (first < 0xD800 || first > 0xDBFF) {\n\t\treturn index + 1;\n\t}\n\n\tvar second = $charCodeAt(S, index + 1);\n\tif (second < 0xDC00 || second > 0xDFFF) {\n\t\treturn index + 1;\n\t}\n\n\treturn index + 2;\n};\n\nvar $TypeError$5 = GetIntrinsic('%TypeError%');\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.10\n\nvar CheckObjectCoercible = function CheckObjectCoercible(value, optMessage) {\n\tif (value == null) {\n\t\tthrow new $TypeError$5(optMessage || ('Cannot call method on ' + value));\n\t}\n\treturn value;\n};\n\nvar RequireObjectCoercible = CheckObjectCoercible;\n\nvar $Object = GetIntrinsic('%Object%');\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-toobject\n\nvar ToObject = function ToObject(value) {\n\tRequireObjectCoercible(value);\n\treturn $Object(value);\n};\n\nvar $TypeError$6 = GetIntrinsic('%TypeError%');\n\n\n\n\n/**\n * 7.3.2 GetV (V, P)\n * 1. Assert: IsPropertyKey(P) is true.\n * 2. Let O be ToObject(V).\n * 3. ReturnIfAbrupt(O).\n * 4. Return O.[[Get]](P, V).\n */\n\nvar GetV = function GetV(V, P) {\n\t// 7.3.2.1\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$6('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\n\t// 7.3.2.2-3\n\tvar O = ToObject(V);\n\n\t// 7.3.2.4\n\treturn O[P];\n};\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.11\n\nvar IsCallable = isCallable;\n\nvar $TypeError$7 = GetIntrinsic('%TypeError%');\n\n\n\n\n\n/**\n * 7.3.9 - https://ecma-international.org/ecma-262/6.0/#sec-getmethod\n * 1. Assert: IsPropertyKey(P) is true.\n * 2. Let func be GetV(O, P).\n * 3. ReturnIfAbrupt(func).\n * 4. If func is either undefined or null, return undefined.\n * 5. If IsCallable(func) is false, throw a TypeError exception.\n * 6. Return func.\n */\n\nvar GetMethod$1 = function GetMethod(O, P) {\n\t// 7.3.9.1\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$7('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\n\t// 7.3.9.2\n\tvar func = GetV(O, P);\n\n\t// 7.3.9.4\n\tif (func == null) {\n\t\treturn void 0;\n\t}\n\n\t// 7.3.9.5\n\tif (!IsCallable(func)) {\n\t\tthrow new $TypeError$7(P + 'is not a function');\n\t}\n\n\t// 7.3.9.6\n\treturn func;\n};\n\nvar $Array = GetIntrinsic('%Array%');\n\n// eslint-disable-next-line global-require\nvar toStr$4 = !$Array.isArray && callBound('Object.prototype.toString');\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isarray\n\nvar IsArray = $Array.isArray || function IsArray(argument) {\n\treturn toStr$4(argument) === '[object Array]';\n};\n\nvar $TypeError$8 = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-getiterator\n\nvar GetIterator = function GetIterator(obj, method) {\n\tvar actualMethod = method;\n\tif (arguments.length < 2) {\n\t\tactualMethod = getIteratorMethod(\n\t\t\t{\n\t\t\t\tAdvanceStringIndex: AdvanceStringIndex,\n\t\t\t\tGetMethod: GetMethod$1,\n\t\t\t\tIsArray: IsArray,\n\t\t\t\tType: Type$1\n\t\t\t},\n\t\t\tobj\n\t\t);\n\t}\n\tvar iterator = Call(actualMethod, obj);\n\tif (Type$1(iterator) !== 'Object') {\n\t\tthrow new $TypeError$8('iterator must return an object');\n\t}\n\n\treturn iterator;\n};\n\nvar $TypeError$9 = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose\n\nvar IteratorClose = function IteratorClose(iterator, completion) {\n\tif (Type$1(iterator) !== 'Object') {\n\t\tthrow new $TypeError$9('Assertion failed: Type(iterator) is not Object');\n\t}\n\tif (!IsCallable(completion)) {\n\t\tthrow new $TypeError$9('Assertion failed: completion is not a thunk for a Completion Record');\n\t}\n\tvar completionThunk = completion;\n\n\tvar iteratorReturn = GetMethod$1(iterator, 'return');\n\n\tif (typeof iteratorReturn === 'undefined') {\n\t\treturn completionThunk();\n\t}\n\n\tvar completionRecord;\n\ttry {\n\t\tvar innerResult = Call(iteratorReturn, iterator, []);\n\t} catch (e) {\n\t\t// if we hit here, then \"e\" is the innerResult completion that needs re-throwing\n\n\t\t// if the completion is of type \"throw\", this will throw.\n\t\tcompletionThunk();\n\t\tcompletionThunk = null; // ensure it's not called twice.\n\n\t\t// if not, then return the innerResult completion\n\t\tthrow e;\n\t}\n\tcompletionRecord = completionThunk(); // if innerResult worked, then throw if the completion does\n\tcompletionThunk = null; // ensure it's not called twice.\n\n\tif (Type$1(innerResult) !== 'Object') {\n\t\tthrow new $TypeError$9('iterator .return must return an object');\n\t}\n\n\treturn completionRecord;\n};\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.2\n\nvar ToBoolean = function ToBoolean(value) { return !!value; };\n\nvar $TypeError$a = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-iteratorcomplete\n\nvar IteratorComplete = function IteratorComplete(iterResult) {\n\tif (Type$1(iterResult) !== 'Object') {\n\t\tthrow new $TypeError$a('Assertion failed: Type(iterResult) is not Object');\n\t}\n\treturn ToBoolean(Get(iterResult, 'done'));\n};\n\nvar $TypeError$b = GetIntrinsic('%TypeError%');\n\nvar $arraySlice = callBound('Array.prototype.slice');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-invoke\n\nvar Invoke = function Invoke(O, P) {\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$b('P must be a Property Key');\n\t}\n\tvar argumentsList = $arraySlice(arguments, 2);\n\tvar func = GetV(O, P);\n\treturn Call(func, O, argumentsList);\n};\n\nvar $TypeError$c = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-iteratornext\n\nvar IteratorNext = function IteratorNext(iterator, value) {\n\tvar result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);\n\tif (Type$1(result) !== 'Object') {\n\t\tthrow new $TypeError$c('iterator next must return an object');\n\t}\n\treturn result;\n};\n\n// https://ecma-international.org/ecma-262/6.0/#sec-iteratorstep\n\nvar IteratorStep = function IteratorStep(iterator) {\n\tvar result = IteratorNext(iterator);\n\tvar done = IteratorComplete(result);\n\treturn done === true ? false : result;\n};\n\nvar $TypeError$d = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-iteratorvalue\n\nvar IteratorValue = function IteratorValue(iterResult) {\n\tif (Type$1(iterResult) !== 'Object') {\n\t\tthrow new $TypeError$d('Assertion failed: Type(iterResult) is not Object');\n\t}\n\treturn Get(iterResult, 'value');\n};\n\nvar $TypeError$e = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n// https://tc39.es/ecma262/#sec-add-entries-from-iterable\n\nvar AddEntriesFromIterable = function AddEntriesFromIterable(target, iterable, adder) {\n\tif (!IsCallable(adder)) {\n\t\tthrow new $TypeError$e('Assertion failed: `adder` is not callable');\n\t}\n\tif (iterable == null) {\n\t\tthrow new $TypeError$e('Assertion failed: `iterable` is present, and not nullish');\n\t}\n\tvar iteratorRecord = GetIterator(iterable);\n\twhile (true) { // eslint-disable-line no-constant-condition\n\t\tvar next = IteratorStep(iteratorRecord);\n\t\tif (!next) {\n\t\t\treturn target;\n\t\t}\n\t\tvar nextItem = IteratorValue(next);\n\t\tif (Type$1(nextItem) !== 'Object') {\n\t\t\tvar error = new $TypeError$e('iterator next must return an Object, got ' + objectInspect(nextItem));\n\t\t\treturn IteratorClose(\n\t\t\t\titeratorRecord,\n\t\t\t\tfunction () { throw error; } // eslint-disable-line no-loop-func\n\t\t\t);\n\t\t}\n\t\ttry {\n\t\t\tvar k = Get(nextItem, '0');\n\t\t\tvar v = Get(nextItem, '1');\n\t\t\tCall(adder, target, [k, v]);\n\t\t} catch (e) {\n\t\t\treturn IteratorClose(\n\t\t\t\titeratorRecord,\n\t\t\t\tfunction () { throw e; }\n\t\t\t);\n\t\t}\n\t}\n};\n\nvar $ArrayPrototype = GetIntrinsic('%Array.prototype%');\nvar $RangeError = GetIntrinsic('%RangeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar $TypeError$f = GetIntrinsic('%TypeError%');\n\n\n\nvar MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1;\n\nvar $setProto = GetIntrinsic('%Object.setPrototypeOf%', true) || (\n\t// eslint-disable-next-line no-proto, no-negated-condition\n\t[].__proto__ !== $ArrayPrototype\n\t\t? null\n\t\t: function (O, proto) {\n\t\t\tO.__proto__ = proto; // eslint-disable-line no-proto, no-param-reassign\n\t\t\treturn O;\n\t\t}\n);\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-arraycreate\n\nvar ArrayCreate = function ArrayCreate(length) {\n\tif (!IsInteger(length) || length < 0) {\n\t\tthrow new $TypeError$f('Assertion failed: `length` must be an integer Number >= 0');\n\t}\n\tif (length > MAX_ARRAY_LENGTH) {\n\t\tthrow new $RangeError('length is greater than (2**32 - 1)');\n\t}\n\tvar proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;\n\tvar A = []; // steps 5 - 7, and 9\n\tif (proto !== $ArrayPrototype) { // step 8\n\t\tif (!$setProto) {\n\t\t\tthrow new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');\n\t\t}\n\t\t$setProto(A, proto);\n\t}\n\tif (length !== 0) { // bypasses the need for step 2\n\t\tA.length = length;\n\t}\n\t/* step 10, the above as a shortcut for the below\n    OrdinaryDefineOwnProperty(A, 'length', {\n        '[[Configurable]]': false,\n        '[[Enumerable]]': false,\n        '[[Value]]': length,\n        '[[Writable]]': true\n    });\n    */\n\treturn A;\n};\n\nvar toStr$5 = Object.prototype.toString;\n\nvar isArguments = function isArguments(value) {\n\tvar str = toStr$5.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr$5.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has$1 = Object.prototype.hasOwnProperty;\n\tvar toStr$6 = Object.prototype.toString;\n\tvar isArgs = isArguments; // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has$1.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr$6.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr$6.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has$1.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has$1.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has$1.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nvar implementation$1 = keysShim;\n\nvar slice$1 = Array.prototype.slice;\n\n\nvar origKeys = Object.keys;\nvar keysShim$1 = origKeys ? function keys(o) { return origKeys(o); } : implementation$1;\n\nvar originalKeys = Object.keys;\n\nkeysShim$1.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArguments(object)) {\n\t\t\t\t\treturn originalKeys(slice$1.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim$1;\n\t}\n\treturn Object.keys || keysShim$1;\n};\n\nvar objectKeys = keysShim$1;\n\nvar hasSymbols$4 = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr$7 = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr$7.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = objectKeys(map);\n\tif (hasSymbols$4) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nvar defineProperties_1 = defineProperties;\n\n// modified from https://github.com/es-shims/es6-shim\n\n\nvar canBeObject = function (obj) {\n\treturn typeof obj !== 'undefined' && obj !== null;\n};\nvar hasSymbols$5 = shams();\nvar toObject = Object;\nvar push = functionBind.call(Function.call, Array.prototype.push);\nvar propIsEnumerable = functionBind.call(Function.call, Object.prototype.propertyIsEnumerable);\nvar originalGetSymbols = hasSymbols$5 ? Object.getOwnPropertySymbols : null;\n\nvar implementation$2 = function assign(target, source1) {\n\tif (!canBeObject(target)) { throw new TypeError('target must be an object'); }\n\tvar objTarget = toObject(target);\n\tvar s, source, i, props, syms, value, key;\n\tfor (s = 1; s < arguments.length; ++s) {\n\t\tsource = toObject(arguments[s]);\n\t\tprops = objectKeys(source);\n\t\tvar getSymbols = hasSymbols$5 && (Object.getOwnPropertySymbols || originalGetSymbols);\n\t\tif (getSymbols) {\n\t\t\tsyms = getSymbols(source);\n\t\t\tfor (i = 0; i < syms.length; ++i) {\n\t\t\t\tkey = syms[i];\n\t\t\t\tif (propIsEnumerable(source, key)) {\n\t\t\t\t\tpush(props, key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < props.length; ++i) {\n\t\t\tkey = props[i];\n\t\t\tvalue = source[key];\n\t\t\tif (propIsEnumerable(source, key)) {\n\t\t\t\tobjTarget[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn objTarget;\n};\n\nvar lacksProperEnumerationOrder = function () {\n\tif (!Object.assign) {\n\t\treturn false;\n\t}\n\t// v8, specifically in node 4.x, has a bug with incorrect property enumeration order\n\t// note: this does not detect the bug unless there's 20 characters\n\tvar str = 'abcdefghijklmnopqrst';\n\tvar letters = str.split('');\n\tvar map = {};\n\tfor (var i = 0; i < letters.length; ++i) {\n\t\tmap[letters[i]] = letters[i];\n\t}\n\tvar obj = Object.assign({}, map);\n\tvar actual = '';\n\tfor (var k in obj) {\n\t\tactual += k;\n\t}\n\treturn str !== actual;\n};\n\nvar assignHasPendingExceptions = function () {\n\tif (!Object.assign || !Object.preventExtensions) {\n\t\treturn false;\n\t}\n\t// Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n\t// which is 72% slower than our shim, and Firefox 40's native implementation.\n\tvar thrower = Object.preventExtensions({ 1: 2 });\n\ttry {\n\t\tObject.assign(thrower, 'xy');\n\t} catch (e) {\n\t\treturn thrower[1] === 'y';\n\t}\n\treturn false;\n};\n\nvar polyfill = function getPolyfill() {\n\tif (!Object.assign) {\n\t\treturn implementation$2;\n\t}\n\tif (lacksProperEnumerationOrder()) {\n\t\treturn implementation$2;\n\t}\n\tif (assignHasPendingExceptions()) {\n\t\treturn implementation$2;\n\t}\n\treturn Object.assign;\n};\n\nvar shim = function shimAssign() {\n\tvar polyfill$1 = polyfill();\n\tdefineProperties_1(\n\t\tObject,\n\t\t{ assign: polyfill$1 },\n\t\t{ assign: function () { return Object.assign !== polyfill$1; } }\n\t);\n\treturn polyfill$1;\n};\n\nvar polyfill$1 = polyfill();\n\ndefineProperties_1(polyfill$1, {\n\tgetPolyfill: polyfill,\n\timplementation: implementation$2,\n\tshim: shim\n});\n\nvar object_assign = polyfill$1;\n\nvar src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);\n\nvar $TypeError$g = GetIntrinsic('%TypeError%');\n\nvar isPropertyDescriptor = function IsPropertyDescriptor(ES, Desc) {\n\tif (ES.Type(Desc) !== 'Object') {\n\t\treturn false;\n\t}\n\tvar allowed = {\n\t\t'[[Configurable]]': true,\n\t\t'[[Enumerable]]': true,\n\t\t'[[Get]]': true,\n\t\t'[[Set]]': true,\n\t\t'[[Value]]': true,\n\t\t'[[Writable]]': true\n\t};\n\n\tfor (var key in Desc) { // eslint-disable-line no-restricted-syntax\n\t\tif (src(Desc, key) && !allowed[key]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {\n\t\tthrow new $TypeError$g('Property Descriptors may not be both accessor and data descriptors');\n\t}\n\treturn true;\n};\n\nvar $TypeError$h = GetIntrinsic('%TypeError%');\nvar $SyntaxError$1 = GetIntrinsic('%SyntaxError%');\n\n\n\nvar predicates = {\n\t// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n\t'Property Descriptor': function isPropertyDescriptor(Type, Desc) {\n\t\tif (Type(Desc) !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\tvar allowed = {\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Get]]': true,\n\t\t\t'[[Set]]': true,\n\t\t\t'[[Value]]': true,\n\t\t\t'[[Writable]]': true\n\t\t};\n\n\t\tfor (var key in Desc) { // eslint-disable-line\n\t\t\tif (src(Desc, key) && !allowed[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar isData = src(Desc, '[[Value]]');\n\t\tvar IsAccessor = src(Desc, '[[Get]]') || src(Desc, '[[Set]]');\n\t\tif (isData && IsAccessor) {\n\t\t\tthrow new $TypeError$h('Property Descriptors may not be both accessor and data descriptors');\n\t\t}\n\t\treturn true;\n\t}\n};\n\nvar assertRecord = function assertRecord(Type, recordType, argumentName, value) {\n\tvar predicate = predicates[recordType];\n\tif (typeof predicate !== 'function') {\n\t\tthrow new $SyntaxError$1('unknown record type: ' + recordType);\n\t}\n\tif (!predicate(Type, value)) {\n\t\tthrow new $TypeError$h(argumentName + ' must be a ' + recordType);\n\t}\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isaccessordescriptor\n\nvar IsAccessorDescriptor = function IsAccessorDescriptor(Desc) {\n\tif (typeof Desc === 'undefined') {\n\t\treturn false;\n\t}\n\n\tassertRecord(Type$1, 'Property Descriptor', 'Desc', Desc);\n\n\tif (!src(Desc, '[[Get]]') && !src(Desc, '[[Set]]')) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isdatadescriptor\n\nvar IsDataDescriptor = function IsDataDescriptor(Desc) {\n\tif (typeof Desc === 'undefined') {\n\t\treturn false;\n\t}\n\n\tassertRecord(Type$1, 'Property Descriptor', 'Desc', Desc);\n\n\tif (!src(Desc, '[[Value]]') && !src(Desc, '[[Writable]]')) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nvar $gOPD$1 = GetIntrinsic('%Object.getOwnPropertyDescriptor%');\nif ($gOPD$1) {\n\ttry {\n\t\t$gOPD$1([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD$1 = null;\n\t}\n}\n\nvar getOwnPropertyDescriptor = $gOPD$1;\n\nvar $Object$1 = GetIntrinsic('%Object%');\n\n\n\nvar $preventExtensions = $Object$1.preventExtensions;\nvar $isExtensible = $Object$1.isExtensible;\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isextensible-o\n\nvar IsExtensible = $preventExtensions\n\t? function IsExtensible(obj) {\n\t\treturn !isPrimitive(obj) && $isExtensible(obj);\n\t}\n\t: function IsExtensible(obj) {\n\t\treturn !isPrimitive(obj);\n\t};\n\nvar $TypeError$i = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5\n\nvar ToPropertyDescriptor = function ToPropertyDescriptor(Obj) {\n\tif (Type$1(Obj) !== 'Object') {\n\t\tthrow new $TypeError$i('ToPropertyDescriptor requires an object');\n\t}\n\n\tvar desc = {};\n\tif (src(Obj, 'enumerable')) {\n\t\tdesc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);\n\t}\n\tif (src(Obj, 'configurable')) {\n\t\tdesc['[[Configurable]]'] = ToBoolean(Obj.configurable);\n\t}\n\tif (src(Obj, 'value')) {\n\t\tdesc['[[Value]]'] = Obj.value;\n\t}\n\tif (src(Obj, 'writable')) {\n\t\tdesc['[[Writable]]'] = ToBoolean(Obj.writable);\n\t}\n\tif (src(Obj, 'get')) {\n\t\tvar getter = Obj.get;\n\t\tif (typeof getter !== 'undefined' && !IsCallable(getter)) {\n\t\t\tthrow new TypeError('getter must be a function');\n\t\t}\n\t\tdesc['[[Get]]'] = getter;\n\t}\n\tif (src(Obj, 'set')) {\n\t\tvar setter = Obj.set;\n\t\tif (typeof setter !== 'undefined' && !IsCallable(setter)) {\n\t\t\tthrow new $TypeError$i('setter must be a function');\n\t\t}\n\t\tdesc['[[Set]]'] = setter;\n\t}\n\n\tif ((src(desc, '[[Get]]') || src(desc, '[[Set]]')) && (src(desc, '[[Value]]') || src(desc, '[[Writable]]'))) {\n\t\tthrow new $TypeError$i('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');\n\t}\n\treturn desc;\n};\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.12\n\nvar SameValue = function SameValue(x, y) {\n\tif (x === y) { // 0 === -0, but they are not identical.\n\t\tif (x === 0) { return 1 / x === 1 / y; }\n\t\treturn true;\n\t}\n\treturn _isNaN(x) && _isNaN(y);\n};\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\n\n\nvar $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');\n\n// eslint-disable-next-line max-params\nvar DefineOwnProperty = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {\n\tif (!$defineProperty) {\n\t\tif (!IsDataDescriptor(desc)) {\n\t\t\t// ES3 does not support getters/setters\n\t\t\treturn false;\n\t\t}\n\t\tif (!desc['[[Configurable]]'] || !desc['[[Writable]]']) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// fallback for ES3\n\t\tif (P in O && $isEnumerable(O, P) !== !!desc['[[Enumerable]]']) {\n\t\t\t// a non-enumerable existing property\n\t\t\treturn false;\n\t\t}\n\n\t\t// property does not exist at all, or exists but is enumerable\n\t\tvar V = desc['[[Value]]'];\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tO[P] = V; // will use [[Define]]\n\t\treturn SameValue(O[P], V);\n\t}\n\t$defineProperty(O, P, FromPropertyDescriptor(desc));\n\treturn true;\n};\n\nvar every = function every(array, predicate) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (!predicate(array[i], i, array)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nvar isSamePropertyDescriptor = function isSamePropertyDescriptor(ES, D1, D2) {\n\tvar fields = [\n\t\t'[[Configurable]]',\n\t\t'[[Enumerable]]',\n\t\t'[[Get]]',\n\t\t'[[Set]]',\n\t\t'[[Value]]',\n\t\t'[[Writable]]'\n\t];\n\treturn every(fields, function (field) {\n\t\tif ((field in D1) !== (field in D2)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn ES.SameValue(D1[field], D2[field]);\n\t});\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-frompropertydescriptor\n\nvar FromPropertyDescriptor = function FromPropertyDescriptor(Desc) {\n\tif (typeof Desc === 'undefined') {\n\t\treturn Desc;\n\t}\n\n\tassertRecord(Type$1, 'Property Descriptor', 'Desc', Desc);\n\n\tvar obj = {};\n\tif ('[[Value]]' in Desc) {\n\t\tobj.value = Desc['[[Value]]'];\n\t}\n\tif ('[[Writable]]' in Desc) {\n\t\tobj.writable = Desc['[[Writable]]'];\n\t}\n\tif ('[[Get]]' in Desc) {\n\t\tobj.get = Desc['[[Get]]'];\n\t}\n\tif ('[[Set]]' in Desc) {\n\t\tobj.set = Desc['[[Set]]'];\n\t}\n\tif ('[[Enumerable]]' in Desc) {\n\t\tobj.enumerable = Desc['[[Enumerable]]'];\n\t}\n\tif ('[[Configurable]]' in Desc) {\n\t\tobj.configurable = Desc['[[Configurable]]'];\n\t}\n\treturn obj;\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isgenericdescriptor\n\nvar IsGenericDescriptor = function IsGenericDescriptor(Desc) {\n\tif (typeof Desc === 'undefined') {\n\t\treturn false;\n\t}\n\n\tassertRecord(Type$1, 'Property Descriptor', 'Desc', Desc);\n\n\tif (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nvar $TypeError$j = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-validateandapplypropertydescriptor\n// https://www.ecma-international.org/ecma-262/8.0/#sec-validateandapplypropertydescriptor\n\n// eslint-disable-next-line max-lines-per-function, max-statements, max-params\nvar ValidateAndApplyPropertyDescriptor = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {\n\t// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.\n\tvar oType = Type$1(O);\n\tif (oType !== 'Undefined' && oType !== 'Object') {\n\t\tthrow new $TypeError$j('Assertion failed: O must be undefined or an Object');\n\t}\n\tif (Type$1(extensible) !== 'Boolean') {\n\t\tthrow new $TypeError$j('Assertion failed: extensible must be a Boolean');\n\t}\n\tif (!isPropertyDescriptor({\n\t\tType: Type$1,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, Desc)) {\n\t\tthrow new $TypeError$j('Assertion failed: Desc must be a Property Descriptor');\n\t}\n\tif (Type$1(current) !== 'Undefined' && !isPropertyDescriptor({\n\t\tType: Type$1,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, current)) {\n\t\tthrow new $TypeError$j('Assertion failed: current must be a Property Descriptor, or undefined');\n\t}\n\tif (oType !== 'Undefined' && !IsPropertyKey(P)) {\n\t\tthrow new $TypeError$j('Assertion failed: if O is not undefined, P must be a Property Key');\n\t}\n\tif (Type$1(current) === 'Undefined') {\n\t\tif (!extensible) {\n\t\t\treturn false;\n\t\t}\n\t\tif (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {\n\t\t\tif (oType !== 'Undefined') {\n\t\t\t\tDefineOwnProperty(\n\t\t\t\t\tIsDataDescriptor,\n\t\t\t\t\tSameValue,\n\t\t\t\t\tFromPropertyDescriptor,\n\t\t\t\t\tO,\n\t\t\t\t\tP,\n\t\t\t\t\t{\n\t\t\t\t\t\t'[[Configurable]]': Desc['[[Configurable]]'],\n\t\t\t\t\t\t'[[Enumerable]]': Desc['[[Enumerable]]'],\n\t\t\t\t\t\t'[[Value]]': Desc['[[Value]]'],\n\t\t\t\t\t\t'[[Writable]]': Desc['[[Writable]]']\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!IsAccessorDescriptor(Desc)) {\n\t\t\t\tthrow new $TypeError$j('Assertion failed: Desc is not an accessor descriptor');\n\t\t\t}\n\t\t\tif (oType !== 'Undefined') {\n\t\t\t\treturn DefineOwnProperty(\n\t\t\t\t\tIsDataDescriptor,\n\t\t\t\t\tSameValue,\n\t\t\t\t\tFromPropertyDescriptor,\n\t\t\t\t\tO,\n\t\t\t\t\tP,\n\t\t\t\t\tDesc\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tif (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {\n\t\treturn true;\n\t}\n\tif (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {\n\t\treturn true; // removed by ES2017, but should still be correct\n\t}\n\t// \"if every field in Desc is absent, return true\" can't really match the assertion that it's a Property Descriptor\n\tif (!current['[[Configurable]]']) {\n\t\tif (Desc['[[Configurable]]']) {\n\t\t\treturn false;\n\t\t}\n\t\tif ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsGenericDescriptor(Desc)) ; else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {\n\t\tif (!current['[[Configurable]]']) {\n\t\t\treturn false;\n\t\t}\n\t\tif (IsDataDescriptor(current)) {\n\t\t\tif (oType !== 'Undefined') {\n\t\t\t\tDefineOwnProperty(\n\t\t\t\t\tIsDataDescriptor,\n\t\t\t\t\tSameValue,\n\t\t\t\t\tFromPropertyDescriptor,\n\t\t\t\t\tO,\n\t\t\t\t\tP,\n\t\t\t\t\t{\n\t\t\t\t\t\t'[[Configurable]]': current['[[Configurable]]'],\n\t\t\t\t\t\t'[[Enumerable]]': current['[[Enumerable]]'],\n\t\t\t\t\t\t'[[Get]]': undefined\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (oType !== 'Undefined') {\n\t\t\tDefineOwnProperty(\n\t\t\t\tIsDataDescriptor,\n\t\t\t\tSameValue,\n\t\t\t\tFromPropertyDescriptor,\n\t\t\t\tO,\n\t\t\t\tP,\n\t\t\t\t{\n\t\t\t\t\t'[[Configurable]]': current['[[Configurable]]'],\n\t\t\t\t\t'[[Enumerable]]': current['[[Enumerable]]'],\n\t\t\t\t\t'[[Value]]': undefined\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {\n\t\tif (!current['[[Configurable]]'] && !current['[[Writable]]']) {\n\t\t\tif ('[[Writable]]' in Desc && Desc['[[Writable]]']) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {\n\t\tif (!current['[[Configurable]]']) {\n\t\t\tif ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tthrow new $TypeError$j('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');\n\t}\n\tif (oType !== 'Undefined') {\n\t\treturn DefineOwnProperty(\n\t\t\tIsDataDescriptor,\n\t\t\tSameValue,\n\t\t\tFromPropertyDescriptor,\n\t\t\tO,\n\t\t\tP,\n\t\t\tDesc\n\t\t);\n\t}\n\treturn true;\n};\n\nvar $SyntaxError$2 = GetIntrinsic('%SyntaxError%');\nvar $TypeError$k = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinarydefineownproperty\n\nvar OrdinaryDefineOwnProperty = function OrdinaryDefineOwnProperty(O, P, Desc) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$k('Assertion failed: O must be an Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$k('Assertion failed: P must be a Property Key');\n\t}\n\tif (!isPropertyDescriptor({\n\t\tType: Type$1,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, Desc)) {\n\t\tthrow new $TypeError$k('Assertion failed: Desc must be a Property Descriptor');\n\t}\n\tif (!getOwnPropertyDescriptor) {\n\t\t// ES3/IE 8 fallback\n\t\tif (IsAccessorDescriptor(Desc)) {\n\t\t\tthrow new $SyntaxError$2('This environment does not support accessor property descriptors.');\n\t\t}\n\t\tvar creatingNormalDataProperty = !(P in O)\n\t\t\t&& Desc['[[Writable]]']\n\t\t\t&& Desc['[[Enumerable]]']\n\t\t\t&& Desc['[[Configurable]]']\n\t\t\t&& '[[Value]]' in Desc;\n\t\tvar settingExistingDataProperty = (P in O)\n\t\t\t&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])\n\t\t\t&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])\n\t\t\t&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])\n\t\t\t&& '[[Value]]' in Desc;\n\t\tif (creatingNormalDataProperty || settingExistingDataProperty) {\n\t\t\tO[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign\n\t\t\treturn SameValue(O[P], Desc['[[Value]]']);\n\t\t}\n\t\tthrow new $SyntaxError$2('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');\n\t}\n\tvar desc = getOwnPropertyDescriptor(O, P);\n\tvar current = desc && ToPropertyDescriptor(desc);\n\tvar extensible = IsExtensible(O);\n\treturn ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);\n};\n\nvar hasSymbols$6 = hasSymbols();\nvar hasToStringTag$2 = hasSymbols$6 && typeof Symbol.toStringTag === 'symbol';\nvar regexExec;\nvar isRegexMarker;\nvar badStringifier;\n\nif (hasToStringTag$2) {\n\tregexExec = Function.call.bind(RegExp.prototype.exec);\n\tisRegexMarker = {};\n\n\tvar throwRegexMarker = function () {\n\t\tthrow isRegexMarker;\n\t};\n\tbadStringifier = {\n\t\ttoString: throwRegexMarker,\n\t\tvalueOf: throwRegexMarker\n\t};\n\n\tif (typeof Symbol.toPrimitive === 'symbol') {\n\t\tbadStringifier[Symbol.toPrimitive] = throwRegexMarker;\n\t}\n}\n\nvar toStr$8 = Object.prototype.toString;\nvar regexClass = '[object RegExp]';\n\nvar isRegex = hasToStringTag$2\n\t// eslint-disable-next-line consistent-return\n\t? function isRegex(value) {\n\t\tif (!value || typeof value !== 'object') {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\tregexExec(value, badStringifier);\n\t\t} catch (e) {\n\t\t\treturn e === isRegexMarker;\n\t\t}\n\t}\n\t: function isRegex(value) {\n\t\t// In older browsers, typeof regex incorrectly returns 'function'\n\t\tif (!value || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn toStr$8.call(value) === regexClass;\n\t};\n\nvar $match = GetIntrinsic('%Symbol.match%', true);\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-isregexp\n\nvar IsRegExp = function IsRegExp(argument) {\n\tif (!argument || typeof argument !== 'object') {\n\t\treturn false;\n\t}\n\tif ($match) {\n\t\tvar isRegExp = argument[$match];\n\t\tif (typeof isRegExp !== 'undefined') {\n\t\t\treturn ToBoolean(isRegExp);\n\t\t}\n\t}\n\treturn isRegex(argument);\n};\n\nvar $TypeError$l = GetIntrinsic('%TypeError%');\n\n\n\nvar $isEnumerable$1 = callBound('Object.prototype.propertyIsEnumerable');\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinarygetownproperty\n\nvar OrdinaryGetOwnProperty = function OrdinaryGetOwnProperty(O, P) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$l('Assertion failed: O must be an Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$l('Assertion failed: P must be a Property Key');\n\t}\n\tif (!src(O, P)) {\n\t\treturn void 0;\n\t}\n\tif (!getOwnPropertyDescriptor) {\n\t\t// ES3 / IE 8 fallback\n\t\tvar arrayLength = IsArray(O) && P === 'length';\n\t\tvar regexLastIndex = IsRegExp(O) && P === 'lastIndex';\n\t\treturn {\n\t\t\t'[[Configurable]]': !(arrayLength || regexLastIndex),\n\t\t\t'[[Enumerable]]': $isEnumerable$1(O, P),\n\t\t\t'[[Value]]': O[P],\n\t\t\t'[[Writable]]': true\n\t\t};\n\t}\n\treturn ToPropertyDescriptor(getOwnPropertyDescriptor(O, P));\n};\n\nvar $String = GetIntrinsic('%String%');\nvar $TypeError$m = GetIntrinsic('%TypeError%');\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n\nvar ToString = function ToString(argument) {\n\tif (typeof argument === 'symbol') {\n\t\tthrow new $TypeError$m('Cannot convert a Symbol value to a string');\n\t}\n\treturn $String(argument);\n};\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.6\n\nvar ToUint32 = function ToUint32(x) {\n\treturn ToNumber(x) >>> 0;\n};\n\nvar $RangeError$1 = GetIntrinsic('%RangeError%');\nvar $TypeError$n = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-arraysetlength\n\n// eslint-disable-next-line max-statements, max-lines-per-function\nvar ArraySetLength = function ArraySetLength(A, Desc) {\n\tif (!IsArray(A)) {\n\t\tthrow new $TypeError$n('Assertion failed: A must be an Array');\n\t}\n\tif (!isPropertyDescriptor({\n\t\tType: Type$1,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, Desc)) {\n\t\tthrow new $TypeError$n('Assertion failed: Desc must be a Property Descriptor');\n\t}\n\tif (!('[[Value]]' in Desc)) {\n\t\treturn OrdinaryDefineOwnProperty(A, 'length', Desc);\n\t}\n\tvar newLenDesc = object_assign({}, Desc);\n\tvar newLen = ToUint32(Desc['[[Value]]']);\n\tvar numberLen = ToNumber(Desc['[[Value]]']);\n\tif (newLen !== numberLen) {\n\t\tthrow new $RangeError$1('Invalid array length');\n\t}\n\tnewLenDesc['[[Value]]'] = newLen;\n\tvar oldLenDesc = OrdinaryGetOwnProperty(A, 'length');\n\tif (!IsDataDescriptor(oldLenDesc)) {\n\t\tthrow new $TypeError$n('Assertion failed: an array had a non-data descriptor on `length`');\n\t}\n\tvar oldLen = oldLenDesc['[[Value]]'];\n\tif (newLen >= oldLen) {\n\t\treturn OrdinaryDefineOwnProperty(A, 'length', newLenDesc);\n\t}\n\tif (!oldLenDesc['[[Writable]]']) {\n\t\treturn false;\n\t}\n\tvar newWritable;\n\tif (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {\n\t\tnewWritable = true;\n\t} else {\n\t\tnewWritable = false;\n\t\tnewLenDesc['[[Writable]]'] = true;\n\t}\n\tvar succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);\n\tif (!succeeded) {\n\t\treturn false;\n\t}\n\twhile (newLen < oldLen) {\n\t\toldLen -= 1;\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tvar deleteSucceeded = delete A[ToString(oldLen)];\n\t\tif (!deleteSucceeded) {\n\t\t\tnewLenDesc['[[Value]]'] = oldLen + 1;\n\t\t\tif (!newWritable) {\n\t\t\t\tnewLenDesc['[[Writable]]'] = false;\n\t\t\t\tOrdinaryDefineOwnProperty(A, 'length', newLenDesc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!newWritable) {\n\t\treturn OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });\n\t}\n\treturn true;\n};\n\nvar $TypeError$o = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow\n\nvar DefinePropertyOrThrow = function DefinePropertyOrThrow(O, P, desc) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$o('Assertion failed: Type(O) is not Object');\n\t}\n\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$o('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\n\tvar Desc = isPropertyDescriptor({\n\t\tType: Type$1,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, desc) ? desc : ToPropertyDescriptor(desc);\n\tif (!isPropertyDescriptor({\n\t\tType: Type$1,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, Desc)) {\n\t\tthrow new $TypeError$o('Assertion failed: Desc is not a valid Property Descriptor');\n\t}\n\n\treturn DefineOwnProperty(\n\t\tIsDataDescriptor,\n\t\tSameValue,\n\t\tFromPropertyDescriptor,\n\t\tO,\n\t\tP,\n\t\tDesc\n\t);\n};\n\nvar IsConstructor = createCommonjsModule(function (module) {\n\n\n\nvar $construct = GetIntrinsic('%Reflect.construct%', true);\n\nvar DefinePropertyOrThrow$1 = DefinePropertyOrThrow;\ntry {\n\tDefinePropertyOrThrow$1({}, '', { '[[Get]]': function () {} });\n} catch (e) {\n\t// Accessor properties aren't supported\n\tDefinePropertyOrThrow$1 = null;\n}\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor\n\nif (DefinePropertyOrThrow$1 && $construct) {\n\tvar isConstructorMarker = {};\n\tvar badArrayLike = {};\n\tDefinePropertyOrThrow$1(badArrayLike, 'length', {\n\t\t'[[Get]]': function () {\n\t\t\tthrow isConstructorMarker;\n\t\t},\n\t\t'[[Enumerable]]': true\n\t});\n\n\tmodule.exports = function IsConstructor(argument) {\n\t\ttry {\n\t\t\t// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:\n\t\t\t$construct(argument, badArrayLike);\n\t\t} catch (err) {\n\t\t\treturn err === isConstructorMarker;\n\t\t}\n\t};\n} else {\n\tmodule.exports = function IsConstructor(argument) {\n\t\t// unfortunately there's no way to truly check this without try/catch `new argument` in old environments\n\t\treturn typeof argument === 'function' && !!argument.prototype;\n\t};\n}\n});\n\nvar $Array$1 = GetIntrinsic('%Array%');\nvar $species = GetIntrinsic('%Symbol.species%', true);\nvar $TypeError$p = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate\n\nvar ArraySpeciesCreate = function ArraySpeciesCreate(originalArray, length) {\n\tif (!IsInteger(length) || length < 0) {\n\t\tthrow new $TypeError$p('Assertion failed: length must be an integer >= 0');\n\t}\n\tvar len = length === 0 ? 0 : length;\n\tvar C;\n\tvar isArray = IsArray(originalArray);\n\tif (isArray) {\n\t\tC = Get(originalArray, 'constructor');\n\t\t// TODO: figure out how to make a cross-realm normal Array, a same-realm Array\n\t\t// if (IsConstructor(C)) {\n\t\t// \tif C is another realm's Array, C = undefined\n\t\t// \tObject.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?\n\t\t// }\n\t\tif ($species && Type$1(C) === 'Object') {\n\t\t\tC = Get(C, $species);\n\t\t\tif (C === null) {\n\t\t\t\tC = void 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (typeof C === 'undefined') {\n\t\treturn $Array$1(len);\n\t}\n\tif (!IsConstructor(C)) {\n\t\tthrow new $TypeError$p('C must be a constructor');\n\t}\n\treturn new C(len); // Construct(C, len);\n};\n\nvar $TypeError$q = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring\n\nvar CanonicalNumericIndexString = function CanonicalNumericIndexString(argument) {\n\tif (Type$1(argument) !== 'String') {\n\t\tthrow new $TypeError$q('Assertion failed: `argument` must be a String');\n\t}\n\tif (argument === '-0') { return -0; }\n\tvar n = ToNumber(argument);\n\tif (SameValue(ToString(n), argument)) { return n; }\n\treturn void 0;\n};\n\n// https://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor\n\nvar CompletePropertyDescriptor = function CompletePropertyDescriptor(Desc) {\n\t/* eslint no-param-reassign: 0 */\n\tassertRecord(Type$1, 'Property Descriptor', 'Desc', Desc);\n\n\tif (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {\n\t\tif (!src(Desc, '[[Value]]')) {\n\t\t\tDesc['[[Value]]'] = void 0;\n\t\t}\n\t\tif (!src(Desc, '[[Writable]]')) {\n\t\t\tDesc['[[Writable]]'] = false;\n\t\t}\n\t} else {\n\t\tif (!src(Desc, '[[Get]]')) {\n\t\t\tDesc['[[Get]]'] = void 0;\n\t\t}\n\t\tif (!src(Desc, '[[Set]]')) {\n\t\t\tDesc['[[Set]]'] = void 0;\n\t\t}\n\t}\n\tif (!src(Desc, '[[Enumerable]]')) {\n\t\tDesc['[[Enumerable]]'] = false;\n\t}\n\tif (!src(Desc, '[[Configurable]]')) {\n\t\tDesc['[[Configurable]]'] = false;\n\t}\n\treturn Desc;\n};\n\nvar forEach = function forEach(array, callback) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tcallback(array[i], i, array); // eslint-disable-line callback-return\n\t}\n};\n\nvar $ownKeys = GetIntrinsic('%Reflect.ownKeys%', true);\nvar $pushApply = callBind.apply(GetIntrinsic('%Array.prototype.push%'));\nvar $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);\nvar $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);\nvar $gOPS = $SymbolValueOf ? GetIntrinsic('%Object.getOwnPropertySymbols%') : null;\n\n\n\nvar OwnPropertyKeys = $ownKeys || function OwnPropertyKeys(source) {\n\tvar ownKeys = ($gOPN || objectKeys)(source);\n\tif ($gOPS) {\n\t\t$pushApply(ownKeys, $gOPS(source));\n\t}\n\treturn ownKeys;\n};\n\nvar $TypeError$r = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-createdataproperty\n\nvar CreateDataProperty = function CreateDataProperty(O, P, V) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$r('Assertion failed: Type(O) is not Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$r('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\tvar oldDesc = OrdinaryGetOwnProperty(O, P);\n\tvar extensible = !oldDesc || IsExtensible(O);\n\tvar immutable = oldDesc && (!oldDesc['[[Writable]]'] || !oldDesc['[[Configurable]]']);\n\tif (immutable || !extensible) {\n\t\treturn false;\n\t}\n\treturn DefineOwnProperty(\n\t\tIsDataDescriptor,\n\t\tSameValue,\n\t\tFromPropertyDescriptor,\n\t\tO,\n\t\tP,\n\t\t{\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Value]]': V,\n\t\t\t'[[Writable]]': true\n\t\t}\n\t);\n};\n\nvar $isEnumerable$2 = callBound('Object.prototype.propertyIsEnumerable');\n\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/9.0/#sec-copydataproperties\n\nvar CopyDataProperties = function CopyDataProperties(target, source, excludedItems) {\n\tif (Type$1(target) !== 'Object') {\n\t\tthrow new TypeError('Assertion failed: \"target\" must be an Object');\n\t}\n\n\tif (!IsArray(excludedItems)) {\n\t\tthrow new TypeError('Assertion failed: \"excludedItems\" must be a List of Property Keys');\n\t}\n\tfor (var i = 0; i < excludedItems.length; i += 1) {\n\t\tif (!IsPropertyKey(excludedItems[i])) {\n\t\t\tthrow new TypeError('Assertion failed: \"excludedItems\" must be a List of Property Keys');\n\t\t}\n\t}\n\n\tif (typeof source === 'undefined' || source === null) {\n\t\treturn target;\n\t}\n\n\tvar fromObj = ToObject(source);\n\n\tvar sourceKeys = OwnPropertyKeys(fromObj);\n\tforEach(sourceKeys, function (nextKey) {\n\t\tvar excluded = false;\n\n\t\tforEach(excludedItems, function (e) {\n\t\t\tif (SameValue(e, nextKey) === true) {\n\t\t\t\texcluded = true;\n\t\t\t}\n\t\t});\n\n\t\tvar enumerable = $isEnumerable$2(fromObj, nextKey) || (\n\t\t// this is to handle string keys being non-enumerable in older engines\n\t\t\ttypeof source === 'string'\n            && nextKey >= 0\n            && IsInteger(ToNumber(nextKey))\n\t\t);\n\t\tif (excluded === false && enumerable) {\n\t\t\tvar propValue = Get(fromObj, nextKey);\n\t\t\tCreateDataProperty(target, nextKey, propValue);\n\t\t}\n\t});\n\n\treturn target;\n};\n\nvar $TypeError$s = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// // https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow\n\nvar CreateDataPropertyOrThrow = function CreateDataPropertyOrThrow(O, P, V) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$s('Assertion failed: Type(O) is not Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$s('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\tvar success = CreateDataProperty(O, P, V);\n\tif (!success) {\n\t\tthrow new $TypeError$s('unable to create data property');\n\t}\n\treturn success;\n};\n\nvar $TypeError$t = GetIntrinsic('%TypeError%');\n\n\n\nvar $replace$2 = callBound('String.prototype.replace');\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-createhtml\n\nvar CreateHTML = function CreateHTML(string, tag, attribute, value) {\n\tif (Type$1(tag) !== 'String' || Type$1(attribute) !== 'String') {\n\t\tthrow new $TypeError$t('Assertion failed: `tag` and `attribute` must be strings');\n\t}\n\tvar str = RequireObjectCoercible(string);\n\tvar S = ToString(str);\n\tvar p1 = '<' + tag;\n\tif (attribute !== '') {\n\t\tvar V = ToString(value);\n\t\tvar escapedV = $replace$2(V, /\\x22/g, '&quot;');\n\t\tp1 += '\\x20' + attribute + '\\x3D\\x22' + escapedV + '\\x22';\n\t}\n\treturn p1 + '>' + S + '</' + tag + '>';\n};\n\nvar $TypeError$u = GetIntrinsic('%TypeError%');\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject\n\nvar CreateIterResultObject = function CreateIterResultObject(value, done) {\n\tif (Type$1(done) !== 'Boolean') {\n\t\tthrow new $TypeError$u('Assertion failed: Type(done) is not Boolean');\n\t}\n\treturn {\n\t\tvalue: value,\n\t\tdone: done\n\t};\n};\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.3\n\nvar ToNumber$1 = function ToNumber(value) {\n\treturn +value; // eslint-disable-line no-implicit-coercion\n};\n\nvar sign = function sign(number) {\n\treturn number >= 0 ? 1 : -1;\n};\n\nvar $Math$2 = GetIntrinsic('%Math%');\n\n\n\n\n\n\nvar $floor$1 = $Math$2.floor;\nvar $abs$1 = $Math$2.abs;\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.4\n\nvar ToInteger = function ToInteger(value) {\n\tvar number = ToNumber$1(value);\n\tif (_isNaN(number)) { return 0; }\n\tif (number === 0 || !_isFinite(number)) { return number; }\n\treturn sign(number) * $floor$1($abs$1(number));\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-tointeger\n\nvar ToInteger$1 = function ToInteger$1(value) {\n\tvar number = ToNumber(value);\n\treturn ToInteger(number);\n};\n\nvar ToLength = function ToLength(argument) {\n\tvar len = ToInteger$1(argument);\n\tif (len <= 0) { return 0; } // includes converting -0 to +0\n\tif (len > maxSafeInteger) { return maxSafeInteger; }\n\treturn len;\n};\n\nvar $TypeError$v = GetIntrinsic('%TypeError%');\nvar $indexOf$1 = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');\nvar $push = callBound('Array.prototype.push');\n\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-createlistfromarraylike\nvar CreateListFromArrayLike = function CreateListFromArrayLike(obj) {\n\tvar elementTypes = arguments.length > 1\n\t\t? arguments[1]\n\t\t: ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];\n\n\tif (Type$1(obj) !== 'Object') {\n\t\tthrow new $TypeError$v('Assertion failed: `obj` must be an Object');\n\t}\n\tif (!IsArray(elementTypes)) {\n\t\tthrow new $TypeError$v('Assertion failed: `elementTypes`, if provided, must be an array');\n\t}\n\tvar len = ToLength(Get(obj, 'length'));\n\tvar list = [];\n\tvar index = 0;\n\twhile (index < len) {\n\t\tvar indexName = ToString(index);\n\t\tvar next = Get(obj, indexName);\n\t\tvar nextType = Type$1(next);\n\t\tif ($indexOf$1(elementTypes, nextType) < 0) {\n\t\t\tthrow new $TypeError$v('item type ' + nextType + ' is not a valid elementType');\n\t\t}\n\t\t$push(list, next);\n\t\tindex += 1;\n\t}\n\treturn list;\n};\n\nvar $TypeError$w = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-createmethodproperty\n\nvar CreateMethodProperty = function CreateMethodProperty(O, P, V) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$w('Assertion failed: Type(O) is not Object');\n\t}\n\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$w('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\n\tvar newDesc = {\n\t\t'[[Configurable]]': true,\n\t\t'[[Enumerable]]': false,\n\t\t'[[Value]]': V,\n\t\t'[[Writable]]': true\n\t};\n\treturn DefineOwnProperty(\n\t\tIsDataDescriptor,\n\t\tSameValue,\n\t\tFromPropertyDescriptor,\n\t\tO,\n\t\tP,\n\t\tnewDesc\n\t);\n};\n\nvar HoursPerDay = 24;\nvar MinutesPerHour = 60;\nvar SecondsPerMinute = 60;\nvar msPerSecond = 1e3;\nvar msPerMinute = msPerSecond * SecondsPerMinute;\nvar msPerHour = msPerMinute * MinutesPerHour;\nvar msPerDay = 86400000;\n\nvar timeConstants = {\n\tHoursPerDay: HoursPerDay,\n\tMinutesPerHour: MinutesPerHour,\n\tSecondsPerMinute: SecondsPerMinute,\n\tmsPerSecond: msPerSecond,\n\tmsPerMinute: msPerMinute,\n\tmsPerHour: msPerHour,\n\tmsPerDay: msPerDay\n};\n\nvar $floor$2 = GetIntrinsic('%Math.floor%');\n\nvar msPerDay$1 = timeConstants.msPerDay;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.2\n\nvar Day = function Day(t) {\n\treturn $floor$2(t / msPerDay$1);\n};\n\nvar $floor$3 = GetIntrinsic('%Math.floor%');\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3\n\nvar DayFromYear = function DayFromYear(y) {\n\treturn (365 * (y - 1970)) + $floor$3((y - 1969) / 4) - $floor$3((y - 1901) / 100) + $floor$3((y - 1601) / 400);\n};\n\nvar $Date = GetIntrinsic('%Date%');\n\n\n\nvar $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3\n\nvar YearFromTime = function YearFromTime(t) {\n\t// largest y such that this.TimeFromYear(y) <= t\n\treturn $getUTCFullYear(new $Date(t));\n};\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.4\n\nvar DayWithinYear = function DayWithinYear(t) {\n\treturn Day(t) - DayFromYear(YearFromTime(t));\n};\n\nvar $floor$4 = Math.floor;\n\nvar mod = function mod(number, modulo) {\n\tvar remain = number % modulo;\n\treturn $floor$4(remain >= 0 ? remain : remain + modulo);\n};\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3\n\nvar DaysInYear = function DaysInYear(y) {\n\tif (mod(y, 4) !== 0) {\n\t\treturn 365;\n\t}\n\tif (mod(y, 100) !== 0) {\n\t\treturn 366;\n\t}\n\tif (mod(y, 400) !== 0) {\n\t\treturn 365;\n\t}\n\treturn 366;\n};\n\nvar $EvalError = GetIntrinsic('%EvalError%');\n\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3\n\nvar InLeapYear = function InLeapYear(t) {\n\tvar days = DaysInYear(YearFromTime(t));\n\tif (days === 365) {\n\t\treturn 0;\n\t}\n\tif (days === 366) {\n\t\treturn 1;\n\t}\n\tthrow new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);\n};\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.4\n\nvar MonthFromTime = function MonthFromTime(t) {\n\tvar day = DayWithinYear(t);\n\tif (0 <= day && day < 31) {\n\t\treturn 0;\n\t}\n\tvar leap = InLeapYear(t);\n\tif (31 <= day && day < (59 + leap)) {\n\t\treturn 1;\n\t}\n\tif ((59 + leap) <= day && day < (90 + leap)) {\n\t\treturn 2;\n\t}\n\tif ((90 + leap) <= day && day < (120 + leap)) {\n\t\treturn 3;\n\t}\n\tif ((120 + leap) <= day && day < (151 + leap)) {\n\t\treturn 4;\n\t}\n\tif ((151 + leap) <= day && day < (181 + leap)) {\n\t\treturn 5;\n\t}\n\tif ((181 + leap) <= day && day < (212 + leap)) {\n\t\treturn 6;\n\t}\n\tif ((212 + leap) <= day && day < (243 + leap)) {\n\t\treturn 7;\n\t}\n\tif ((243 + leap) <= day && day < (273 + leap)) {\n\t\treturn 8;\n\t}\n\tif ((273 + leap) <= day && day < (304 + leap)) {\n\t\treturn 9;\n\t}\n\tif ((304 + leap) <= day && day < (334 + leap)) {\n\t\treturn 10;\n\t}\n\tif ((334 + leap) <= day && day < (365 + leap)) {\n\t\treturn 11;\n\t}\n};\n\nvar $EvalError$1 = GetIntrinsic('%EvalError%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.5\n\nvar DateFromTime = function DateFromTime(t) {\n\tvar m = MonthFromTime(t);\n\tvar d = DayWithinYear(t);\n\tif (m === 0) {\n\t\treturn d + 1;\n\t}\n\tif (m === 1) {\n\t\treturn d - 30;\n\t}\n\tvar leap = InLeapYear(t);\n\tif (m === 2) {\n\t\treturn d - 58 - leap;\n\t}\n\tif (m === 3) {\n\t\treturn d - 89 - leap;\n\t}\n\tif (m === 4) {\n\t\treturn d - 119 - leap;\n\t}\n\tif (m === 5) {\n\t\treturn d - 150 - leap;\n\t}\n\tif (m === 6) {\n\t\treturn d - 180 - leap;\n\t}\n\tif (m === 7) {\n\t\treturn d - 211 - leap;\n\t}\n\tif (m === 8) {\n\t\treturn d - 242 - leap;\n\t}\n\tif (m === 9) {\n\t\treturn d - 272 - leap;\n\t}\n\tif (m === 10) {\n\t\treturn d - 303 - leap;\n\t}\n\tif (m === 11) {\n\t\treturn d - 333 - leap;\n\t}\n\tthrow new $EvalError$1('Assertion failed: MonthFromTime returned an impossible value: ' + m);\n};\n\nvar $strSlice$2 = callBound('String.prototype.slice');\n\nvar padTimeComponent = function padTimeComponent(c, count) {\n\treturn $strSlice$2('00' + c, -(count || 2));\n};\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.6\n\nvar WeekDay = function WeekDay(t) {\n\treturn mod(Day(t) + 4, 7);\n};\n\nvar $TypeError$x = GetIntrinsic('%TypeError%');\n\nvar weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/9.0/#sec-datestring\n\nvar DateString = function DateString(tv) {\n\tif (Type$1(tv) !== 'Number' || _isNaN(tv)) {\n\t\tthrow new $TypeError$x('Assertion failed: `tv` must be a non-NaN Number');\n\t}\n\tvar weekday = weekdays[WeekDay(tv)];\n\tvar month = months[MonthFromTime(tv)];\n\tvar day = padTimeComponent(DateFromTime(tv));\n\tvar year = padTimeComponent(YearFromTime(tv), 4);\n\treturn weekday + '\\x20' + month + '\\x20' + day + '\\x20' + year;\n};\n\nvar $TypeError$y = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-deletepropertyorthrow\n\nvar DeletePropertyOrThrow = function DeletePropertyOrThrow(O, P) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$y('Assertion failed: Type(O) is not Object');\n\t}\n\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$y('Assertion failed: IsPropertyKey(P) is not true');\n\t}\n\n\t// eslint-disable-next-line no-param-reassign\n\tvar success = delete O[P];\n\tif (!success) {\n\t\tthrow new $TypeError$y('Attempt to delete property failed.');\n\t}\n\treturn success;\n};\n\nvar $TypeError$z = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\nvar $isEnumerable$3 = callBound('Object.prototype.propertyIsEnumerable');\nvar $pushApply$1 = callBind.apply(GetIntrinsic('%Array.prototype.push%'));\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/8.0/#sec-enumerableownproperties\n\nvar EnumerableOwnPropertyNames = function EnumerableOwnProperties(O, kind) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$z('Assertion failed: Type(O) is not Object');\n\t}\n\n\tvar keys = objectKeys(O);\n\tif (kind === 'key') {\n\t\treturn keys;\n\t}\n\tif (kind === 'value' || kind === 'key+value') {\n\t\tvar results = [];\n\t\tforEach(keys, function (key) {\n\t\t\tif ($isEnumerable$3(O, key)) {\n\t\t\t\t$pushApply$1(results, [\n\t\t\t\t\tkind === 'value' ? O[key] : [key, O[key]]\n\t\t\t\t]);\n\t\t\t}\n\t\t});\n\t\treturn results;\n\t}\n\tthrow new $TypeError$z('Assertion failed: \"kind\" is not \"key\", \"value\", or \"key+value\": ' + kind);\n};\n\nvar $TypeError$A = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty\n\nvar HasProperty = function HasProperty(O, P) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$A('Assertion failed: `O` must be an Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$A('Assertion failed: `P` must be a Property Key');\n\t}\n\treturn P in O;\n};\n\nvar $TypeError$B = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/10.0/#sec-flattenintoarray\n\n// eslint-disable-next-line max-params, max-statements\nvar FlattenIntoArray = function FlattenIntoArray(target, source, sourceLen, start, depth) {\n\tvar mapperFunction;\n\tif (arguments.length > 5) {\n\t\tmapperFunction = arguments[5];\n\t}\n\n\tvar targetIndex = start;\n\tvar sourceIndex = 0;\n\twhile (sourceIndex < sourceLen) {\n\t\tvar P = ToString(sourceIndex);\n\t\tvar exists = HasProperty(source, P);\n\t\tif (exists === true) {\n\t\t\tvar element = Get(source, P);\n\t\t\tif (typeof mapperFunction !== 'undefined') {\n\t\t\t\tif (arguments.length <= 6) {\n\t\t\t\t\tthrow new $TypeError$B('Assertion failed: thisArg is required when mapperFunction is provided');\n\t\t\t\t}\n\t\t\t\telement = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);\n\t\t\t}\n\t\t\tvar shouldFlatten = false;\n\t\t\tif (depth > 0) {\n\t\t\t\tshouldFlatten = IsArray(element);\n\t\t\t}\n\t\t\tif (shouldFlatten) {\n\t\t\t\tvar elementLen = ToLength(Get(element, 'length'));\n\t\t\t\ttargetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);\n\t\t\t} else {\n\t\t\t\tif (targetIndex >= maxSafeInteger) {\n\t\t\t\t\tthrow new $TypeError$B('index too large');\n\t\t\t\t}\n\t\t\t\tCreateDataPropertyOrThrow(target, ToString(targetIndex), element);\n\t\t\t\ttargetIndex += 1;\n\t\t\t}\n\t\t}\n\t\tsourceIndex += 1;\n\t}\n\n\treturn targetIndex;\n};\n\nvar hasSymbols$7 = hasSymbols();\n\nvar $TypeError$C = GetIntrinsic('%TypeError%');\n\nvar $gOPN$1 = GetIntrinsic('%Object.getOwnPropertyNames%');\nvar $gOPS$1 = hasSymbols$7 && GetIntrinsic('%Object.getOwnPropertySymbols%');\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-getownpropertykeys\n\nvar GetOwnPropertyKeys = function GetOwnPropertyKeys(O, Type) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$C('Assertion failed: Type(O) is not Object');\n\t}\n\tif (Type === 'Symbol') {\n\t\treturn $gOPS$1 ? $gOPS$1(O) : [];\n\t}\n\tif (Type === 'String') {\n\t\tif (!$gOPN$1) {\n\t\t\treturn objectKeys(O);\n\t\t}\n\t\treturn $gOPN$1(O);\n\t}\n\tthrow new $TypeError$C('Assertion failed: `Type` must be `\"String\"` or `\"Symbol\"`');\n};\n\nvar $Function = GetIntrinsic('%Function%');\nvar $TypeError$D = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-getprototypefromconstructor\n\nvar GetPrototypeFromConstructor = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {\n\tvar intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic\n\tif (!IsConstructor(constructor)) {\n\t\tthrow new $TypeError$D('Assertion failed: `constructor` must be a constructor');\n\t}\n\tvar proto = Get(constructor, 'prototype');\n\tif (Type$1(proto) !== 'Object') {\n\t\tif (!(constructor instanceof $Function)) {\n\t\t\t// ignore other realms, for now\n\t\t\tthrow new $TypeError$D('cross-realm constructors not currently supported');\n\t\t}\n\t\tproto = intrinsic;\n\t}\n\treturn proto;\n};\n\nvar $TypeError$E = GetIntrinsic('%TypeError%');\n\n\n\n\n\nvar $charAt = callBound('String.prototype.charAt');\nvar $strSlice$3 = callBound('String.prototype.slice');\nvar $indexOf$2 = callBound('String.prototype.indexOf');\nvar $parseInt = parseInt;\n\nvar isDigit = regexTester(/^[0-9]$/);\n\n\n\n\n\n\n\n\n\n\nvar canDistinguishSparseFromUndefined = 0 in [undefined]; // IE 6 - 8 have a bug where this returns false\n\nvar isStringOrHole = function (capture, index, arr) {\n\treturn Type$1(capture) === 'String' || (canDistinguishSparseFromUndefined ? !(index in arr) : Type$1(capture) === 'Undefined');\n};\n\n// http://www.ecma-international.org/ecma-262/9.0/#sec-getsubstitution\n\n// eslint-disable-next-line max-statements, max-params, max-lines-per-function\nvar GetSubstitution = function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n\tif (Type$1(matched) !== 'String') {\n\t\tthrow new $TypeError$E('Assertion failed: `matched` must be a String');\n\t}\n\tvar matchLength = matched.length;\n\n\tif (Type$1(str) !== 'String') {\n\t\tthrow new $TypeError$E('Assertion failed: `str` must be a String');\n\t}\n\tvar stringLength = str.length;\n\n\tif (!IsInteger(position) || position < 0 || position > stringLength) {\n\t\tthrow new $TypeError$E('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + objectInspect(position));\n\t}\n\n\tif (!IsArray(captures) || !every(captures, isStringOrHole)) {\n\t\tthrow new $TypeError$E('Assertion failed: `captures` must be a List of Strings, got ' + objectInspect(captures));\n\t}\n\n\tif (Type$1(replacement) !== 'String') {\n\t\tthrow new $TypeError$E('Assertion failed: `replacement` must be a String');\n\t}\n\n\tvar tailPos = position + matchLength;\n\tvar m = captures.length;\n\tif (Type$1(namedCaptures) !== 'Undefined') {\n\t\tnamedCaptures = ToObject(namedCaptures); // eslint-disable-line no-param-reassign\n\t}\n\n\tvar result = '';\n\tfor (var i = 0; i < replacement.length; i += 1) {\n\t\t// if this is a $, and it's not the end of the replacement\n\t\tvar current = $charAt(replacement, i);\n\t\tvar isLast = (i + 1) >= replacement.length;\n\t\tvar nextIsLast = (i + 2) >= replacement.length;\n\t\tif (current === '$' && !isLast) {\n\t\t\tvar next = $charAt(replacement, i + 1);\n\t\t\tif (next === '$') {\n\t\t\t\tresult += '$';\n\t\t\t\ti += 1;\n\t\t\t} else if (next === '&') {\n\t\t\t\tresult += matched;\n\t\t\t\ti += 1;\n\t\t\t} else if (next === '`') {\n\t\t\t\tresult += position === 0 ? '' : $strSlice$3(str, 0, position - 1);\n\t\t\t\ti += 1;\n\t\t\t} else if (next === \"'\") {\n\t\t\t\tresult += tailPos >= stringLength ? '' : $strSlice$3(str, tailPos);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar nextNext = nextIsLast ? null : $charAt(replacement, i + 2);\n\t\t\t\tif (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {\n\t\t\t\t\t// $1 through $9, and not followed by a digit\n\t\t\t\t\tvar n = $parseInt(next, 10);\n\t\t\t\t\t// if (n > m, impl-defined)\n\t\t\t\t\tresult += (n <= m && Type$1(captures[n - 1]) === 'Undefined') ? '' : captures[n - 1];\n\t\t\t\t\ti += 1;\n\t\t\t\t} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {\n\t\t\t\t\t// $00 through $99\n\t\t\t\t\tvar nn = next + nextNext;\n\t\t\t\t\tvar nnI = $parseInt(nn, 10) - 1;\n\t\t\t\t\t// if nn === '00' or nn > m, impl-defined\n\t\t\t\t\tresult += (nn <= m && Type$1(captures[nnI]) === 'Undefined') ? '' : captures[nnI];\n\t\t\t\t\ti += 2;\n\t\t\t\t} else if (next === '<') {\n\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\tif (Type$1(namedCaptures) === 'Undefined') {\n\t\t\t\t\t\tresult += '$<';\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar endIndex = $indexOf$2(replacement, '>', i);\n\t\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\t\tif (endIndex > -1) {\n\t\t\t\t\t\t\tvar groupName = $strSlice$3(replacement, i, endIndex);\n\t\t\t\t\t\t\tvar capture = Get(namedCaptures, groupName);\n\t\t\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\t\t\tif (Type$1(capture) !== 'Undefined') {\n\t\t\t\t\t\t\t\tresult += ToString(capture);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti += '$<' + groupName + '>'.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult += '$';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// the final $, or else not a $\n\t\t\tresult += $charAt(replacement, i);\n\t\t}\n\t}\n\treturn result;\n};\n\nvar $TypeError$F = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-hasownproperty\n\nvar HasOwnProperty = function HasOwnProperty(O, P) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$F('Assertion failed: `O` must be an Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$F('Assertion failed: `P` must be a Property Key');\n\t}\n\treturn src(O, P);\n};\n\nvar $floor$5 = GetIntrinsic('%Math.floor%');\n\n\n\nvar msPerHour$1 = timeConstants.msPerHour;\nvar HoursPerDay$1 = timeConstants.HoursPerDay;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10\n\nvar HourFromTime = function HourFromTime(t) {\n\treturn mod($floor$5(t / msPerHour$1), HoursPerDay$1);\n};\n\nvar $TypeError$G = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinaryhasinstance\n\nvar OrdinaryHasInstance = function OrdinaryHasInstance(C, O) {\n\tif (IsCallable(C) === false) {\n\t\treturn false;\n\t}\n\tif (Type$1(O) !== 'Object') {\n\t\treturn false;\n\t}\n\tvar P = Get(C, 'prototype');\n\tif (Type$1(P) !== 'Object') {\n\t\tthrow new $TypeError$G('OrdinaryHasInstance called on an object with an invalid prototype property.');\n\t}\n\treturn O instanceof C;\n};\n\nvar $TypeError$H = GetIntrinsic('%TypeError%');\n\nvar $hasInstance = GetIntrinsic('Symbol.hasInstance', true);\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator\n\nvar InstanceofOperator = function InstanceofOperator(O, C) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$H('Assertion failed: Type(O) is not Object');\n\t}\n\tvar instOfHandler = $hasInstance ? GetMethod$1(C, $hasInstance) : void 0;\n\tif (typeof instOfHandler !== 'undefined') {\n\t\treturn ToBoolean(Call(instOfHandler, C, [O]));\n\t}\n\tif (!IsCallable(C)) {\n\t\tthrow new $TypeError$H('`C` is not Callable');\n\t}\n\treturn OrdinaryHasInstance(C, O);\n};\n\nvar $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable\n\nvar IsConcatSpreadable = function IsConcatSpreadable(O) {\n\tif (Type$1(O) !== 'Object') {\n\t\treturn false;\n\t}\n\tif ($isConcatSpreadable) {\n\t\tvar spreadable = Get(O, $isConcatSpreadable);\n\t\tif (typeof spreadable !== 'undefined') {\n\t\t\treturn ToBoolean(spreadable);\n\t\t}\n\t}\n\treturn IsArray(O);\n};\n\nvar $PromiseThen = callBound('Promise.prototype.then', true);\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-ispromise\n\nvar IsPromise = function IsPromise(x) {\n\tif (Type$1(x) !== 'Object') {\n\t\treturn false;\n\t}\n\tif (!$PromiseThen) { // Promises are not supported\n\t\treturn false;\n\t}\n\ttry {\n\t\t$PromiseThen(x); // throws if not a promise\n\t} catch (e) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\nvar $TypeError$I = GetIntrinsic('%TypeError%');\n\n\n\n// var callBound = require('../helpers/callBound');\n\n// var $charAt = callBound('String.prototype.charAt');\n\n\n\n// https://www.ecma-international.org/ecma-262/9.0/#sec-isstringprefix\n\nvar IsStringPrefix = function IsStringPrefix(p, q) {\n\tif (Type$1(p) !== 'String') {\n\t\tthrow new $TypeError$I('Assertion failed: \"p\" must be a String');\n\t}\n\n\tif (Type$1(q) !== 'String') {\n\t\tthrow new $TypeError$I('Assertion failed: \"q\" must be a String');\n\t}\n\n\treturn isPrefixOf(p, q);\n\t/*\n\tif (p === q || p === '') {\n\t\treturn true;\n\t}\n\n\tvar pLength = p.length;\n\tvar qLength = q.length;\n\tif (pLength >= qLength) {\n\t\treturn false;\n\t}\n\n\t// assert: pLength < qLength\n\n\tfor (var i = 0; i < pLength; i += 1) {\n\t\tif ($charAt(p, i) !== $charAt(q, i)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\t*/\n};\n\nvar $arrayPush = callBound('Array.prototype.push');\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/8.0/#sec-iterabletolist\n\nvar IterableToList = function IterableToList(items, method) {\n\tvar iterator = GetIterator(items, method);\n\tvar values = [];\n\tvar next = true;\n\twhile (next) {\n\t\tnext = IteratorStep(iterator);\n\t\tif (next) {\n\t\t\tvar nextValue = IteratorValue(next);\n\t\t\t$arrayPush(values, nextValue);\n\t\t}\n\t}\n\treturn values;\n};\n\nvar msPerDay$2 = timeConstants.msPerDay;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.13\n\nvar MakeDate = function MakeDate(day, time) {\n\tif (!_isFinite(day) || !_isFinite(time)) {\n\t\treturn NaN;\n\t}\n\treturn (day * msPerDay$2) + time;\n};\n\nvar $floor$6 = GetIntrinsic('%Math.floor%');\nvar $DateUTC = GetIntrinsic('%Date.UTC%');\n\n\n\n\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.12\n\nvar MakeDay = function MakeDay(year, month, date) {\n\tif (!_isFinite(year) || !_isFinite(month) || !_isFinite(date)) {\n\t\treturn NaN;\n\t}\n\tvar y = ToInteger$1(year);\n\tvar m = ToInteger$1(month);\n\tvar dt = ToInteger$1(date);\n\tvar ym = y + $floor$6(m / 12);\n\tvar mn = mod(m, 12);\n\tvar t = $DateUTC(ym, mn, 1);\n\tif (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {\n\t\treturn NaN;\n\t}\n\treturn Day(t) + dt - 1;\n};\n\nvar msPerSecond$1 = timeConstants.msPerSecond;\nvar msPerMinute$1 = timeConstants.msPerMinute;\nvar msPerHour$2 = timeConstants.msPerHour;\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.11\n\nvar MakeTime = function MakeTime(hour, min, sec, ms) {\n\tif (!_isFinite(hour) || !_isFinite(min) || !_isFinite(sec) || !_isFinite(ms)) {\n\t\treturn NaN;\n\t}\n\tvar h = ToInteger$1(hour);\n\tvar m = ToInteger$1(min);\n\tvar s = ToInteger$1(sec);\n\tvar milli = ToInteger$1(ms);\n\tvar t = (h * msPerHour$2) + (m * msPerMinute$1) + (s * msPerSecond$1) + milli;\n\treturn t;\n};\n\nvar $floor$7 = GetIntrinsic('%Math.floor%');\n\n\n\nvar msPerMinute$2 = timeConstants.msPerMinute;\nvar MinutesPerHour$1 = timeConstants.MinutesPerHour;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10\n\nvar MinFromTime = function MinFromTime(t) {\n\treturn mod($floor$7(t / msPerMinute$2), MinutesPerHour$1);\n};\n\n// https://ecma-international.org/ecma-262/5.1/#sec-5.2\n\nvar modulo = function modulo(x, y) {\n\treturn mod(x, y);\n};\n\nvar msPerSecond$2 = timeConstants.msPerSecond;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10\n\nvar msFromTime = function msFromTime(t) {\n\treturn mod(t, msPerSecond$2);\n};\n\nvar $String$1 = GetIntrinsic('%String%');\n\n\n\n// https://www.ecma-international.org/ecma-262/9.0/#sec-tostring-applied-to-the-number-type\n\nvar NumberToString = function NumberToString(m) {\n\tif (Type$1(m) !== 'Number') {\n\t\tthrow new TypeError('Assertion failed: \"m\" must be a String');\n\t}\n\n\treturn $String$1(m);\n};\n\nvar $ObjectCreate = GetIntrinsic('%Object.create%', true);\nvar $TypeError$J = GetIntrinsic('%TypeError%');\nvar $SyntaxError$3 = GetIntrinsic('%SyntaxError%');\n\n\n\nvar hasProto = !({ __proto__: null } instanceof Object);\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-objectcreate\n\nvar ObjectCreate = function ObjectCreate(proto, internalSlotsList) {\n\tif (proto !== null && Type$1(proto) !== 'Object') {\n\t\tthrow new $TypeError$J('Assertion failed: `proto` must be null or an object');\n\t}\n\tvar slots = arguments.length < 2 ? [] : internalSlotsList;\n\tif (slots.length > 0) {\n\t\tthrow new $SyntaxError$3('es-abstract does not yet support internal slots');\n\t}\n\n\tif ($ObjectCreate) {\n\t\treturn $ObjectCreate(proto);\n\t}\n\tif (hasProto) {\n\t\treturn { __proto__: proto };\n\t}\n\n\tif (proto === null) {\n\t\tthrow new $SyntaxError$3('native Object.create support is required to create null objects');\n\t}\n\tvar T = function T() {};\n\tT.prototype = proto;\n\treturn new T();\n};\n\nvar originalGetProto = GetIntrinsic('%Object.getPrototypeOf%', true);\nvar $ArrayProto = GetIntrinsic('%Array.prototype%');\n\nvar getProto$1 = originalGetProto || (\n\t// eslint-disable-next-line no-proto\n\t[].__proto__ === $ArrayProto\n\t\t? function (O) {\n\t\t\treturn O.__proto__; // eslint-disable-line no-proto\n\t\t}\n\t\t: null\n);\n\nvar $TypeError$K = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/7.0/#sec-ordinarygetprototypeof\n\nvar OrdinaryGetPrototypeOf = function OrdinaryGetPrototypeOf(O) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$K('Assertion failed: O must be an Object');\n\t}\n\tif (!getProto$1) {\n\t\tthrow new $TypeError$K('This environment does not support fetching prototypes.');\n\t}\n\treturn getProto$1(O);\n};\n\nvar originalSetProto = GetIntrinsic('%Object.setPrototypeOf%', true);\nvar $ArrayProto$1 = GetIntrinsic('%Array.prototype%');\n\nvar setProto = originalSetProto || (\n\t// eslint-disable-next-line no-proto, no-negated-condition\n\t[].__proto__ !== $ArrayProto$1\n\t\t? null\n\t\t: function (O, proto) {\n\t\t\tO.__proto__ = proto; // eslint-disable-line no-proto, no-param-reassign\n\t\t\treturn O;\n\t\t}\n);\n\nvar $TypeError$L = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/7.0/#sec-ordinarysetprototypeof\n\nvar OrdinarySetPrototypeOf = function OrdinarySetPrototypeOf(O, V) {\n\tif (Type$1(V) !== 'Object' && Type$1(V) !== 'Null') {\n\t\tthrow new $TypeError$L('Assertion failed: V must be Object or Null');\n\t}\n\t/*\n    var extensible = IsExtensible(O);\n    var current = OrdinaryGetPrototypeOf(O);\n    if (SameValue(V, current)) {\n        return true;\n    }\n    if (!extensible) {\n        return false;\n    }\n    */\n\ttry {\n\t\tsetProto(O, V);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\treturn OrdinaryGetPrototypeOf(O) === V;\n\t/*\n    var p = V;\n    var done = false;\n    while (!done) {\n        if (p === null) {\n            done = true;\n        } else if (SameValue(p, O)) {\n            return false;\n        } else {\n            if (wat) {\n                done = true;\n            } else {\n                p = p.[[Prototype]];\n            }\n        }\n     }\n     O.[[Prototype]] = V;\n     return true;\n     */\n};\n\nvar $TypeError$M = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinaryhasproperty\n\nvar OrdinaryHasProperty = function OrdinaryHasProperty(O, P) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$M('Assertion failed: Type(O) is not Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$M('Assertion failed: P must be a Property Key');\n\t}\n\treturn P in O;\n};\n\nvar $PromiseResolve = callBound('Promise.resolve', true);\n\n// https://ecma-international.org/ecma-262/9.0/#sec-promise-resolve\n\nvar PromiseResolve = function PromiseResolve(C, x) {\n\tif (!$PromiseResolve) {\n\t\tthrow new SyntaxError('This environment does not support Promises.');\n\t}\n\treturn $PromiseResolve(C, x);\n};\n\nvar $TypeError$N = GetIntrinsic('%TypeError%');\n\nvar regexExec$1 = callBound('RegExp.prototype.exec');\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-regexpexec\n\nvar RegExpExec = function RegExpExec(R, S) {\n\tif (Type$1(R) !== 'Object') {\n\t\tthrow new $TypeError$N('Assertion failed: `R` must be an Object');\n\t}\n\tif (Type$1(S) !== 'String') {\n\t\tthrow new $TypeError$N('Assertion failed: `S` must be a String');\n\t}\n\tvar exec = Get(R, 'exec');\n\tif (IsCallable(exec)) {\n\t\tvar result = Call(exec, R, [S]);\n\t\tif (result === null || Type$1(result) === 'Object') {\n\t\t\treturn result;\n\t\t}\n\t\tthrow new $TypeError$N('\"exec\" method must return `null` or an Object');\n\t}\n\treturn regexExec$1(R, S);\n};\n\nvar $TypeError$O = GetIntrinsic('%TypeError%');\n\n\n\n// https://www.ecma-international.org/ecma-262/7.0/#sec-samevaluenonnumber\n\nvar SameValueNonNumber = function SameValueNonNumber(x, y) {\n\tif (typeof x === 'number' || typeof x !== typeof y) {\n\t\tthrow new $TypeError$O('SameValueNonNumber requires two non-number values of the same type.');\n\t}\n\treturn SameValue(x, y);\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero\n\nvar SameValueZero = function SameValueZero(x, y) {\n\treturn (x === y) || (_isNaN(x) && _isNaN(y));\n};\n\nvar $floor$8 = GetIntrinsic('%Math.floor%');\n\n\n\nvar msPerSecond$3 = timeConstants.msPerSecond;\nvar SecondsPerMinute$1 = timeConstants.SecondsPerMinute;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10\n\nvar SecFromTime = function SecFromTime(t) {\n\treturn mod($floor$8(t / msPerSecond$3), SecondsPerMinute$1);\n};\n\nvar $TypeError$P = GetIntrinsic('%TypeError%');\n\n\n\n\n\n// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated\nvar noThrowOnStrictViolation = (function () {\n\ttry {\n\t\tdelete [].length;\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}());\n\n// https://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw\n\nvar _Set = function Set(O, P, V, Throw) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$P('Assertion failed: `O` must be an Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError$P('Assertion failed: `P` must be a Property Key');\n\t}\n\tif (Type$1(Throw) !== 'Boolean') {\n\t\tthrow new $TypeError$P('Assertion failed: `Throw` must be a Boolean');\n\t}\n\tif (Throw) {\n\t\tO[P] = V; // eslint-disable-line no-param-reassign\n\t\tif (noThrowOnStrictViolation && !SameValue(O[P], V)) {\n\t\t\tthrow new $TypeError$P('Attempted to assign to readonly property.');\n\t\t}\n\t\treturn true;\n\t} else {\n\t\ttry {\n\t\t\tO[P] = V; // eslint-disable-line no-param-reassign\n\t\t\treturn noThrowOnStrictViolation ? SameValue(O[P], V) : true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nvar getInferredName;\ntry {\n\t// eslint-disable-next-line no-new-func\n\tgetInferredName = Function('s', 'return { [s]() {} }[s].name;');\n} catch (e) {}\n\nvar inferred = function () {};\nvar getInferredName_1 = getInferredName && inferred.name === 'inferred' ? getInferredName : null;\n\nvar $SyntaxError$4 = GetIntrinsic('%SyntaxError%');\nvar getGlobalSymbolDescription = GetIntrinsic('%Symbol.keyFor%', true);\nvar thisSymbolValue = callBound('%Symbol.prototype.valueOf%', true);\nvar symToStr = callBound('Symbol.prototype.toString', true);\n\n\n\n/* eslint-disable consistent-return */\nvar getSymbolDescription = callBound('%Symbol.prototype.description%', true) || function getSymbolDescription(symbol) {\n\tif (!thisSymbolValue) {\n\t\tthrow new $SyntaxError$4('Symbols are not supported in this environment');\n\t}\n\n\t// will throw if not a symbol primitive or wrapper object\n\tvar sym = thisSymbolValue(symbol);\n\n\tif (getInferredName_1) {\n\t\tvar name = getInferredName_1(sym);\n\t\tif (name === '') { return; }\n\t\treturn name.slice(1, -1); // name.slice('['.length, -']'.length);\n\t}\n\n\tvar desc;\n\tif (getGlobalSymbolDescription) {\n\t\tdesc = getGlobalSymbolDescription(sym);\n\t\tif (typeof desc === 'string') {\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\tdesc = symToStr(sym).slice(7, -1); // str.slice('Symbol('.length, -')'.length);\n\tif (desc) {\n\t\treturn desc;\n\t}\n};\n\nvar $TypeError$Q = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-setfunctionname\n\nvar SetFunctionName = function SetFunctionName(F, name) {\n\tif (typeof F !== 'function') {\n\t\tthrow new $TypeError$Q('Assertion failed: `F` must be a function');\n\t}\n\tif (!IsExtensible(F) || src(F, 'name')) {\n\t\tthrow new $TypeError$Q('Assertion failed: `F` must be extensible, and must not have a `name` own property');\n\t}\n\tvar nameType = Type$1(name);\n\tif (nameType !== 'Symbol' && nameType !== 'String') {\n\t\tthrow new $TypeError$Q('Assertion failed: `name` must be a Symbol or a String');\n\t}\n\tif (nameType === 'Symbol') {\n\t\tvar description = getSymbolDescription(name);\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tname = typeof description === 'undefined' ? '' : '[' + description + ']';\n\t}\n\tif (arguments.length > 2) {\n\t\tvar prefix = arguments[2];\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tname = prefix + ' ' + name;\n\t}\n\treturn DefinePropertyOrThrow(F, 'name', {\n\t\t'[[Value]]': name,\n\t\t'[[Writable]]': false,\n\t\t'[[Enumerable]]': false,\n\t\t'[[Configurable]]': true\n\t});\n};\n\nvar $SyntaxError$5 = GetIntrinsic('%SyntaxError%');\nvar $TypeError$R = GetIntrinsic('%TypeError%');\nvar $preventExtensions$1 = GetIntrinsic('%Object.preventExtensions%');\n\nvar $gOPN$2 = GetIntrinsic('%Object.getOwnPropertyNames%');\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-setintegritylevel\n\nvar SetIntegrityLevel = function SetIntegrityLevel(O, level) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$R('Assertion failed: Type(O) is not Object');\n\t}\n\tif (level !== 'sealed' && level !== 'frozen') {\n\t\tthrow new $TypeError$R('Assertion failed: `level` must be `\"sealed\"` or `\"frozen\"`');\n\t}\n\tif (!$preventExtensions$1) {\n\t\tthrow new $SyntaxError$5('SetIntegrityLevel requires native `Object.preventExtensions` support');\n\t}\n\tvar status = $preventExtensions$1(O);\n\tif (!status) {\n\t\treturn false;\n\t}\n\tif (!$gOPN$2) {\n\t\tthrow new $SyntaxError$5('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');\n\t}\n\tvar theKeys = $gOPN$2(O);\n\tif (level === 'sealed') {\n\t\tforEach(theKeys, function (k) {\n\t\t\tDefinePropertyOrThrow(O, k, { configurable: false });\n\t\t});\n\t} else if (level === 'frozen') {\n\t\tforEach(theKeys, function (k) {\n\t\t\tvar currentDesc = getOwnPropertyDescriptor(O, k);\n\t\t\tif (typeof currentDesc !== 'undefined') {\n\t\t\t\tvar desc;\n\t\t\t\tif (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {\n\t\t\t\t\tdesc = { configurable: false };\n\t\t\t\t} else {\n\t\t\t\t\tdesc = { configurable: false, writable: false };\n\t\t\t\t}\n\t\t\t\tDefinePropertyOrThrow(O, k, desc);\n\t\t\t}\n\t\t});\n\t}\n\treturn true;\n};\n\nvar $species$1 = GetIntrinsic('%Symbol.species%', true);\nvar $TypeError$S = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor\n\nvar SpeciesConstructor = function SpeciesConstructor(O, defaultConstructor) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$S('Assertion failed: Type(O) is not Object');\n\t}\n\tvar C = O.constructor;\n\tif (typeof C === 'undefined') {\n\t\treturn defaultConstructor;\n\t}\n\tif (Type$1(C) !== 'Object') {\n\t\tthrow new $TypeError$S('O.constructor is not an Object');\n\t}\n\tvar S = $species$1 ? C[$species$1] : void 0;\n\tif (S == null) {\n\t\treturn defaultConstructor;\n\t}\n\tif (IsConstructor(S)) {\n\t\treturn S;\n\t}\n\tthrow new $TypeError$S('no constructor found');\n};\n\nvar $TypeError$T = GetIntrinsic('%TypeError%');\n\n\n\nvar $SymbolToString = callBound('Symbol.prototype.toString', true);\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-symboldescriptivestring\n\nvar SymbolDescriptiveString = function SymbolDescriptiveString(sym) {\n\tif (Type$1(sym) !== 'Symbol') {\n\t\tthrow new $TypeError$T('Assertion failed: `sym` must be a Symbol');\n\t}\n\treturn $SymbolToString(sym);\n};\n\nvar $gOPN$3 = GetIntrinsic('%Object.getOwnPropertyNames%');\nvar $TypeError$U = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-testintegritylevel\n\nvar TestIntegrityLevel = function TestIntegrityLevel(O, level) {\n\tif (Type$1(O) !== 'Object') {\n\t\tthrow new $TypeError$U('Assertion failed: Type(O) is not Object');\n\t}\n\tif (level !== 'sealed' && level !== 'frozen') {\n\t\tthrow new $TypeError$U('Assertion failed: `level` must be `\"sealed\"` or `\"frozen\"`');\n\t}\n\tvar status = IsExtensible(O);\n\tif (status) {\n\t\treturn false;\n\t}\n\tvar theKeys = $gOPN$3(O);\n\treturn theKeys.length === 0 || every(theKeys, function (k) {\n\t\tvar currentDesc = getOwnPropertyDescriptor(O, k);\n\t\tif (typeof currentDesc !== 'undefined') {\n\t\t\tif (currentDesc.configurable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t});\n};\n\nvar $BooleanValueOf = callBound('Boolean.prototype.valueOf');\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-boolean-prototype-object\n\nvar thisBooleanValue = function thisBooleanValue(value) {\n\tif (Type$1(value) === 'Boolean') {\n\t\treturn value;\n\t}\n\n\treturn $BooleanValueOf(value);\n};\n\nvar $NumberValueOf = callBound('Number.prototype.valueOf');\n\n// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-number-prototype-object\n\nvar thisNumberValue = function thisNumberValue(value) {\n\tif (Type$1(value) === 'Number') {\n\t\treturn value;\n\t}\n\n\treturn $NumberValueOf(value);\n};\n\nvar $StringValueOf = callBound('String.prototype.valueOf');\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-string-prototype-object\n\nvar thisStringValue = function thisStringValue(value) {\n\tif (Type$1(value) === 'String') {\n\t\treturn value;\n\t}\n\n\treturn $StringValueOf(value);\n};\n\nvar $SymbolValueOf$1 = callBound('Symbol.prototype.valueOf', true);\n\n\n\n// https://ecma-international.org/ecma-262/9.0/#sec-thissymbolvalue\n\nvar thisSymbolValue$1 = function thisSymbolValue(value) {\n\tif (!$SymbolValueOf$1) {\n\t\tthrow new SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');\n\t}\n\tif (Type$1(value) === 'Symbol') {\n\t\treturn value;\n\t}\n\treturn $SymbolValueOf$1(value);\n};\n\nvar $DateValueOf = callBound('Date.prototype.valueOf');\n\n// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-date-prototype-object\n\nvar thisTimeValue = function thisTimeValue(value) {\n\treturn $DateValueOf(value);\n};\n\nvar thisTimeValue$1 = thisTimeValue;\n\nvar $Date$1 = GetIntrinsic('%Date%');\nvar $Number$3 = GetIntrinsic('%Number%');\nvar $abs$2 = GetIntrinsic('%Math.abs%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.14\n\nvar TimeClip = function TimeClip(time) {\n\tif (!_isFinite(time) || $abs$2(time) > 8.64e15) {\n\t\treturn NaN;\n\t}\n\treturn $Number$3(new $Date$1(ToNumber(time)));\n};\n\nvar msPerDay$3 = timeConstants.msPerDay;\n\n\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3\n\nvar TimeFromYear = function TimeFromYear(y) {\n\treturn msPerDay$3 * DayFromYear(y);\n};\n\nvar $TypeError$V = GetIntrinsic('%TypeError%');\n\n\n\n\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/9.0/#sec-timestring\n\nvar TimeString = function TimeString(tv) {\n\tif (Type$1(tv) !== 'Number' || _isNaN(tv)) {\n\t\tthrow new $TypeError$V('Assertion failed: `tv` must be a non-NaN Number');\n\t}\n\tvar hour = HourFromTime(tv);\n\tvar minute = MinFromTime(tv);\n\tvar second = SecFromTime(tv);\n\treturn padTimeComponent(hour) + ':' + padTimeComponent(minute) + ':' + padTimeComponent(second) + '\\x20GMT';\n};\n\nvar msPerDay$4 = timeConstants.msPerDay;\n\n// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.2\n\nvar TimeWithinDay = function TimeWithinDay(t) {\n\treturn mod(t, msPerDay$4);\n};\n\nvar $TypeError$W = GetIntrinsic('%TypeError%');\nvar $Date$2 = GetIntrinsic('%Date%');\n\n\n\n\n\n// https://ecma-international.org/ecma-262/6.0/#sec-todatestring\n\nvar ToDateString = function ToDateString(tv) {\n\tif (Type$1(tv) !== 'Number') {\n\t\tthrow new $TypeError$W('Assertion failed: `tv` must be a Number');\n\t}\n\tif (_isNaN(tv)) {\n\t\treturn 'Invalid Date';\n\t}\n\treturn $Date$2(tv);\n};\n\nvar $RangeError$2 = GetIntrinsic('%RangeError%');\n\n\n\n\n\n// https://www.ecma-international.org/ecma-262/8.0/#sec-toindex\n\nvar ToIndex = function ToIndex(value) {\n\tif (typeof value === 'undefined') {\n\t\treturn 0;\n\t}\n\tvar integerIndex = ToInteger$1(value);\n\tif (integerIndex < 0) {\n\t\tthrow new $RangeError$2('index must be >= 0');\n\t}\n\tvar index = ToLength(integerIndex);\n\tif (!SameValueZero(integerIndex, index)) {\n\t\tthrow new $RangeError$2('index must be >= 0 and < 2 ** 53 - 1');\n\t}\n\treturn index;\n};\n\nvar $Math$3 = GetIntrinsic('%Math%');\n\n\n\n\n\n\n\n\nvar $floor$9 = $Math$3.floor;\nvar $abs$3 = $Math$3.abs;\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.7\n\nvar ToUint16 = function ToUint16(value) {\n\tvar number = ToNumber(value);\n\tif (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }\n\tvar posInt = sign(number) * $floor$9($abs$3(number));\n\treturn mod(posInt, 0x10000);\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-toint16\n\nvar ToInt16 = function ToInt16(argument) {\n\tvar int16bit = ToUint16(argument);\n\treturn int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;\n};\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-9.5\n\nvar ToInt32 = function ToInt32(x) {\n\treturn ToNumber(x) >> 0;\n};\n\nvar $Math$4 = GetIntrinsic('%Math%');\n\n\n\n\n\n\n\n\nvar $floor$a = $Math$4.floor;\nvar $abs$4 = $Math$4.abs;\n\nvar ToUint8 = function ToUint8(argument) {\n\tvar number = ToNumber(argument);\n\tif (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }\n\tvar posInt = sign(number) * $floor$a($abs$4(number));\n\treturn mod(posInt, 0x100);\n};\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-toint8\n\nvar ToInt8 = function ToInt8(argument) {\n\tvar int8bit = ToUint8(argument);\n\treturn int8bit >= 0x80 ? int8bit - 0x100 : int8bit;\n};\n\nvar $String$2 = GetIntrinsic('%String%');\n\n\n\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-topropertykey\n\nvar ToPropertyKey = function ToPropertyKey(argument) {\n\tvar key = ToPrimitive(argument, $String$2);\n\treturn typeof key === 'symbol' ? key : ToString(key);\n};\n\nvar $Math$5 = GetIntrinsic('%Math%');\n\n\n\n\n\nvar $floor$b = $Math$5.floor;\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-touint8clamp\n\nvar ToUint8Clamp = function ToUint8Clamp(argument) {\n\tvar number = ToNumber(argument);\n\tif (_isNaN(number) || number <= 0) { return 0; }\n\tif (number >= 0xFF) { return 0xFF; }\n\tvar f = $floor$b(argument);\n\tif (f + 0.5 < number) { return f + 1; }\n\tif (number < f + 0.5) { return f; }\n\tif (f % 2 !== 0) { return f + 1; }\n\treturn f;\n};\n\nvar replace = callBind(String.prototype.replace);\n\n/* eslint-disable no-control-regex */\nvar startWhitespace = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*/;\n/* eslint-enable no-control-regex */\n\nvar implementation$3 = function trimStart() {\n\treturn replace(this, startWhitespace, '');\n};\n\nvar polyfill$2 = function getPolyfill() {\n\tif (!String.prototype.trimStart && !String.prototype.trimLeft) {\n\t\treturn implementation$3;\n\t}\n\tvar zeroWidthSpace = '\\u200b';\n\tvar trimmed = zeroWidthSpace.trimStart ? zeroWidthSpace.trimStart() : zeroWidthSpace.trimLeft();\n\tif (trimmed !== zeroWidthSpace) {\n\t\treturn implementation$3;\n\t}\n\treturn String.prototype.trimStart || String.prototype.trimLeft;\n};\n\nvar shim$1 = function shimTrimStart() {\n\tvar polyfill = polyfill$2();\n\tdefineProperties_1(\n\t\tString.prototype,\n\t\t{ trimStart: polyfill },\n\t\t{ trimStart: function () { return String.prototype.trimStart !== polyfill; } }\n\t);\n\treturn polyfill;\n};\n\nvar bound = callBind(polyfill$2());\n\ndefineProperties_1(bound, {\n\tgetPolyfill: polyfill$2,\n\timplementation: implementation$3,\n\tshim: shim$1\n});\n\nvar string_prototype_trimstart = bound;\n\nvar $replace$3 = callBound('String.prototype.replace');\n\n/* eslint-disable no-control-regex */\nvar endWhitespace = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*$/;\n/* eslint-enable no-control-regex */\n\nvar implementation$4 = function trimEnd() {\n\treturn $replace$3(this, endWhitespace, '');\n};\n\nvar polyfill$3 = function getPolyfill() {\n\tif (!String.prototype.trimEnd && !String.prototype.trimRight) {\n\t\treturn implementation$4;\n\t}\n\tvar zeroWidthSpace = '\\u200b';\n\tvar trimmed = zeroWidthSpace.trimEnd ? zeroWidthSpace.trimEnd() : zeroWidthSpace.trimRight();\n\tif (trimmed !== zeroWidthSpace) {\n\t\treturn implementation$4;\n\t}\n\treturn String.prototype.trimEnd || String.prototype.trimRight;\n};\n\nvar shim$2 = function shimTrimEnd() {\n\tvar polyfill = polyfill$3();\n\tdefineProperties_1(\n\t\tString.prototype,\n\t\t{ trimEnd: polyfill },\n\t\t{ trimEnd: function () { return String.prototype.trimEnd !== polyfill; } }\n\t);\n\treturn polyfill;\n};\n\nvar bound$1 = callBind(polyfill$3());\n\ndefineProperties_1(bound$1, {\n\tgetPolyfill: polyfill$3,\n\timplementation: implementation$4,\n\tshim: shim$2\n});\n\nvar string_prototype_trimend = bound$1;\n\nvar $TypeError$X = GetIntrinsic('%TypeError%');\n\n\n\n\n// https://ecma-international.org/ecma-262/10.0/#sec-trimstring\n\nvar TrimString = function TrimString(string, where) {\n\tvar str = RequireObjectCoercible(string);\n\tvar S = ToString(str);\n\tvar T;\n\tif (where === 'start') {\n\t\tT = string_prototype_trimstart(S);\n\t} else if (where === 'end') {\n\t\tT = string_prototype_trimend(S);\n\t} else if (where === 'start+end') {\n\t\tT = string_prototype_trimstart(string_prototype_trimend(S));\n\t} else {\n\t\tthrow new $TypeError$X('Assertion failed: invalid `where` value; must be \"start\", \"end\", or \"start+end\"');\n\t}\n\treturn T;\n};\n\n/* eslint global-require: 0 */\n// https://www.ecma-international.org/ecma-262/10.0/#sec-abstract-operations\nvar ES2019 = {\n\t'Abstract Equality Comparison': AbstractEqualityComparison,\n\t'Abstract Relational Comparison': AbstractRelationalComparison,\n\t'Strict Equality Comparison': StrictEqualityComparison,\n\tAddEntriesFromIterable: AddEntriesFromIterable,\n\tAdvanceStringIndex: AdvanceStringIndex,\n\tArrayCreate: ArrayCreate,\n\tArraySetLength: ArraySetLength,\n\tArraySpeciesCreate: ArraySpeciesCreate,\n\tCall: Call,\n\tCanonicalNumericIndexString: CanonicalNumericIndexString,\n\tCompletePropertyDescriptor: CompletePropertyDescriptor,\n\tCopyDataProperties: CopyDataProperties,\n\tCreateDataProperty: CreateDataProperty,\n\tCreateDataPropertyOrThrow: CreateDataPropertyOrThrow,\n\tCreateHTML: CreateHTML,\n\tCreateIterResultObject: CreateIterResultObject,\n\tCreateListFromArrayLike: CreateListFromArrayLike,\n\tCreateMethodProperty: CreateMethodProperty,\n\tDateFromTime: DateFromTime,\n\tDateString: DateString,\n\tDay: Day,\n\tDayFromYear: DayFromYear,\n\tDaysInYear: DaysInYear,\n\tDayWithinYear: DayWithinYear,\n\tDefinePropertyOrThrow: DefinePropertyOrThrow,\n\tDeletePropertyOrThrow: DeletePropertyOrThrow,\n\tEnumerableOwnPropertyNames: EnumerableOwnPropertyNames,\n\tFlattenIntoArray: FlattenIntoArray,\n\tFromPropertyDescriptor: FromPropertyDescriptor,\n\tGet: Get,\n\tGetIterator: GetIterator,\n\tGetMethod: GetMethod$1,\n\tGetOwnPropertyKeys: GetOwnPropertyKeys,\n\tGetPrototypeFromConstructor: GetPrototypeFromConstructor,\n\tGetSubstitution: GetSubstitution,\n\tGetV: GetV,\n\tHasOwnProperty: HasOwnProperty,\n\tHasProperty: HasProperty,\n\tHourFromTime: HourFromTime,\n\tInLeapYear: InLeapYear,\n\tInstanceofOperator: InstanceofOperator,\n\tInvoke: Invoke,\n\tIsAccessorDescriptor: IsAccessorDescriptor,\n\tIsArray: IsArray,\n\tIsCallable: IsCallable,\n\tIsConcatSpreadable: IsConcatSpreadable,\n\tIsConstructor: IsConstructor,\n\tIsDataDescriptor: IsDataDescriptor,\n\tIsExtensible: IsExtensible,\n\tIsGenericDescriptor: IsGenericDescriptor,\n\tIsInteger: IsInteger,\n\tIsPromise: IsPromise,\n\tIsPropertyKey: IsPropertyKey,\n\tIsRegExp: IsRegExp,\n\tIsStringPrefix: IsStringPrefix,\n\tIterableToList: IterableToList,\n\tIteratorClose: IteratorClose,\n\tIteratorComplete: IteratorComplete,\n\tIteratorNext: IteratorNext,\n\tIteratorStep: IteratorStep,\n\tIteratorValue: IteratorValue,\n\tMakeDate: MakeDate,\n\tMakeDay: MakeDay,\n\tMakeTime: MakeTime,\n\tMinFromTime: MinFromTime,\n\tmodulo: modulo,\n\tMonthFromTime: MonthFromTime,\n\tmsFromTime: msFromTime,\n\tNumberToString: NumberToString,\n\tObjectCreate: ObjectCreate,\n\tOrdinaryDefineOwnProperty: OrdinaryDefineOwnProperty,\n\tOrdinaryGetOwnProperty: OrdinaryGetOwnProperty,\n\tOrdinaryGetPrototypeOf: OrdinaryGetPrototypeOf,\n\tOrdinarySetPrototypeOf: OrdinarySetPrototypeOf,\n\tOrdinaryHasInstance: OrdinaryHasInstance,\n\tOrdinaryHasProperty: OrdinaryHasProperty,\n\tPromiseResolve: PromiseResolve,\n\tRegExpExec: RegExpExec,\n\tRequireObjectCoercible: RequireObjectCoercible,\n\tSameValue: SameValue,\n\tSameValueNonNumber: SameValueNonNumber,\n\tSameValueZero: SameValueZero,\n\tSecFromTime: SecFromTime,\n\tSet: _Set,\n\tSetFunctionName: SetFunctionName,\n\tSetIntegrityLevel: SetIntegrityLevel,\n\tSpeciesConstructor: SpeciesConstructor,\n\tSymbolDescriptiveString: SymbolDescriptiveString,\n\tTestIntegrityLevel: TestIntegrityLevel,\n\tthisBooleanValue: thisBooleanValue,\n\tthisNumberValue: thisNumberValue,\n\tthisStringValue: thisStringValue,\n\tthisSymbolValue: thisSymbolValue$1,\n\tthisTimeValue: thisTimeValue$1,\n\tTimeClip: TimeClip,\n\tTimeFromYear: TimeFromYear,\n\tTimeString: TimeString,\n\tTimeWithinDay: TimeWithinDay,\n\tToBoolean: ToBoolean,\n\tToDateString: ToDateString,\n\tToIndex: ToIndex,\n\tToInt16: ToInt16,\n\tToInt32: ToInt32,\n\tToInt8: ToInt8,\n\tToInteger: ToInteger$1,\n\tToLength: ToLength,\n\tToNumber: ToNumber,\n\tToObject: ToObject,\n\tToPrimitive: ToPrimitive,\n\tToPropertyDescriptor: ToPropertyDescriptor,\n\tToPropertyKey: ToPropertyKey,\n\tToString: ToString,\n\tToUint16: ToUint16,\n\tToUint32: ToUint32,\n\tToUint8: ToUint8,\n\tToUint8Clamp: ToUint8Clamp,\n\tTrimString: TrimString,\n\tType: Type$1,\n\tValidateAndApplyPropertyDescriptor: ValidateAndApplyPropertyDescriptor,\n\tWeekDay: WeekDay,\n\tYearFromTime: YearFromTime\n};\n\nvar es2019 = ES2019;\n\nvar BigInteger = createCommonjsModule(function (module) {\nvar bigInt = (function (undefined$1) {\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    };\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    };\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    };\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    };\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    };\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    };\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined$1) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined$1) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined$1 ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    };\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined$1) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined$1) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); };\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif ( module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n});\n\nvar INTRINSICS$1 = {};\nfunction MakeIntrinsicClass(Class, name) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  var species = function species() {\n    return this;\n  };\n\n  Object.defineProperty(species, 'name', {\n    value: 'get [Symbol.species]',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Class, Symbol.species, {\n    get: species,\n    enumerable: false,\n    configurable: true\n  });\n\n  var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(Class)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var prop = _step.value;\n      var desc = Object.getOwnPropertyDescriptor(Class, prop);\n      if (!desc.configurable || !desc.enumerable) continue;\n      desc.enumerable = false;\n      Object.defineProperty(Class, prop, desc);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(Object.getOwnPropertyNames(Class.prototype)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _prop = _step2.value;\n\n      var _desc = Object.getOwnPropertyDescriptor(Class.prototype, _prop);\n\n      if (!_desc.configurable || !_desc.enumerable) continue;\n      _desc.enumerable = false;\n      Object.defineProperty(Class.prototype, _prop, _desc);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  INTRINSICS$1[\"%\".concat(name, \"%\")] = Class;\n}\nfunction GetIntrinsic$1(intrinsic) {\n  return intrinsic in INTRINSICS$1 ? INTRINSICS$1[intrinsic] : GetIntrinsic(intrinsic);\n}\n\n// Absolute\nvar EPOCHNANOSECONDS = 'slot-epochNanoSeconds'; // TimeZone\n\nvar TIMEZONE_ID = 'slot-timezone-identifier'; // DateTime, Date, Time, YearMonth, MonthDay\n\nvar ISO_YEAR = 'slot-year';\nvar ISO_MONTH = 'slot-month';\nvar ISO_DAY = 'slot-day';\nvar HOUR = 'slot-hour';\nvar MINUTE = 'slot-minute';\nvar SECOND = 'slot-second';\nvar MILLISECOND = 'slot-millisecond';\nvar MICROSECOND = 'slot-microsecond';\nvar NANOSECOND = 'slot-nanosecond';\nvar REF_ISO_YEAR = 'slot-ref-iso-year';\nvar REF_ISO_DAY = 'slot-ref-iso-day';\nvar CALENDAR = 'slot-calendar'; // Duration\n\nvar YEARS = 'slot-years';\nvar MONTHS = 'slot-months';\nvar WEEKS = 'slot-weeks';\nvar DAYS = 'slot-days';\nvar HOURS = 'slot-hours';\nvar MINUTES = 'slot-minutes';\nvar SECONDS = 'slot-seconds';\nvar MILLISECONDS = 'slot-milliseconds';\nvar MICROSECONDS = 'slot-microseconds';\nvar NANOSECONDS = 'slot-nanoseconds'; // Calendar\n\nvar CALENDAR_ID = 'slot-calendar-identifier';\nvar slots = new WeakMap();\nfunction CreateSlots(container) {\n  slots.set(container, Object.create(null));\n}\n\nfunction GetSlots(container) {\n  return slots.get(container);\n}\n\nfunction HasSlot(container) {\n  if (!container || 'object' !== _typeof(container)) return false;\n  var myslots = GetSlots(container);\n\n  for (var _len = arguments.length, ids = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    ids[_key - 1] = arguments[_key];\n  }\n\n  return !!myslots && ids.reduce(function (all, id) {\n    return all && id in myslots;\n  }, true);\n}\nfunction GetSlot(container, id) {\n  return GetSlots(container)[id];\n}\nfunction SetSlot(container, id, value) {\n  GetSlots(container)[id] = value;\n}\n\nvar yearpart = /(?:[+-]\\d{6}|\\d{4})/;\nvar datesplit = new RegExp(\"(\".concat(yearpart.source, \")(?:-(\\\\d{2})-(\\\\d{2})|(\\\\d{2})(\\\\d{2}))\"));\nvar timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nvar zonesplit = /(?:([zZ])|(?:([+-]\\d{2})(?::?(\\d{2}))?(?:\\[([^c\\]\\s](?:[^=\\]\\s][^\\]\\s]*))?\\])?))/;\nvar calendar = /\\[c=([^\\]\\s]+)\\]/;\nvar absolute = new RegExp(\"^\".concat(datesplit.source, \"(?:T|\\\\s+)\").concat(timesplit.source).concat(zonesplit.source, \"(?:\").concat(calendar.source, \")?$\"), 'i');\nvar datetime = new RegExp(\"^\".concat(datesplit.source, \"(?:(?:T|\\\\s+)\").concat(timesplit.source, \"(?:\").concat(zonesplit.source, \")?)?(?:\").concat(calendar.source, \")?$\"), 'i');\nvar time = new RegExp(\"^\".concat(timesplit.source, \"(?:\").concat(zonesplit.source, \")?(?:\").concat(calendar.source, \")?$\"), 'i'); // The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.Date,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601, but since it is not ambiguous with anything\n// else we could parse in a YearMonth context, we allow it\n\nvar yearmonth = new RegExp(\"^(\".concat(yearpart.source, \")-?(\\\\d{2})$\"));\nvar monthday = /^(?:--)?(\\d{2})-?(\\d{2})$/;\nvar offset = /([+-])([0-2][0-9])(?::?([0-5][0-9]))?/;\nvar duration = /P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:[.,](\\d{1,9}))?S)?)?/i;\n\nvar IntlDateTimeFormat = Intl.DateTimeFormat;\nvar ObjectAssign = Object.assign;\nvar DAYMILLIS = 86400000;\nvar NS_MIN = BigInteger(-86400).multiply(1e17);\nvar NS_MAX = BigInteger(86400).multiply(1e17);\nvar YEAR_MIN = -271821;\nvar YEAR_MAX = 275760;\nvar BEFORE_FIRST_DST = BigInteger(-388152).multiply(1e13); // 1847-01-01T00:00:00Z\nvar ES = ObjectAssign({}, es2019, {\n  IsTemporalAbsolute: function IsTemporalAbsolute(item) {\n    return HasSlot(item, EPOCHNANOSECONDS);\n  },\n  IsTemporalTimeZone: function IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n  },\n  IsTemporalCalendar: function IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n  },\n  IsTemporalDuration: function IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n  },\n  IsTemporalDate: function IsTemporalDate(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY) && !HasSlot(item, HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND);\n  },\n  IsTemporalTime: function IsTemporalTime(item) {\n    return HasSlot(item, HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND) && !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY);\n  },\n  IsTemporalDateTime: function IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND);\n  },\n  IsTemporalYearMonth: function IsTemporalYearMonth(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, REF_ISO_DAY);\n  },\n  IsTemporalMonthDay: function IsTemporalMonthDay(item) {\n    return HasSlot(item, ISO_MONTH, ISO_DAY, REF_ISO_YEAR);\n  },\n  TemporalTimeZoneFromString: function TemporalTimeZoneFromString(stringIdent) {\n    var _ES$ParseTemporalTime = ES.ParseTemporalTimeZoneString(stringIdent),\n        zone = _ES$ParseTemporalTime.zone,\n        ianaName = _ES$ParseTemporalTime.ianaName,\n        offset = _ES$ParseTemporalTime.offset;\n\n    var result = ES.GetCanonicalTimeZoneIdentifier(zone);\n\n    if (offset && ianaName) {\n      var ns = ES.ParseTemporalAbsolute(stringIdent);\n      var offsetNs = ES.GetIANATimeZoneOffsetNanoseconds(ns, result);\n\n      if (ES.FormatTimeZoneOffsetString(offsetNs) !== offset) {\n        throw new RangeError(\"invalid offset \".concat(offset, \"[\").concat(ianaName, \"]\"));\n      }\n    }\n\n    return result;\n  },\n  FormatCalendarAnnotation: function FormatCalendarAnnotation(calendar) {\n    if (calendar.id === 'iso8601') return '';\n    return \"[c=\".concat(calendar.id, \"]\");\n  },\n  ParseISODateTime: function ParseISODateTime(isoString, _ref) {\n    var zoneRequired = _ref.zoneRequired;\n    var regex = zoneRequired ? absolute : datetime;\n    var match = regex.exec(isoString);\n    if (!match) throw new RangeError(\"invalid ISO 8601 string: \".concat(isoString));\n    var year = ES.ToInteger(match[1]);\n    var month = ES.ToInteger(match[2] || match[4]);\n    var day = ES.ToInteger(match[3] || match[5]);\n    var hour = ES.ToInteger(match[6]);\n    var minute = ES.ToInteger(match[7] || match[10]);\n    var second = ES.ToInteger(match[8] || match[11]);\n    if (second === 60) second = 59;\n    var fraction = (match[9] || match[12]) + '000000000';\n    var millisecond = ES.ToInteger(fraction.slice(0, 3));\n    var microsecond = ES.ToInteger(fraction.slice(3, 6));\n    var nanosecond = ES.ToInteger(fraction.slice(6, 9));\n    var offset = \"\".concat(match[14], \":\").concat(match[15] || '00');\n    var ianaName = match[16];\n\n    if (ianaName) {\n      try {\n        // Canonicalize name if it is an IANA link name or is capitalized wrong\n        ianaName = ES.GetCanonicalTimeZoneIdentifier(ianaName).toString();\n      } catch (_unused) {// Not an IANA name, may be a custom ID, pass through unchanged\n      }\n    }\n\n    var zone = match[13] ? 'UTC' : ianaName || offset;\n    var calendar = match[17] || null;\n    return {\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond,\n      zone: zone,\n      ianaName: ianaName,\n      offset: offset,\n      calendar: calendar\n    };\n  },\n  ParseTemporalAbsoluteString: function ParseTemporalAbsoluteString(isoString) {\n    return ES.ParseISODateTime(isoString, {\n      zoneRequired: true\n    });\n  },\n  ParseTemporalDateTimeString: function ParseTemporalDateTimeString(isoString) {\n    return ES.ParseISODateTime(isoString, {\n      zoneRequired: false\n    });\n  },\n  ParseTemporalDateString: function ParseTemporalDateString(isoString) {\n    return ES.ParseISODateTime(isoString, {\n      zoneRequired: false\n    });\n  },\n  ParseTemporalTimeString: function ParseTemporalTimeString(isoString) {\n    var match = time.exec(isoString);\n    var hour, minute, second, millisecond, microsecond, nanosecond;\n\n    if (match) {\n      hour = ES.ToInteger(match[1]);\n      minute = ES.ToInteger(match[2] || match[5]);\n      second = ES.ToInteger(match[3] || match[6]);\n      if (second === 60) second = 59;\n      var fraction = (match[4] || match[7]) + '000000000';\n      millisecond = ES.ToInteger(fraction.slice(0, 3));\n      microsecond = ES.ToInteger(fraction.slice(3, 6));\n      nanosecond = ES.ToInteger(fraction.slice(6, 9));\n    } else {\n      var _ES$ParseISODateTime = ES.ParseISODateTime(isoString, {\n        zoneRequired: false\n      });\n\n      hour = _ES$ParseISODateTime.hour;\n      minute = _ES$ParseISODateTime.minute;\n      second = _ES$ParseISODateTime.second;\n      millisecond = _ES$ParseISODateTime.millisecond;\n      microsecond = _ES$ParseISODateTime.microsecond;\n      nanosecond = _ES$ParseISODateTime.nanosecond;\n    }\n\n    return {\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  ParseTemporalYearMonthString: function ParseTemporalYearMonthString(isoString) {\n    var match = yearmonth.exec(isoString);\n    var year, month, calendar, refISODay;\n\n    if (match) {\n      year = ES.ToInteger(match[1]);\n      month = ES.ToInteger(match[2]);\n      calendar = match[3] || null;\n    } else {\n      var _ES$ParseISODateTime2 = ES.ParseISODateTime(isoString, {\n        zoneRequired: false\n      });\n\n      year = _ES$ParseISODateTime2.year;\n      month = _ES$ParseISODateTime2.month;\n      calendar = _ES$ParseISODateTime2.calendar;\n      refISODay = _ES$ParseISODateTime2.day;\n      if (!calendar) refISODay = undefined;\n    }\n\n    return {\n      year: year,\n      month: month,\n      calendar: calendar,\n      refISODay: refISODay\n    };\n  },\n  ParseTemporalMonthDayString: function ParseTemporalMonthDayString(isoString) {\n    var match = monthday.exec(isoString);\n    var month, day, calendar, refISOYear;\n\n    if (match) {\n      month = ES.ToInteger(match[1]);\n      day = ES.ToInteger(match[2]);\n    } else {\n      var _ES$ParseISODateTime3 = ES.ParseISODateTime(isoString, {\n        zoneRequired: false\n      });\n\n      month = _ES$ParseISODateTime3.month;\n      day = _ES$ParseISODateTime3.day;\n      calendar = _ES$ParseISODateTime3.calendar;\n      refISOYear = _ES$ParseISODateTime3.year;\n      if (!calendar) refISOYear = undefined;\n    }\n\n    return {\n      month: month,\n      day: day,\n      calendar: calendar,\n      refISOYear: refISOYear\n    };\n  },\n  ParseTemporalTimeZoneString: function ParseTemporalTimeZoneString(stringIdent) {\n    try {\n      var canonicalIdent = ES.GetCanonicalTimeZoneIdentifier(stringIdent);\n      if (canonicalIdent) return {\n        zone: canonicalIdent.toString()\n      };\n    } catch (_unused2) {// fall through\n    }\n\n    try {\n      // Try parsing ISO string instead\n      return ES.ParseISODateTime(stringIdent, {\n        zoneRequired: true\n      });\n    } catch (_unused3) {\n      throw new RangeError(\"Invalid time zone: \".concat(stringIdent));\n    }\n  },\n  ParseTemporalDurationString: function ParseTemporalDurationString(isoString) {\n    var match = duration.exec(isoString);\n    if (!match) throw new RangeError(\"invalid duration: \".concat(isoString));\n    var years = ES.ToInteger(match[1]);\n    var months = ES.ToInteger(match[2]);\n    var weeks = ES.ToInteger(match[3]);\n    var days = ES.ToInteger(match[4]);\n    var hours = ES.ToInteger(match[5]);\n    var minutes = ES.ToInteger(match[6]);\n    var seconds = ES.ToInteger(match[7]);\n    var fraction = match[8] + '000000000';\n    var milliseconds = ES.ToInteger(fraction.slice(0, 3));\n    var microseconds = ES.ToInteger(fraction.slice(3, 6));\n    var nanoseconds = ES.ToInteger(fraction.slice(6, 9));\n    return {\n      years: years,\n      months: months,\n      weeks: weeks,\n      days: days,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      milliseconds: milliseconds,\n      microseconds: microseconds,\n      nanoseconds: nanoseconds\n    };\n  },\n  ParseTemporalAbsolute: function ParseTemporalAbsolute(isoString) {\n    var _ES$ParseTemporalAbso = ES.ParseTemporalAbsoluteString(isoString),\n        year = _ES$ParseTemporalAbso.year,\n        month = _ES$ParseTemporalAbso.month,\n        day = _ES$ParseTemporalAbso.day,\n        hour = _ES$ParseTemporalAbso.hour,\n        minute = _ES$ParseTemporalAbso.minute,\n        second = _ES$ParseTemporalAbso.second,\n        millisecond = _ES$ParseTemporalAbso.millisecond,\n        microsecond = _ES$ParseTemporalAbso.microsecond,\n        nanosecond = _ES$ParseTemporalAbso.nanosecond,\n        offset = _ES$ParseTemporalAbso.offset,\n        zone = _ES$ParseTemporalAbso.zone;\n\n    var DateTime = GetIntrinsic$1('%Temporal.DateTime%');\n    var TimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n    var dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    var tz = TimeZone.from(zone);\n    var possibleAbsolutes = tz.getPossibleAbsolutesFor(dt);\n    if (possibleAbsolutes.length === 1) return GetSlot(possibleAbsolutes[0], EPOCHNANOSECONDS);\n\n    var _iterator = _createForOfIteratorHelper(possibleAbsolutes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var absolute = _step.value;\n        var possibleOffsetNs = tz.getOffsetNanosecondsFor(absolute);\n        if (ES.FormatTimeZoneOffsetString(possibleOffsetNs) === offset) return GetSlot(absolute, EPOCHNANOSECONDS);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    throw new RangeError(\"'\".concat(isoString, \"' doesn't uniquely identify a Temporal.Absolute\"));\n  },\n  RegulateDateTime: function RegulateDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, disambiguation) {\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainDateTime = ES.ConstrainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n        year = _ES$ConstrainDateTime.year;\n        month = _ES$ConstrainDateTime.month;\n        day = _ES$ConstrainDateTime.day;\n        hour = _ES$ConstrainDateTime.hour;\n        minute = _ES$ConstrainDateTime.minute;\n        second = _ES$ConstrainDateTime.second;\n        millisecond = _ES$ConstrainDateTime.millisecond;\n        microsecond = _ES$ConstrainDateTime.microsecond;\n        nanosecond = _ES$ConstrainDateTime.nanosecond;\n        break;\n    }\n\n    return {\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  RegulateDateTimeRange: function RegulateDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, disambiguation) {\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainDateTime2 = ES.ConstrainDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n        year = _ES$ConstrainDateTime2.year;\n        month = _ES$ConstrainDateTime2.month;\n        day = _ES$ConstrainDateTime2.day;\n        hour = _ES$ConstrainDateTime2.hour;\n        minute = _ES$ConstrainDateTime2.minute;\n        second = _ES$ConstrainDateTime2.second;\n        millisecond = _ES$ConstrainDateTime2.millisecond;\n        microsecond = _ES$ConstrainDateTime2.microsecond;\n        nanosecond = _ES$ConstrainDateTime2.nanosecond;\n        break;\n    }\n\n    return {\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  RegulateDate: function RegulateDate(year, month, day, disambiguation) {\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectDate(year, month, day);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainDate = ES.ConstrainDate(year, month, day);\n\n        year = _ES$ConstrainDate.year;\n        month = _ES$ConstrainDate.month;\n        day = _ES$ConstrainDate.day;\n        break;\n    }\n\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  RegulateDateRange: function RegulateDateRange(year, month, day, disambiguation) {\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectDateRange(year, month, day);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainDateRang = ES.ConstrainDateRange(year, month, day);\n\n        year = _ES$ConstrainDateRang.year;\n        month = _ES$ConstrainDateRang.month;\n        day = _ES$ConstrainDateRang.day;\n        break;\n    }\n\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  RegulateTime: function RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, disambiguation) {\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainTime = ES.ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n\n        hour = _ES$ConstrainTime.hour;\n        minute = _ES$ConstrainTime.minute;\n        second = _ES$ConstrainTime.second;\n        millisecond = _ES$ConstrainTime.millisecond;\n        microsecond = _ES$ConstrainTime.microsecond;\n        nanosecond = _ES$ConstrainTime.nanosecond;\n        break;\n    }\n\n    return {\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  RegulateYearMonth: function RegulateYearMonth(year, month, disambiguation) {\n    var refISODay = 1;\n\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectDate(year, month, refISODay);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainDate2 = ES.ConstrainDate(year, month);\n\n        year = _ES$ConstrainDate2.year;\n        month = _ES$ConstrainDate2.month;\n        break;\n    }\n\n    return {\n      year: year,\n      month: month\n    };\n  },\n  RegulateYearMonthRange: function RegulateYearMonthRange(year, month, disambiguation) {\n    var refISODay = 1;\n\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectYearMonthRange(year, month, refISODay);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainYearMont = ES.ConstrainYearMonthRange(year, month);\n\n        year = _ES$ConstrainYearMont.year;\n        month = _ES$ConstrainYearMont.month;\n        break;\n    }\n\n    return {\n      year: year,\n      month: month\n    };\n  },\n  RegulateMonthDay: function RegulateMonthDay(month, day, disambiguation) {\n    var refISOYear = 1972;\n\n    switch (disambiguation) {\n      case 'reject':\n        ES.RejectDate(refISOYear, month, day);\n        break;\n\n      case 'constrain':\n        var _ES$ConstrainDate3 = ES.ConstrainDate(refISOYear, month, day);\n\n        month = _ES$ConstrainDate3.month;\n        day = _ES$ConstrainDate3.day;\n        break;\n    }\n\n    return {\n      month: month,\n      day: day\n    };\n  },\n  ToTemporalDurationRecord: function ToTemporalDurationRecord(item) {\n    if (ES.IsTemporalDuration(item)) {\n      return {\n        years: GetSlot(item, YEARS),\n        months: GetSlot(item, MONTHS),\n        weeks: GetSlot(item, WEEKS),\n        days: GetSlot(item, DAYS),\n        hours: GetSlot(item, HOURS),\n        minutes: GetSlot(item, MINUTES),\n        seconds: GetSlot(item, SECONDS),\n        milliseconds: GetSlot(item, MILLISECONDS),\n        microseconds: GetSlot(item, MICROSECONDS),\n        nanoseconds: GetSlot(item, NANOSECONDS)\n      };\n    }\n\n    return ES.ToRecord(item, [['days', 0], ['hours', 0], ['microseconds', 0], ['milliseconds', 0], ['minutes', 0], ['months', 0], ['nanoseconds', 0], ['seconds', 0], ['weeks', 0], ['years', 0]]);\n  },\n  RegulateDuration: function RegulateDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, disambiguation) {\n    for (var _i = 0, _arr = [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]; _i < _arr.length; _i++) {\n      var prop = _arr[_i];\n      if (prop < 0) throw new RangeError('negative values not allowed as duration fields');\n    }\n\n    switch (disambiguation) {\n      case 'reject':\n        for (var _i2 = 0, _arr2 = [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]; _i2 < _arr2.length; _i2++) {\n          var _prop = _arr2[_i2];\n          if (!Number.isFinite(_prop)) throw new RangeError('infinite values not allowed as duration fields');\n        }\n\n        break;\n\n      case 'constrain':\n        {\n          var arr = [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds];\n\n          for (var idx in arr) {\n            if (!Number.isFinite(arr[idx])) arr[idx] = Number.MAX_VALUE;\n          }\n\n          years = arr[0];\n          months = arr[1];\n          weeks = arr[2];\n          days = arr[3];\n          hours = arr[4];\n          minutes = arr[5];\n          seconds = arr[6];\n          milliseconds = arr[7];\n          microseconds = arr[8];\n          nanoseconds = arr[9];\n          break;\n        }\n\n      case 'balance':\n        {\n          var _ES$BalanceDuration = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days');\n\n          days = _ES$BalanceDuration.days;\n          hours = _ES$BalanceDuration.hours;\n          minutes = _ES$BalanceDuration.minutes;\n          seconds = _ES$BalanceDuration.seconds;\n          milliseconds = _ES$BalanceDuration.milliseconds;\n          microseconds = _ES$BalanceDuration.microseconds;\n          nanoseconds = _ES$BalanceDuration.nanoseconds;\n\n          for (var _i3 = 0, _arr3 = [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]; _i3 < _arr3.length; _i3++) {\n            var _prop2 = _arr3[_i3];\n            if (!Number.isFinite(_prop2)) throw new RangeError('infinite values not allowed as duration fields');\n          }\n\n          break;\n        }\n    }\n\n    return {\n      years: years,\n      months: months,\n      weeks: weeks,\n      days: days,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      milliseconds: milliseconds,\n      microseconds: microseconds,\n      nanoseconds: nanoseconds\n    };\n  },\n  ToLimitedTemporalDuration: function ToLimitedTemporalDuration(item) {\n    var disallowedProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (_typeof(item) !== 'object' || item === null) {\n      throw new TypeError('Unexpected type for duration');\n    }\n\n    var _ES$ToTemporalDuratio = ES.ToTemporalDurationRecord(item),\n        years = _ES$ToTemporalDuratio.years,\n        months = _ES$ToTemporalDuratio.months,\n        weeks = _ES$ToTemporalDuratio.weeks,\n        days = _ES$ToTemporalDuratio.days,\n        hours = _ES$ToTemporalDuratio.hours,\n        minutes = _ES$ToTemporalDuratio.minutes,\n        seconds = _ES$ToTemporalDuratio.seconds,\n        milliseconds = _ES$ToTemporalDuratio.milliseconds,\n        microseconds = _ES$ToTemporalDuratio.microseconds,\n        nanoseconds = _ES$ToTemporalDuratio.nanoseconds;\n\n    var duration = ES.RegulateDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'reject');\n\n    var _iterator2 = _createForOfIteratorHelper(disallowedProperties),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var property = _step2.value;\n\n        if (duration[property] !== 0) {\n          throw new RangeError(\"invalid duration field \".concat(property));\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return duration;\n  },\n  ToDurationTemporalDisambiguation: function ToDurationTemporalDisambiguation(options) {\n    return ES.GetOption(options, 'disambiguation', ['constrain', 'balance', 'reject'], 'constrain');\n  },\n  ToTemporalDisambiguation: function ToTemporalDisambiguation(options) {\n    return ES.GetOption(options, 'disambiguation', ['constrain', 'reject'], 'constrain');\n  },\n  ToTimeZoneTemporalDisambiguation: function ToTimeZoneTemporalDisambiguation(options) {\n    return ES.GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n  },\n  ToDurationSubtractionTemporalDisambiguation: function ToDurationSubtractionTemporalDisambiguation(options) {\n    return ES.GetOption(options, 'disambiguation', ['balanceConstrain', 'balance'], 'balanceConstrain');\n  },\n  ToLargestTemporalUnit: function ToLargestTemporalUnit(options, fallback) {\n    var disallowedStrings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var largestUnit = ES.GetOption(options, 'largestUnit', ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds'], fallback);\n\n    if (disallowedStrings.includes(largestUnit)) {\n      throw new RangeError(\"\".concat(largestUnit, \" not allowed as the largest unit here\"));\n    }\n\n    return largestUnit;\n  },\n  ToPartialRecord: function ToPartialRecord(bag, fields) {\n    if (!bag || 'object' !== _typeof(bag)) return false;\n    var any;\n\n    var _iterator3 = _createForOfIteratorHelper(fields),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var property = _step3.value;\n        var value = bag[property];\n\n        if (value !== undefined) {\n          any = any || {};\n\n          if (property === 'calendar') {\n            // FIXME: this is terrible\n            var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n            any.calendar = TemporalCalendar.from(value);\n          } else if (property === 'era') {\n            any.era = value;\n          } else {\n            any[property] = ES.ToInteger(value);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return any ? any : false;\n  },\n  ToRecord: function ToRecord(bag, fields) {\n    if (!bag || 'object' !== _typeof(bag)) return false;\n    var result = {};\n\n    var _iterator4 = _createForOfIteratorHelper(fields),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var fieldRecord = _step4.value;\n\n        var _fieldRecord = _slicedToArray(fieldRecord, 2),\n            property = _fieldRecord[0],\n            defaultValue = _fieldRecord[1];\n\n        var value = bag[property];\n\n        if (value === undefined) {\n          if (fieldRecord.length === 1) {\n            throw new TypeError(\"required property '\".concat(property, \"' missing or undefined\"));\n          }\n\n          value = defaultValue;\n        }\n\n        if (property === 'calendar') {\n          // FIXME: this is terrible\n          var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n          result.calendar = TemporalCalendar.from(value);\n        } else if (property === 'era') {\n          result.era = value;\n        } else {\n          result[property] = ES.ToInteger(value);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return result;\n  },\n  // field access in the following operations is intentionally alphabetical\n  ToTemporalDateRecord: function ToTemporalDateRecord(bag) {\n    return ES.ToRecord(bag, [['day'], ['era', undefined], ['month'], ['year']]);\n  },\n  ToTemporalDateTimeRecord: function ToTemporalDateTimeRecord(bag) {\n    return ES.ToRecord(bag, [['day'], ['era', undefined], ['hour', 0], ['microsecond', 0], ['millisecond', 0], ['minute', 0], ['month'], ['nanosecond', 0], ['second', 0], ['year']]);\n  },\n  ToTemporalMonthDayRecord: function ToTemporalMonthDayRecord(bag) {\n    return ES.ToRecord(bag, [['day'], ['month']]);\n  },\n  ToTemporalTimeRecord: function ToTemporalTimeRecord(bag) {\n    return ES.ToRecord(bag, [['hour', 0], ['microsecond', 0], ['millisecond', 0], ['minute', 0], ['nanosecond', 0], ['second', 0]]);\n  },\n  ToTemporalYearMonthRecord: function ToTemporalYearMonthRecord(bag) {\n    return ES.ToRecord(bag, [['era', undefined], ['month'], ['year']]);\n  },\n  ISOTimeZoneString: function ISOTimeZoneString(timeZone, absolute) {\n    var offset;\n\n    if (typeof timeZone.getOffsetStringFor === 'function') {\n      offset = timeZone.getOffsetStringFor(absolute);\n    } else {\n      var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n      offset = TemporalTimeZone.prototype.getOffsetStringFor.call(timeZone, absolute);\n    }\n\n    var timeZoneString;\n\n    switch (true) {\n      case 'UTC' === timeZone.name:\n        timeZoneString = 'Z';\n        break;\n\n      case timeZone.name === offset:\n        timeZoneString = offset;\n        break;\n\n      default:\n        timeZoneString = \"\".concat(offset, \"[\").concat(timeZone.toString(), \"]\");\n        break;\n    }\n\n    return timeZoneString;\n  },\n  ISOYearString: function ISOYearString(year) {\n    var yearString;\n\n    if (year < 1000 || year > 9999) {\n      var sign = year < 0 ? '-' : '+';\n      var yearNumber = Math.abs(year);\n      yearString = sign + \"000000\".concat(yearNumber).slice(-6);\n    } else {\n      yearString = \"\".concat(year);\n    }\n\n    return yearString;\n  },\n  ISODateTimePartString: function ISODateTimePartString(part) {\n    return \"00\".concat(part).slice(-2);\n  },\n  ISOSecondsString: function ISOSecondsString(seconds, millis, micros, nanos) {\n    if (!seconds && !millis && !micros && !nanos) return '';\n    var parts = [];\n    if (nanos) parts.unshift(\"000\".concat(nanos || 0).slice(-3));\n    if (micros || parts.length) parts.unshift(\"000\".concat(micros || 0).slice(-3));\n    if (millis || parts.length) parts.unshift(\"000\".concat(millis || 0).slice(-3));\n    var secs = \"00\".concat(seconds).slice(-2);\n    var post = parts.length ? \".\".concat(parts.join('')) : '';\n    return \"\".concat(secs).concat(post);\n  },\n  TemporalAbsoluteToString: function TemporalAbsoluteToString(absolute, timeZone) {\n    var dateTime;\n\n    if (typeof timeZone.getDateTimeFor === 'function') {\n      dateTime = timeZone.getDateTimeFor(absolute);\n    } else {\n      var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n      dateTime = TemporalTimeZone.prototype.getDateTimeFor.call(timeZone, absolute);\n    }\n\n    var year = ES.ISOYearString(dateTime.year);\n    var month = ES.ISODateTimePartString(dateTime.month);\n    var day = ES.ISODateTimePartString(dateTime.day);\n    var hour = ES.ISODateTimePartString(dateTime.hour);\n    var minute = ES.ISODateTimePartString(dateTime.minute);\n    var seconds = ES.ISOSecondsString(dateTime.second, dateTime.millisecond, dateTime.microsecond, dateTime.nanosecond);\n    var timeZoneString = ES.ISOTimeZoneString(timeZone, absolute);\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute).concat(seconds ? \":\".concat(seconds) : '').concat(timeZoneString);\n  },\n  TemporalDurationToString: function TemporalDurationToString(duration) {\n    function formatNumber(num) {\n      if (num <= Number.MAX_SAFE_INTEGER) return num.toString(10);\n      return BigInteger(num).toString();\n    }\n\n    var dateParts = [];\n    if (GetSlot(duration, YEARS)) dateParts.push(\"\".concat(formatNumber(GetSlot(duration, YEARS)), \"Y\"));\n    if (GetSlot(duration, MONTHS)) dateParts.push(\"\".concat(formatNumber(GetSlot(duration, MONTHS)), \"M\"));\n    if (GetSlot(duration, WEEKS)) dateParts.push(\"\".concat(formatNumber(GetSlot(duration, WEEKS)), \"W\"));\n    if (GetSlot(duration, DAYS)) dateParts.push(\"\".concat(formatNumber(GetSlot(duration, DAYS)), \"D\"));\n    var timeParts = [];\n    if (GetSlot(duration, HOURS)) timeParts.push(\"\".concat(formatNumber(GetSlot(duration, HOURS)), \"H\"));\n    if (GetSlot(duration, MINUTES)) timeParts.push(\"\".concat(formatNumber(GetSlot(duration, MINUTES)), \"M\"));\n    var secondParts = [];\n    var ms = GetSlot(duration, MILLISECONDS);\n    var s = GetSlot(duration, MICROSECONDS);\n    var ns = GetSlot(duration, NANOSECONDS);\n    var seconds;\n\n    var _ES$BalanceSubSecond = ES.BalanceSubSecond(ms, s, ns);\n\n    seconds = _ES$BalanceSubSecond.seconds;\n    ms = _ES$BalanceSubSecond.millisecond;\n    s = _ES$BalanceSubSecond.microsecond;\n    ns = _ES$BalanceSubSecond.nanosecond;\n    var s = GetSlot(duration, SECONDS) + seconds;\n    if (ns) secondParts.unshift(\"\".concat(ns).padStart(3, '0'));\n    if (s || secondParts.length) secondParts.unshift(\"\".concat(s).padStart(3, '0'));\n    if (ms || secondParts.length) secondParts.unshift(\"\".concat(ms).padStart(3, '0'));\n    if (secondParts.length) secondParts.unshift('.');\n    if (s || secondParts.length) secondParts.unshift(formatNumber(s));\n    if (secondParts.length) timeParts.push(\"\".concat(secondParts.join(''), \"S\"));\n    if (timeParts.length) timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length) return 'PT0S';\n    return \"P\".concat(dateParts.join('')).concat(timeParts.join(''));\n  },\n  GetCanonicalTimeZoneIdentifier: function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    var offsetNs = parseOffsetString(timeZoneIdentifier);\n    if (offsetNs !== null) return ES.FormatTimeZoneOffsetString(offsetNs);\n    var formatter = new IntlDateTimeFormat('en-us', {\n      timeZone: String(timeZoneIdentifier),\n      hour12: false,\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    return formatter.resolvedOptions().timeZone;\n  },\n  GetIANATimeZoneOffsetNanoseconds: function GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    var _ES$GetIANATimeZoneDa = ES.GetIANATimeZoneDateTimeParts(epochNanoseconds, id),\n        year = _ES$GetIANATimeZoneDa.year,\n        month = _ES$GetIANATimeZoneDa.month,\n        day = _ES$GetIANATimeZoneDa.day,\n        hour = _ES$GetIANATimeZoneDa.hour,\n        minute = _ES$GetIANATimeZoneDa.minute,\n        second = _ES$GetIANATimeZoneDa.second,\n        millisecond = _ES$GetIANATimeZoneDa.millisecond,\n        microsecond = _ES$GetIANATimeZoneDa.microsecond,\n        nanosecond = _ES$GetIANATimeZoneDa.nanosecond;\n\n    var utc = ES.GetEpochFromParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null) throw new RangeError('Date outside of supported range');\n    return +utc.minus(epochNanoseconds);\n  },\n  FormatTimeZoneOffsetString: function FormatTimeZoneOffsetString(offsetNanoseconds) {\n    var sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = Math.abs(offsetNanoseconds);\n    var offsetMinutes = Math.floor(offsetNanoseconds / 60e9);\n    var offsetMinuteString = \"00\".concat(offsetMinutes % 60).slice(-2);\n    var offsetHourString = \"00\".concat(Math.floor(offsetMinutes / 60)).slice(-2);\n    return \"\".concat(sign).concat(offsetHourString, \":\").concat(offsetMinuteString);\n  },\n  GetEpochFromParts: function GetEpochFromParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    var ms = Date.UTC(year, month - 1, day, hour, minute, second, millisecond);\n    if (Number.isNaN(ms)) return null; // Date.UTC interprets one and two-digit years as being in the 20th century\n\n    if (year >= 0 && year < 100) ms = new Date(ms).setUTCFullYear(year);\n    var ns = BigInteger(ms).multiply(1e6);\n    ns = ns.plus(BigInteger(microsecond).multiply(1e3));\n    ns = ns.plus(BigInteger(nanosecond));\n    if (ns.lesser(NS_MIN) || ns.greater(NS_MAX)) return null;\n    return ns;\n  },\n  GetPartsFromEpoch: function GetPartsFromEpoch(epochNanoseconds) {\n    var nanos = BigInteger(epochNanoseconds).mod(1e9);\n    var epochMilliseconds = BigInteger(epochNanoseconds).divide(1e9).multiply(1e3).plus(Math.floor(nanos / 1e6));\n    nanos = +((epochNanoseconds < 0 ? 1e9 : 0) + nanos);\n    var millisecond = Math.floor(nanos / 1e6) % 1e3;\n    var microsecond = Math.floor(nanos / 1e3) % 1e3;\n    var nanosecond = Math.floor(nanos / 1) % 1e3;\n    var item = new Date(epochMilliseconds);\n    var year = item.getUTCFullYear();\n    var month = item.getUTCMonth() + 1;\n    var day = item.getUTCDate();\n    var hour = item.getUTCHours();\n    var minute = item.getUTCMinutes();\n    var second = item.getUTCSeconds();\n    return {\n      epochMilliseconds: epochMilliseconds,\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  GetIANATimeZoneDateTimeParts: function GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    var _ES$GetPartsFromEpoch = ES.GetPartsFromEpoch(epochNanoseconds),\n        epochMilliseconds = _ES$GetPartsFromEpoch.epochMilliseconds,\n        millisecond = _ES$GetPartsFromEpoch.millisecond,\n        microsecond = _ES$GetPartsFromEpoch.microsecond,\n        nanosecond = _ES$GetPartsFromEpoch.nanosecond;\n\n    var _ES$GetFormatterParts = ES.GetFormatterParts(id, epochMilliseconds).reduce(reduceParts, {}),\n        year = _ES$GetFormatterParts.year,\n        month = _ES$GetFormatterParts.month,\n        day = _ES$GetFormatterParts.day,\n        hour = _ES$GetFormatterParts.hour,\n        minute = _ES$GetFormatterParts.minute,\n        second = _ES$GetFormatterParts.second;\n\n    return ES.BalanceDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  },\n  GetIANATimeZoneNextTransition: function GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    var uppercap = ES.SystemUTCEpochNanoSeconds() + 366 * DAYMILLIS * 1e6;\n    var leftNanos = epochNanoseconds;\n    var leftOffsetNs = ES.GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    var rightNanos = leftNanos;\n    var rightOffsetNs = leftOffsetNs;\n\n    while (leftOffsetNs === rightOffsetNs && BigInteger(leftNanos).compare(uppercap) === -1) {\n      rightNanos = BigInteger(leftNanos).plus(2 * 7 * DAYMILLIS * 1e6);\n      rightOffsetNs = ES.GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n\n      if (leftOffsetNs === rightOffsetNs) {\n        leftNanos = rightNanos;\n      }\n    }\n\n    if (leftOffsetNs === rightOffsetNs) return null;\n    var result = bisect(function (epochNs) {\n      return ES.GetIANATimeZoneOffsetNanoseconds(epochNs, id);\n    }, leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n  },\n  GetIANATimeZonePreviousTransition: function GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    var lowercap = BEFORE_FIRST_DST; // 1847-01-01T00:00:00Z\n\n    var rightNanos = epochNanoseconds;\n    var rightOffsetNs = ES.GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    var leftNanos = rightNanos;\n    var leftOffsetNs = rightOffsetNs;\n\n    while (rightOffsetNs === leftOffsetNs && BigInteger(rightNanos).compare(lowercap) === 1) {\n      leftNanos = BigInteger(rightNanos).minus(2 * 7 * DAYMILLIS * 1e6);\n      leftOffsetNs = ES.GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n\n      if (rightOffsetNs === leftOffsetNs) {\n        rightNanos = leftNanos;\n      }\n    }\n\n    if (rightOffsetNs === leftOffsetNs) return null;\n    var result = bisect(function (epochNs) {\n      return ES.GetIANATimeZoneOffsetNanoseconds(epochNs, id);\n    }, leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n  },\n  GetFormatterParts: function GetFormatterParts(timeZone, epochMilliseconds) {\n    var formatter = new IntlDateTimeFormat('en-us', {\n      timeZone: timeZone,\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    }); // FIXME: can this use formatToParts instead?\n\n    var datetime = formatter.format(new Date(epochMilliseconds));\n\n    var _datetime$split = datetime.split(/,\\s+/),\n        _datetime$split2 = _slicedToArray(_datetime$split, 3),\n        date = _datetime$split2[0],\n        fullYear = _datetime$split2[1],\n        time = _datetime$split2[2];\n\n    var _date$split = date.split(' '),\n        _date$split2 = _slicedToArray(_date$split, 2),\n        month = _date$split2[0],\n        day = _date$split2[1];\n\n    var _fullYear$split = fullYear.split(' '),\n        _fullYear$split2 = _slicedToArray(_fullYear$split, 2),\n        year = _fullYear$split2[0],\n        era = _fullYear$split2[1];\n\n    var _time$split = time.split(':'),\n        _time$split2 = _slicedToArray(_time$split, 3),\n        hour = _time$split2[0],\n        minute = _time$split2[1],\n        second = _time$split2[2];\n\n    return [{\n      type: 'year',\n      value: era === 'BC' ? -year + 1 : +year\n    }, {\n      type: 'month',\n      value: +month\n    }, {\n      type: 'day',\n      value: +day\n    }, {\n      type: 'hour',\n      value: hour === '24' ? 0 : +hour\n    }, // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n    {\n      type: 'minute',\n      value: +minute\n    }, {\n      type: 'second',\n      value: +second\n    }];\n  },\n  GetIANATimeZoneEpochValue: function GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    var ns = ES.GetEpochFromParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null) throw new RangeError('DateTime outside of supported range');\n    var dayNanos = BigInteger(DAYMILLIS).multiply(1e6);\n    var nsEarlier = ns.minus(dayNanos);\n    if (nsEarlier.lesser(NS_MIN)) nsEarlier = ns;\n    var nsLater = ns.plus(dayNanos);\n    if (nsLater.greater(NS_MAX)) nsLater = ns;\n    var earliest = ES.GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    var latest = ES.GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    var found = earliest === latest ? [earliest] : [earliest, latest];\n    return found.map(function (offsetNanoseconds) {\n      var epochNanoseconds = BigInteger(ns).minus(offsetNanoseconds);\n      var parts = ES.GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n\n      if (year !== parts.year || month !== parts.month || day !== parts.day || hour !== parts.hour || minute !== parts.minute || second !== parts.second || millisecond !== parts.millisecond || microsecond !== parts.microsecond || nanosecond !== parts.nanosecond) {\n        return undefined;\n      }\n\n      return epochNanoseconds;\n    }).filter(function (x) {\n      return x !== undefined;\n    });\n  },\n  LeapYear: function LeapYear(year) {\n    if (undefined === year) return false;\n    var isDiv4 = year % 4 === 0;\n    var isDiv100 = year % 100 === 0;\n    var isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n  },\n  DaysInMonth: function DaysInMonth(year, month) {\n    var DoM = {\n      standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n      leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[ES.LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n  },\n  DayOfWeek: function DayOfWeek(year, month, day) {\n    var m = month + (month < 3 ? 10 : -2);\n    var Y = year - (month < 3 ? 1 : 0);\n    var c = Math.floor(Y / 100);\n    var y = Y - c * 100;\n    var d = day;\n    var pD = d;\n    var pM = Math.floor(2.6 * m - 0.2);\n    var pY = y + Math.floor(y / 4);\n    var pC = Math.floor(c / 4) - 2 * c;\n    var dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n  },\n  DayOfYear: function DayOfYear(year, month, day) {\n    var days = day;\n\n    for (var m = month - 1; m > 0; m--) {\n      days += ES.DaysInMonth(year, m);\n    }\n\n    return days;\n  },\n  WeekOfYear: function WeekOfYear(year, month, day) {\n    var doy = ES.DayOfYear(year, month, day);\n    var dow = ES.DayOfWeek(year, month, day) || 7;\n    var doj = ES.DayOfWeek(year, 1, 1);\n    var week = Math.floor((doy - dow + 10) / 7);\n\n    if (week < 1) {\n      if (doj === (ES.LeapYear(year) ? 5 : 6)) {\n        return 53;\n      } else {\n        return 52;\n      }\n    }\n\n    if (week === 53) {\n      if ((ES.LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n        return 1;\n      }\n    }\n\n    return week;\n  },\n  BalanceYearMonth: function BalanceYearMonth(year, month) {\n    if (!Number.isFinite(year) || !Number.isFinite(month)) throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += Math.floor(month / 12);\n    month %= 12;\n    if (month < 0) month += 12;\n    month += 1;\n    return {\n      year: year,\n      month: month\n    };\n  },\n  BalanceDate: function BalanceDate(year, month, day) {\n    if (!Number.isFinite(day)) throw new RangeError('infinity is out of range');\n\n    var _ES$BalanceYearMonth = ES.BalanceYearMonth(year, month);\n\n    year = _ES$BalanceYearMonth.year;\n    month = _ES$BalanceYearMonth.month;\n    var daysInYear = 0;\n    var testYear = month > 2 ? year : year - 1;\n\n    while (daysInYear = ES.LeapYear(testYear) ? 366 : 365, day < -daysInYear) {\n      year -= 1;\n      testYear -= 1;\n      day += daysInYear;\n    }\n\n    testYear += 1;\n\n    while (daysInYear = ES.LeapYear(testYear) ? 366 : 365, day > daysInYear) {\n      year += 1;\n      testYear += 1;\n      day -= daysInYear;\n    }\n\n    while (day < 1) {\n      var _ES$BalanceYearMonth2 = ES.BalanceYearMonth(year, month - 1);\n\n      year = _ES$BalanceYearMonth2.year;\n      month = _ES$BalanceYearMonth2.month;\n      day += ES.DaysInMonth(year, month);\n    }\n\n    while (day > ES.DaysInMonth(year, month)) {\n      day -= ES.DaysInMonth(year, month);\n\n      var _ES$BalanceYearMonth3 = ES.BalanceYearMonth(year, month + 1);\n\n      year = _ES$BalanceYearMonth3.year;\n      month = _ES$BalanceYearMonth3.month;\n    }\n\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  BalanceDateTime: function BalanceDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    var deltaDays;\n\n    var _ES$BalanceTime = ES.BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n\n    deltaDays = _ES$BalanceTime.deltaDays;\n    hour = _ES$BalanceTime.hour;\n    minute = _ES$BalanceTime.minute;\n    second = _ES$BalanceTime.second;\n    millisecond = _ES$BalanceTime.millisecond;\n    microsecond = _ES$BalanceTime.microsecond;\n    nanosecond = _ES$BalanceTime.nanosecond;\n\n    var _ES$BalanceDate = ES.BalanceDate(year, month, day + deltaDays);\n\n    year = _ES$BalanceDate.year;\n    month = _ES$BalanceDate.month;\n    day = _ES$BalanceDate.day;\n    return {\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  BalanceSubSecond: function BalanceSubSecond(millisecond, microsecond, nanosecond) {\n    if (!Number.isFinite(millisecond) || !Number.isFinite(microsecond) || !Number.isFinite(nanosecond)) {\n      throw new RangeError('infinity is out of range');\n    }\n\n    microsecond += Math.floor(nanosecond / 1000);\n    nanosecond = ES.NonNegativeModulo(nanosecond, 1000);\n    millisecond += Math.floor(microsecond / 1000);\n    microsecond = ES.NonNegativeModulo(microsecond, 1000);\n    var seconds = Math.floor(millisecond / 1000);\n    millisecond = ES.NonNegativeModulo(millisecond, 1000);\n    return {\n      seconds: seconds,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  BalanceTime: function BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    if (!Number.isFinite(hour) || !Number.isFinite(minute) || !Number.isFinite(second)) {\n      throw new RangeError('infinity is out of range');\n    }\n\n    var seconds;\n\n    var _ES$BalanceSubSecond2 = ES.BalanceSubSecond(millisecond, microsecond, nanosecond);\n\n    seconds = _ES$BalanceSubSecond2.seconds;\n    millisecond = _ES$BalanceSubSecond2.millisecond;\n    microsecond = _ES$BalanceSubSecond2.microsecond;\n    nanosecond = _ES$BalanceSubSecond2.nanosecond;\n    second += seconds;\n    minute += Math.floor(second / 60);\n    second = ES.NonNegativeModulo(second, 60);\n    hour += Math.floor(minute / 60);\n    minute = ES.NonNegativeModulo(minute, 60);\n    var deltaDays = Math.floor(hour / 24);\n    hour = ES.NonNegativeModulo(hour, 24);\n    return {\n      deltaDays: deltaDays,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  BalanceDurationDate: function BalanceDurationDate(years, months, startYear, startMonth, startDay) {\n    if (months < 0) {\n      years -= 1;\n      months += 12;\n    }\n\n    var _ES$BalanceYearMonth4 = ES.BalanceYearMonth(startYear + years, startMonth + months),\n        year = _ES$BalanceYearMonth4.year,\n        month = _ES$BalanceYearMonth4.month;\n\n    while (startDay > ES.DaysInMonth(year, month)) {\n      months -= 1;\n\n      if (months < 0) {\n        years -= 1;\n        months += 12;\n      }\n\n      var _ES$BalanceYearMonth5 = ES.BalanceYearMonth(startYear + years, startMonth + months);\n\n      year = _ES$BalanceYearMonth5.year;\n      month = _ES$BalanceYearMonth5.month;\n    }\n\n    return {\n      year: year,\n      month: month,\n      years: years,\n      months: months\n    };\n  },\n  BalanceDuration: function BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit) {\n    var deltaDays;\n\n    var _ES$BalanceTime2 = ES.BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    deltaDays = _ES$BalanceTime2.deltaDays;\n    hours = _ES$BalanceTime2.hour;\n    minutes = _ES$BalanceTime2.minute;\n    seconds = _ES$BalanceTime2.second;\n    milliseconds = _ES$BalanceTime2.millisecond;\n    microseconds = _ES$BalanceTime2.microsecond;\n    nanoseconds = _ES$BalanceTime2.nanosecond;\n    days += deltaDays;\n\n    switch (largestUnit) {\n      case 'hours':\n        hours += 24 * days;\n        days = 0;\n        break;\n\n      case 'minutes':\n        minutes += 60 * (hours + 24 * days);\n        hours = days = 0;\n        break;\n\n      case 'seconds':\n        seconds += 60 * (minutes + 60 * (hours + 24 * days));\n        minutes = hours = days = 0;\n        break;\n\n      case 'years':\n      case 'months':\n      case 'weeks':\n      case 'days':\n        break;\n\n      default:\n        throw new Error('assert not reached');\n    }\n\n    return {\n      days: days,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      milliseconds: milliseconds,\n      microseconds: microseconds,\n      nanoseconds: nanoseconds\n    };\n  },\n  ConstrainToRange: function ConstrainToRange(value, min, max) {\n    return Math.min(max, Math.max(min, value));\n  },\n  ConstrainDate: function ConstrainDate(year, month, day) {\n    month = ES.ConstrainToRange(month, 1, 12);\n    day = ES.ConstrainToRange(day, 1, ES.DaysInMonth(year, month));\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  ConstrainDateRange: function ConstrainDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    var _ES$ConstrainDateTime3 = ES.ConstrainDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n\n    year = _ES$ConstrainDateTime3.year;\n    month = _ES$ConstrainDateTime3.month;\n    day = _ES$ConstrainDateTime3.day;\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  ConstrainTime: function ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    hour = ES.ConstrainToRange(hour, 0, 23);\n    minute = ES.ConstrainToRange(minute, 0, 59);\n    second = ES.ConstrainToRange(second, 0, 59);\n    millisecond = ES.ConstrainToRange(millisecond, 0, 999);\n    microsecond = ES.ConstrainToRange(microsecond, 0, 999);\n    nanosecond = ES.ConstrainToRange(nanosecond, 0, 999);\n    return {\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  ConstrainDateTime: function ConstrainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    var _ES$ConstrainDate4 = ES.ConstrainDate(year, month, day);\n\n    year = _ES$ConstrainDate4.year;\n    month = _ES$ConstrainDate4.month;\n    day = _ES$ConstrainDate4.day;\n\n    var _ES$ConstrainTime2 = ES.ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n\n    hour = _ES$ConstrainTime2.hour;\n    minute = _ES$ConstrainTime2.minute;\n    second = _ES$ConstrainTime2.second;\n    millisecond = _ES$ConstrainTime2.millisecond;\n    microsecond = _ES$ConstrainTime2.microsecond;\n    nanosecond = _ES$ConstrainTime2.nanosecond;\n    return {\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  ConstrainDateTimeRange: function ConstrainDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    year = ES.ConstrainToRange(year, YEAR_MIN, YEAR_MAX); // Constrain to within 24 hours outside the Absolute range\n\n    if (year === YEAR_MIN && null === ES.GetEpochFromParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) {\n      month = 4;\n      day = 19;\n      hour = minute = second = millisecond = microsecond = 0;\n      nanosecond = 1;\n    } else if (year === YEAR_MAX && null === ES.GetEpochFromParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1)) {\n      month = 9;\n      day = 13;\n      hour = 23;\n      minute = second = 59;\n      millisecond = microsecond = nanosecond = 999;\n    }\n\n    return {\n      year: year,\n      month: month,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  ConstrainYearMonthRange: function ConstrainYearMonthRange(year, month) {\n    year = ES.ConstrainToRange(year, YEAR_MIN, YEAR_MAX);\n\n    if (year === YEAR_MIN) {\n      month = ES.ConstrainToRange(month, 4, 12);\n    } else if (year === YEAR_MAX) {\n      month = ES.ConstrainToRange(month, 1, 9);\n    }\n\n    return {\n      year: year,\n      month: month\n    };\n  },\n  RejectToRange: function RejectToRange(value, min, max) {\n    if (value < min || value > max) throw new RangeError(\"value out of range: \".concat(min, \" <= \").concat(value, \" <= \").concat(max));\n  },\n  RejectDate: function RejectDate(year, month, day) {\n    ES.RejectToRange(month, 1, 12);\n    ES.RejectToRange(day, 1, ES.DaysInMonth(year, month));\n  },\n  RejectDateRange: function RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    ES.RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n  },\n  RejectTime: function RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    ES.RejectToRange(hour, 0, 23);\n    ES.RejectToRange(minute, 0, 59);\n    ES.RejectToRange(second, 0, 59);\n    ES.RejectToRange(millisecond, 0, 999);\n    ES.RejectToRange(microsecond, 0, 999);\n    ES.RejectToRange(nanosecond, 0, 999);\n  },\n  RejectDateTime: function RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    ES.RejectDate(year, month, day);\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  },\n  RejectDateTimeRange: function RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    ES.RejectToRange(year, YEAR_MIN, YEAR_MAX); // Reject any DateTime 24 hours or more outside the Absolute range\n\n    if (year === YEAR_MIN && null == ES.GetEpochFromParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1) || year === YEAR_MAX && null == ES.GetEpochFromParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1)) {\n      throw new RangeError('DateTime outside of supported range');\n    }\n  },\n  RejectAbsoluteRange: function RejectAbsoluteRange(epochNanoseconds) {\n    if (epochNanoseconds.lesser(NS_MIN) || epochNanoseconds.greater(NS_MAX)) {\n      throw new RangeError('Absolute outside of supported range');\n    }\n  },\n  RejectYearMonthRange: function RejectYearMonthRange(year, month) {\n    ES.RejectToRange(year, YEAR_MIN, YEAR_MAX);\n\n    if (year === YEAR_MIN) {\n      ES.RejectToRange(month, 4, 12);\n    } else if (year === YEAR_MAX) {\n      ES.RejectToRange(month, 1, 9);\n    }\n  },\n  DifferenceDate: function DifferenceDate(smaller, larger) {\n    var largestUnit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'days';\n    var years = larger.year - smaller.year;\n    var weeks = 0;\n    var months, days;\n\n    switch (largestUnit) {\n      case 'years':\n      case 'months':\n        {\n          months = larger.month - smaller.month;\n          var year, month;\n\n          var _ES$BalanceDurationDa = ES.BalanceDurationDate(years, months, smaller.year, smaller.month, smaller.day);\n\n          year = _ES$BalanceDurationDa.year;\n          month = _ES$BalanceDurationDa.month;\n          years = _ES$BalanceDurationDa.years;\n          months = _ES$BalanceDurationDa.months;\n          days = ES.DayOfYear(larger.year, larger.month, larger.day) - ES.DayOfYear(year, month, smaller.day);\n\n          if (days < 0) {\n            months -= 1;\n\n            var _ES$BalanceDurationDa2 = ES.BalanceDurationDate(years, months, smaller.year, smaller.month, smaller.day);\n\n            year = _ES$BalanceDurationDa2.year;\n            month = _ES$BalanceDurationDa2.month;\n            years = _ES$BalanceDurationDa2.years;\n            months = _ES$BalanceDurationDa2.months;\n            days = ES.DayOfYear(larger.year, larger.month, larger.day) - ES.DayOfYear(year, month, smaller.day);\n            if (larger.year > year) days += ES.LeapYear(year) ? 366 : 365;\n          }\n\n          if (largestUnit === 'months') {\n            months += years * 12;\n            years = 0;\n          }\n\n          break;\n        }\n\n      case 'weeks':\n      case 'days':\n        months = 0;\n        days = ES.DayOfYear(larger.year, larger.month, larger.day) - ES.DayOfYear(smaller.year, smaller.month, smaller.day);\n\n        while (years > 0) {\n          days += ES.LeapYear(smaller.year + years - 1) ? 366 : 365;\n          years -= 1;\n        }\n\n        if (largestUnit === 'weeks') {\n          weeks = Math.floor(days / 7);\n          days %= 7;\n        }\n\n        break;\n\n      default:\n        throw new Error('assert not reached');\n    }\n\n    return {\n      years: years,\n      months: months,\n      weeks: weeks,\n      days: days\n    };\n  },\n  DifferenceTime: function DifferenceTime(earlier, later) {\n    var hours = later.hour - earlier.hour;\n    var minutes = later.minute - earlier.minute;\n    var seconds = later.second - earlier.second;\n    var milliseconds = later.millisecond - earlier.millisecond;\n    var microseconds = later.microsecond - earlier.microsecond;\n    var nanoseconds = later.nanosecond - earlier.nanosecond;\n    var deltaDays = 0;\n\n    var _ES$BalanceTime3 = ES.BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    deltaDays = _ES$BalanceTime3.deltaDays;\n    hours = _ES$BalanceTime3.hour;\n    minutes = _ES$BalanceTime3.minute;\n    seconds = _ES$BalanceTime3.second;\n    milliseconds = _ES$BalanceTime3.millisecond;\n    microseconds = _ES$BalanceTime3.microsecond;\n    nanoseconds = _ES$BalanceTime3.nanosecond;\n    return {\n      deltaDays: deltaDays,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      milliseconds: milliseconds,\n      microseconds: microseconds,\n      nanoseconds: nanoseconds\n    };\n  },\n  AddDate: function AddDate(year, month, day, years, months, weeks, days, disambiguation) {\n    year += years;\n    month += months;\n\n    var _ES$BalanceYearMonth6 = ES.BalanceYearMonth(year, month);\n\n    year = _ES$BalanceYearMonth6.year;\n    month = _ES$BalanceYearMonth6.month;\n\n    var _ES$RegulateDate = ES.RegulateDate(year, month, day, disambiguation);\n\n    year = _ES$RegulateDate.year;\n    month = _ES$RegulateDate.month;\n    day = _ES$RegulateDate.day;\n    days += 7 * weeks;\n    day += days;\n\n    var _ES$BalanceDate2 = ES.BalanceDate(year, month, day);\n\n    year = _ES$BalanceDate2.year;\n    month = _ES$BalanceDate2.month;\n    day = _ES$BalanceDate2.day;\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  AddTime: function AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    var deltaDays = 0;\n\n    var _ES$BalanceTime4 = ES.BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n\n    deltaDays = _ES$BalanceTime4.deltaDays;\n    hour = _ES$BalanceTime4.hour;\n    minute = _ES$BalanceTime4.minute;\n    second = _ES$BalanceTime4.second;\n    millisecond = _ES$BalanceTime4.millisecond;\n    microsecond = _ES$BalanceTime4.microsecond;\n    nanosecond = _ES$BalanceTime4.nanosecond;\n    return {\n      deltaDays: deltaDays,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  SubtractDate: function SubtractDate(year, month, day, years, months, weeks, days, disambiguation) {\n    days += 7 * weeks;\n    day -= days;\n\n    var _ES$BalanceDate3 = ES.BalanceDate(year, month, day);\n\n    year = _ES$BalanceDate3.year;\n    month = _ES$BalanceDate3.month;\n    day = _ES$BalanceDate3.day;\n    month -= months;\n    year -= years;\n\n    var _ES$BalanceYearMonth7 = ES.BalanceYearMonth(year, month);\n\n    year = _ES$BalanceYearMonth7.year;\n    month = _ES$BalanceYearMonth7.month;\n\n    var _ES$RegulateDate2 = ES.RegulateDate(year, month, day, disambiguation);\n\n    year = _ES$RegulateDate2.year;\n    month = _ES$RegulateDate2.month;\n    day = _ES$RegulateDate2.day;\n    return {\n      year: year,\n      month: month,\n      day: day\n    };\n  },\n  SubtractTime: function SubtractTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    hour -= hours;\n    minute -= minutes;\n    second -= seconds;\n    millisecond -= milliseconds;\n    microsecond -= microseconds;\n    nanosecond -= nanoseconds;\n    var deltaDays = 0;\n\n    var _ES$BalanceTime5 = ES.BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n\n    deltaDays = _ES$BalanceTime5.deltaDays;\n    hour = _ES$BalanceTime5.hour;\n    minute = _ES$BalanceTime5.minute;\n    second = _ES$BalanceTime5.second;\n    millisecond = _ES$BalanceTime5.millisecond;\n    microsecond = _ES$BalanceTime5.microsecond;\n    nanosecond = _ES$BalanceTime5.nanosecond;\n    return {\n      deltaDays: deltaDays,\n      hour: hour,\n      minute: minute,\n      second: second,\n      millisecond: millisecond,\n      microsecond: microsecond,\n      nanosecond: nanosecond\n    };\n  },\n  AddDuration: function AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2, disambiguation) {\n    var years = y1 + y2;\n    var months = mon1 + mon2;\n    var weeks = w1 + w2;\n    var days = d1 + d2;\n    var hours = h1 + h2;\n    var minutes = min1 + min2;\n    var seconds = s1 + s2;\n    var milliseconds = ms1 + ms2;\n    var microseconds = s1 + s2;\n    var nanoseconds = ns1 + ns2;\n    return ES.RegulateDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, disambiguation);\n  },\n  SubtractDuration: function SubtractDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, s1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, s2, ns2, disambiguation) {\n    var years = y1 - y2;\n    var months = mon1 - mon2;\n    var weeks = w1 - w2;\n    var days = d1 - d2;\n    var hours = h1 - h2;\n    var minutes = min1 - min2;\n    var seconds = s1 - s2;\n    var milliseconds = ms1 - ms2;\n    var microseconds = s1 - s2;\n    var nanoseconds = ns1 - ns2;\n\n    if (nanoseconds < 0) {\n      microseconds += Math.floor(nanoseconds / 1000);\n      nanoseconds = ES.NonNegativeModulo(nanoseconds, 1000);\n    }\n\n    if (microseconds < 0) {\n      milliseconds += Math.floor(microseconds / 1000);\n      microseconds = ES.NonNegativeModulo(microseconds, 1000);\n    }\n\n    if (milliseconds < 0) {\n      seconds += Math.floor(milliseconds / 1000);\n      milliseconds = ES.NonNegativeModulo(milliseconds, 1000);\n    }\n\n    if (seconds < 0) {\n      minutes += Math.floor(seconds / 60);\n      seconds = ES.NonNegativeModulo(seconds, 60);\n    }\n\n    if (minutes < 0) {\n      hours += Math.floor(minutes / 60);\n      minutes = ES.NonNegativeModulo(minutes, 60);\n    }\n\n    if (hours < 0) {\n      days += Math.floor(hours / 24);\n      hours = ES.NonNegativeModulo(hours, 24);\n    }\n\n    for (var _i4 = 0, _arr4 = [years, months, weeks, days]; _i4 < _arr4.length; _i4++) {\n      var prop = _arr4[_i4];\n      if (prop < 0) throw new RangeError('negative values not allowed as duration fields');\n    }\n\n    if (disambiguation === 'balance') {\n      return ES.RegulateDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'balance');\n    }\n\n    return {\n      years: years,\n      months: months,\n      weeks: weeks,\n      days: days,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      milliseconds: milliseconds,\n      microseconds: microseconds,\n      nanoseconds: nanoseconds\n    };\n  },\n  AssertPositiveInteger: function AssertPositiveInteger(num) {\n    if (!Number.isFinite(num) || Math.abs(num) !== num) throw new RangeError(\"invalid positive integer: \".concat(num));\n    return num;\n  },\n  NonNegativeModulo: function NonNegativeModulo(x, y) {\n    var result = x % y;\n    if (Object.is(result, -0)) return 0;\n    if (result < 0) result += y;\n    return result;\n  },\n  ToBigInt: function ToBigInt(arg) {\n    if (BigInteger.isInstance(arg)) return arg;\n    var prim = ES.ToPrimitive(arg, Number);\n    if (typeof prim === 'number') throw new TypeError('Use BigInt() to convert Number to BigInt');\n\n    try {\n      return BigInteger(prim);\n    } catch (e) {\n      if (e instanceof Error && e.message.startsWith('Invalid integer')) throw new SyntaxError(e.message);\n      throw e;\n    }\n  },\n  // Note: This method returns values with bogus nanoseconds based on the previous iteration's\n  // milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n  // increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\n  SystemUTCEpochNanoSeconds: function () {\n    var ns = Date.now() % 1e6;\n    return function () {\n      var ms = Date.now();\n      var result = BigInteger(ms).multiply(1e6).plus(ns);\n      ns = ms % 1e6;\n      return result;\n    };\n  }(),\n  SystemTimeZone: function SystemTimeZone() {\n    var fmt = new IntlDateTimeFormat('en-us');\n    var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ES.TemporalTimeZoneFromString(fmt.resolvedOptions().timeZone));\n  },\n  ComparisonResult: function ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n  },\n  GetOption: function GetOption(options, property, allowedValues, fallback) {\n    if (options === null || options === undefined) return fallback;\n    options = ES.ToObject(options);\n    var value = options[property];\n\n    if (value !== undefined) {\n      value = ES.ToString(value);\n\n      if (!allowedValues.includes(value)) {\n        throw new RangeError(\"\".concat(property, \" must be one of \").concat(allowedValues.join(', '), \", not \").concat(value));\n      }\n\n      return value;\n    }\n\n    return fallback;\n  }\n});\nvar OFFSET = new RegExp(\"^\".concat(offset.source, \"$\"));\n\nfunction parseOffsetString(string) {\n  var match = OFFSET.exec(String(string));\n  if (!match) return null;\n  var sign = match[1] === '-' ? -1 : +1;\n  var hours = +match[2];\n  var minutes = +(match[3] || 0);\n  return sign * (hours * 60 + minutes) * 60 * 1e9;\n}\n\nfunction reduceParts(res, item) {\n  if (item.type === 'literal') return res;\n  if (item.type === 'timeZoneName') return res;\n  res[item.type] = parseInt(item.value, 10);\n  return res;\n}\n\nfunction bisect(getState, left, right) {\n  var lstate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getState(left);\n  var rstate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : getState(right);\n  left = BigInteger(left);\n  right = BigInteger(right);\n\n  while (right.minus(left).greater(1)) {\n    var middle = left.plus(right).divide(2);\n    var mstate = getState(middle);\n\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      throw new Error(\"invalid state in bisection \".concat(lstate, \" - \").concat(mstate, \" - \").concat(rstate));\n    }\n  }\n\n  return right;\n}\n\nvar Absolute = /*#__PURE__*/function () {\n  function Absolute(epochNanoseconds) {\n    _classCallCheck(this, Absolute);\n\n    var ns = ES.ToBigInt(epochNanoseconds);\n    ES.RejectAbsoluteRange(ns);\n    CreateSlots(this);\n    SetSlot(this, EPOCHNANOSECONDS, ns);\n  }\n\n  _createClass(Absolute, [{\n    key: \"getEpochSeconds\",\n    value: function getEpochSeconds() {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      var value = GetSlot(this, EPOCHNANOSECONDS);\n      return +value.divide(1e9);\n    }\n  }, {\n    key: \"getEpochMilliseconds\",\n    value: function getEpochMilliseconds() {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      var value = BigInteger(GetSlot(this, EPOCHNANOSECONDS));\n      return +value.divide(1e6);\n    }\n  }, {\n    key: \"getEpochMicroseconds\",\n    value: function getEpochMicroseconds() {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      var value = GetSlot(this, EPOCHNANOSECONDS);\n      return bigIntIfAvailable(value.divide(1e3));\n    }\n  }, {\n    key: \"getEpochNanoseconds\",\n    value: function getEpochNanoseconds() {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      return bigIntIfAvailable(GetSlot(this, EPOCHNANOSECONDS));\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(temporalDurationLike) {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n\n      var _ES$ToLimitedTemporal = ES.ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months']),\n          days = _ES$ToLimitedTemporal.days,\n          hours = _ES$ToLimitedTemporal.hours,\n          minutes = _ES$ToLimitedTemporal.minutes,\n          seconds = _ES$ToLimitedTemporal.seconds,\n          milliseconds = _ES$ToLimitedTemporal.milliseconds,\n          microseconds = _ES$ToLimitedTemporal.microseconds,\n          nanoseconds = _ES$ToLimitedTemporal.nanoseconds;\n\n      var add = BigInteger(0);\n      add = add.plus(BigInteger(nanoseconds));\n      add = add.plus(BigInteger(microseconds).multiply(1e3));\n      add = add.plus(BigInteger(milliseconds).multiply(1e6));\n      add = add.plus(BigInteger(seconds).multiply(1e9));\n      add = add.plus(BigInteger(minutes).multiply(60 * 1e9));\n      add = add.plus(BigInteger(hours).multiply(60 * 60 * 1e9));\n      add = add.plus(BigInteger(days).multiply(24 * 60 * 60 * 1e9));\n      var ns = BigInteger(GetSlot(this, EPOCHNANOSECONDS)).plus(add);\n      ES.RejectAbsoluteRange(ns);\n      var Construct = ES.SpeciesConstructor(this, Absolute);\n      var result = new Construct(bigIntIfAvailable(ns));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(temporalDurationLike) {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n\n      var _ES$ToLimitedTemporal2 = ES.ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months']),\n          days = _ES$ToLimitedTemporal2.days,\n          hours = _ES$ToLimitedTemporal2.hours,\n          minutes = _ES$ToLimitedTemporal2.minutes,\n          seconds = _ES$ToLimitedTemporal2.seconds,\n          milliseconds = _ES$ToLimitedTemporal2.milliseconds,\n          microseconds = _ES$ToLimitedTemporal2.microseconds,\n          nanoseconds = _ES$ToLimitedTemporal2.nanoseconds;\n\n      var add = BigInteger(0);\n      add = add.plus(BigInteger(nanoseconds));\n      add = add.plus(BigInteger(microseconds).multiply(1e3));\n      add = add.plus(BigInteger(milliseconds).multiply(1e6));\n      add = add.plus(BigInteger(seconds).multiply(1e9));\n      add = add.plus(BigInteger(minutes).multiply(60 * 1e9));\n      add = add.plus(BigInteger(hours).multiply(60 * 60 * 1e9));\n      add = add.plus(BigInteger(days).multiply(24 * 60 * 60 * 1e9));\n      var ns = BigInteger(GetSlot(this, EPOCHNANOSECONDS)).minus(add);\n      ES.RejectAbsoluteRange(ns);\n      var Construct = ES.SpeciesConstructor(this, Absolute);\n      var result = new Construct(bigIntIfAvailable(ns));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(other, options) {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalAbsolute(other)) throw new TypeError('invalid Absolute object');\n      var largestUnit = ES.ToLargestTemporalUnit(options, 'seconds', ['years', 'months', 'weeks']);\n      var comparison = Absolute.compare(this, other);\n      if (comparison < 0) throw new RangeError('other instance cannot be larger than `this`');\n      var onens = GetSlot(other, EPOCHNANOSECONDS);\n      var twons = GetSlot(this, EPOCHNANOSECONDS);\n      var diff = twons.minus(onens);\n      var ns = +diff.mod(1e3);\n      var us = +diff.divide(1e3).mod(1e3);\n      var ms = +diff.divide(1e6).mod(1e3);\n      var ss = +diff.divide(1e9);\n      var Duration = GetIntrinsic$1('%Temporal.Duration%');\n\n      var _ES$BalanceDuration = ES.BalanceDuration(0, 0, 0, ss, ms, us, ns, largestUnit),\n          days = _ES$BalanceDuration.days,\n          hours = _ES$BalanceDuration.hours,\n          minutes = _ES$BalanceDuration.minutes,\n          seconds = _ES$BalanceDuration.seconds,\n          milliseconds = _ES$BalanceDuration.milliseconds,\n          microseconds = _ES$BalanceDuration.microseconds,\n          nanoseconds = _ES$BalanceDuration.nanoseconds;\n\n      return new Duration(0, 0, 0, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalAbsolute(other)) throw new TypeError('invalid Absolute object');\n      var one = GetSlot(this, EPOCHNANOSECONDS);\n      var two = GetSlot(other, EPOCHNANOSECONDS);\n      return BigInteger(one).equals(two);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var temporalTimeZoneLike = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'UTC';\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n      var timeZone = TemporalTimeZone.from(temporalTimeZoneLike);\n      return ES.TemporalAbsoluteToString(this, timeZone);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n      var timeZone = new TemporalTimeZone('UTC');\n      return ES.TemporalAbsoluteToString(this, timeZone);\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _construct(Intl.DateTimeFormat, args).format(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('use compare() or equals() to compare Temporal.Absolute');\n    }\n  }, {\n    key: \"inTimeZone\",\n    value: function inTimeZone(temporalTimeZoneLike) {\n      var calendar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (!ES.IsTemporalAbsolute(this)) throw new TypeError('invalid receiver');\n      var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n      var timeZone = TemporalTimeZone.from(temporalTimeZoneLike);\n      if (typeof timeZone.getDateTimeFor === 'function') return timeZone.getDateTimeFor(this, calendar);\n      return TemporalTimeZone.prototype.getDateTimeFor.call(timeZone, this, calendar);\n    }\n  }], [{\n    key: \"fromEpochSeconds\",\n    value: function fromEpochSeconds(epochSeconds) {\n      epochSeconds = ES.ToNumber(epochSeconds);\n      var epochNanoseconds = BigInteger(epochSeconds).multiply(1e9);\n      ES.RejectAbsoluteRange(epochNanoseconds);\n      var result = new this(bigIntIfAvailable(epochNanoseconds));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"fromEpochMilliseconds\",\n    value: function fromEpochMilliseconds(epochMilliseconds) {\n      epochMilliseconds = ES.ToNumber(epochMilliseconds);\n      var epochNanoseconds = BigInteger(epochMilliseconds).multiply(1e6);\n      ES.RejectAbsoluteRange(epochNanoseconds);\n      var result = new this(bigIntIfAvailable(epochNanoseconds));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"fromEpochMicroseconds\",\n    value: function fromEpochMicroseconds(epochMicroseconds) {\n      epochMicroseconds = ES.ToBigInt(epochMicroseconds);\n      var epochNanoseconds = epochMicroseconds.multiply(1e3);\n      ES.RejectAbsoluteRange(epochNanoseconds);\n      var result = new this(bigIntIfAvailable(epochNanoseconds));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"fromEpochNanoseconds\",\n    value: function fromEpochNanoseconds(epochNanoseconds) {\n      epochNanoseconds = ES.ToBigInt(epochNanoseconds);\n      ES.RejectAbsoluteRange(epochNanoseconds);\n      var result = new this(bigIntIfAvailable(epochNanoseconds));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"from\",\n    value: function from(item) {\n      var ns;\n\n      if (ES.IsTemporalAbsolute(item)) {\n        ns = GetSlot(item, EPOCHNANOSECONDS);\n      } else {\n        ns = ES.ParseTemporalAbsolute(ES.ToString(item));\n      }\n\n      var result = new this(bigIntIfAvailable(ns));\n      if (!ES.IsTemporalAbsolute(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(one, two) {\n      if (!ES.IsTemporalAbsolute(one) || !ES.IsTemporalAbsolute(two)) throw new TypeError('invalid Absolute object');\n      one = GetSlot(one, EPOCHNANOSECONDS);\n      two = GetSlot(two, EPOCHNANOSECONDS);\n      if (BigInteger(one).lesser(two)) return -1;\n      if (BigInteger(one).greater(two)) return 1;\n      return 0;\n    }\n  }]);\n\n  return Absolute;\n}();\nMakeIntrinsicClass(Absolute, 'Temporal.Absolute');\n\nfunction bigIntIfAvailable(wrapper) {\n  return typeof BigInt === 'undefined' ? wrapper : wrapper.value;\n}\n\nvar Calendar = /*#__PURE__*/function () {\n  function Calendar(id) {\n    _classCallCheck(this, Calendar);\n\n    CreateSlots(this);\n    SetSlot(this, CALENDAR_ID, id);\n  }\n\n  _createClass(Calendar, [{\n    key: \"dateFromFields\",\n    value: function dateFromFields(fields, options, constructor) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"yearMonthFromFields\",\n    value: function yearMonthFromFields(fields, options, constructor) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"monthDayFromFields\",\n    value: function monthDayFromFields(fields, options, constructor) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(date, duration, options, constructor) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(date, duration, options, constructor) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(smaller, larger, options) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"year\",\n    value: function year(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"month\",\n    value: function month(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"day\",\n    value: function day(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"era\",\n    value: function era(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"dayOfWeek\",\n    value: function dayOfWeek(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"dayOfYear\",\n    value: function dayOfYear(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"weekOfYear\",\n    value: function weekOfYear(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"daysInMonth\",\n    value: function daysInMonth(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"daysInYear\",\n    value: function daysInYear(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"isLeapYear\",\n    value: function isLeapYear(date) {\n      throw new Error('not implemented');\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR_ID);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR_ID);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      if (ES.IsTemporalCalendar(item) || _typeof(item) === 'object' && item) return item;\n      var stringIdent = ES.ToString(item);\n      return GetBuiltinCalendar(stringIdent);\n    }\n  }]);\n\n  return Calendar;\n}();\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\n\nvar ISO8601 = /*#__PURE__*/function (_Calendar) {\n  _inherits(ISO8601, _Calendar);\n\n  var _super = _createSuper(ISO8601);\n\n  function ISO8601() {\n    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'iso8601';\n\n    _classCallCheck(this, ISO8601);\n\n    // Needs to be subclassable, that's why the ID is a default argument\n    return _super.call(this, id);\n  }\n\n  _createClass(ISO8601, [{\n    key: \"dateFromFields\",\n    value: function dateFromFields(fields, options, constructor) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options); // Intentionally alphabetical\n\n      var _ES$ToTemporalDateRec = ES.ToTemporalDateRecord(fields),\n          year = _ES$ToTemporalDateRec.year,\n          month = _ES$ToTemporalDateRec.month,\n          day = _ES$ToTemporalDateRec.day;\n\n      var _ES$RegulateDate = ES.RegulateDate(year, month, day, disambiguation);\n\n      year = _ES$RegulateDate.year;\n      month = _ES$RegulateDate.month;\n      day = _ES$RegulateDate.day;\n\n      var _ES$RegulateDateRange = ES.RegulateDateRange(year, month, day, disambiguation);\n\n      year = _ES$RegulateDateRange.year;\n      month = _ES$RegulateDateRange.month;\n      day = _ES$RegulateDateRange.day;\n      return new constructor(year, month, day, this);\n    }\n  }, {\n    key: \"yearMonthFromFields\",\n    value: function yearMonthFromFields(fields, options, constructor) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options); // Intentionally alphabetical\n\n      var _ES$ToTemporalYearMon = ES.ToTemporalYearMonthRecord(fields),\n          year = _ES$ToTemporalYearMon.year,\n          month = _ES$ToTemporalYearMon.month;\n\n      var _ES$RegulateYearMonth = ES.RegulateYearMonth(year, month, disambiguation);\n\n      year = _ES$RegulateYearMonth.year;\n      month = _ES$RegulateYearMonth.month;\n\n      var _ES$RegulateYearMonth2 = ES.RegulateYearMonthRange(year, month, disambiguation);\n\n      year = _ES$RegulateYearMonth2.year;\n      month = _ES$RegulateYearMonth2.month;\n      return new constructor(year, month, this,\n      /* refIsoDay = */\n      1);\n    }\n  }, {\n    key: \"monthDayFromFields\",\n    value: function monthDayFromFields(fields, options, constructor) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options); // Intentionally alphabetical\n\n      var _ES$ToTemporalMonthDa = ES.ToTemporalMonthDayRecord(fields),\n          month = _ES$ToTemporalMonthDa.month,\n          day = _ES$ToTemporalMonthDa.day;\n\n      var _ES$RegulateMonthDay = ES.RegulateMonthDay(month, day, disambiguation);\n\n      month = _ES$RegulateMonthDay.month;\n      day = _ES$RegulateMonthDay.day;\n      return new constructor(month, day, this,\n      /* refIsoYear = */\n      1972);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(date, duration, options, constructor) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var years = duration.years,\n          months = duration.months,\n          weeks = duration.weeks,\n          days = duration.days;\n      var year = GetSlot(date, ISO_YEAR);\n      var month = GetSlot(date, ISO_MONTH);\n      var day = GetSlot(date, ISO_DAY);\n\n      var _ES$AddDate = ES.AddDate(year, month, day, years, months, weeks, days, disambiguation);\n\n      year = _ES$AddDate.year;\n      month = _ES$AddDate.month;\n      day = _ES$AddDate.day;\n\n      var _ES$RegulateDateRange2 = ES.RegulateDateRange(year, month, day, disambiguation);\n\n      year = _ES$RegulateDateRange2.year;\n      month = _ES$RegulateDateRange2.month;\n      day = _ES$RegulateDateRange2.day;\n      return new constructor(year, month, day, this);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(date, duration, options, constructor) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var years = duration.years,\n          months = duration.months,\n          weeks = duration.weeks,\n          days = duration.days;\n      var year = GetSlot(date, ISO_YEAR);\n      var month = GetSlot(date, ISO_MONTH);\n      var day = GetSlot(date, ISO_DAY);\n\n      var _ES$SubtractDate = ES.SubtractDate(year, month, day, years, months, weeks, days, disambiguation);\n\n      year = _ES$SubtractDate.year;\n      month = _ES$SubtractDate.month;\n      day = _ES$SubtractDate.day;\n\n      var _ES$RegulateDateRange3 = ES.RegulateDateRange(year, month, day, disambiguation);\n\n      year = _ES$RegulateDateRange3.year;\n      month = _ES$RegulateDateRange3.month;\n      day = _ES$RegulateDateRange3.day;\n      return new constructor(year, month, day, this);\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(smaller, larger, options) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      var largestUnit = ES.ToLargestTemporalUnit(options, 'days', ['hours', 'minutes', 'seconds']);\n\n      var _ES$DifferenceDate = ES.DifferenceDate(smaller, larger, largestUnit),\n          years = _ES$DifferenceDate.years,\n          months = _ES$DifferenceDate.months,\n          weeks = _ES$DifferenceDate.weeks,\n          days = _ES$DifferenceDate.days;\n\n      var Duration = GetIntrinsic$1('%Temporal.Duration%');\n      return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n  }, {\n    key: \"year\",\n    value: function year(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return GetSlot(date, ISO_YEAR);\n    }\n  }, {\n    key: \"month\",\n    value: function month(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return GetSlot(date, ISO_MONTH);\n    }\n  }, {\n    key: \"day\",\n    value: function day(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return GetSlot(date, ISO_DAY);\n    }\n  }, {\n    key: \"era\",\n    value: function era(date) {\n      return undefined;\n    }\n  }, {\n    key: \"dayOfWeek\",\n    value: function dayOfWeek(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    }\n  }, {\n    key: \"dayOfYear\",\n    value: function dayOfYear(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    }\n  }, {\n    key: \"weekOfYear\",\n    value: function weekOfYear(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    }\n  }, {\n    key: \"daysInMonth\",\n    value: function daysInMonth(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return ES.DaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    }\n  }, {\n    key: \"daysInYear\",\n    value: function daysInYear(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    }\n  }, {\n    key: \"isLeapYear\",\n    value: function isLeapYear(date) {\n      if (!ES.IsTemporalCalendar(this)) throw new TypeError('invalid receiver');\n      return ES.LeapYear(GetSlot(date, ISO_YEAR));\n    }\n  }]);\n\n  return ISO8601;\n}(Calendar); // According to documentation for Intl.Locale.prototype.calendar on MDN,\n// 'iso8601' calendar is equivalent to 'gregory' except for ISO 8601 week\n// numbering rules, which we do not currently use in Temporal.\n\n\nvar Gregorian = /*#__PURE__*/function (_ISO) {\n  _inherits(Gregorian, _ISO);\n\n  var _super2 = _createSuper(Gregorian);\n\n  function Gregorian() {\n    _classCallCheck(this, Gregorian);\n\n    return _super2.call(this, 'gregory');\n  }\n\n  return Gregorian;\n}(ISO8601); // Implementation details for Japanese calendar\n//\n// NOTE: For convenience, this hacky class only supports the most recent five\n// eras, those of the modern period. For the full list, see:\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\n\n\nvar jpn = {\n  eraStartDates: ['1868-09-08', '1912-07-30', '1926-12-25', '1989-01-08', '2019-05-01'],\n  eraAddends: [1867, 1911, 1925, 1988, 2018],\n  // This is what API consumers pass in as the value of the 'era' field. We use\n  // string constants consisting of the romanized name\n  // Unfortunately these are not unique throughout history, so this should be\n  // solved: https://github.com/tc39/proposal-temporal/issues/526\n  // Otherwise, we'd have to introduce some era numbering system, which (as far\n  // as I can tell from Wikipedia) the calendar doesn't have, so would be\n  // non-standard and confusing, requiring API consumers to figure out \"now what\n  // number is the Reiwa (current) era?\" My understanding is also that this\n  // starting point for eras (0645-06-19) is not the only possible one, since\n  // there are unofficial eras before that.\n  // https://en.wikipedia.org/wiki/Japanese_era_name\n  eraNames: ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'],\n  // Note: C locale era names available at\n  // https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n  compareDate: function compareDate(one, two) {\n    for (var _i = 0, _arr = [ISO_YEAR, ISO_MONTH, ISO_DAY]; _i < _arr.length; _i++) {\n      var slot = _arr[_i];\n      var val1 = GetSlot(one, slot);\n      var val2 = GetSlot(two, slot);\n      if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n    }\n  },\n  findEra: function findEra(date) {\n    var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n    var idx = jpn.eraStartDates.findIndex(function (dateStr) {\n      var _ES$ParseTemporalDate = ES.ParseTemporalDateString(dateStr),\n          year = _ES$ParseTemporalDate.year,\n          month = _ES$ParseTemporalDate.month,\n          day = _ES$ParseTemporalDate.day;\n\n      var startDate = new TemporalDate(year, month, day);\n      return jpn.compareDate(date, startDate) < 0;\n    });\n    if (idx === -1) return jpn.eraStartDates.length - 1;\n    if (idx === 0) return 0;\n    return idx - 1;\n  },\n  isoYear: function isoYear(year, era) {\n    var eraIdx = jpn.eraNames.indexOf(era);\n    if (eraIdx === -1) throw new RangeError(\"invalid era \".concat(era));\n    return year + jpn.eraAddends[eraIdx];\n  }\n};\n\nvar Japanese = /*#__PURE__*/function (_ISO2) {\n  _inherits(Japanese, _ISO2);\n\n  var _super3 = _createSuper(Japanese);\n\n  function Japanese() {\n    _classCallCheck(this, Japanese);\n\n    return _super3.call(this, 'japanese');\n  }\n\n  _createClass(Japanese, [{\n    key: \"era\",\n    value: function era(date) {\n      return jpn.eraNames[jpn.findEra(date)];\n    }\n  }, {\n    key: \"year\",\n    value: function year(date) {\n      var eraIdx = jpn.findEra(date);\n      return GetSlot(date, ISO_YEAR) - jpn.eraAddends[eraIdx];\n    }\n  }, {\n    key: \"dateFromFields\",\n    value: function dateFromFields(fields, options, constructor) {\n      // Intentionally alphabetical\n      fields = ES.ToRecord(fields, [['day'], ['era'], ['month'], ['year']]);\n      var isoYear = jpn.isoYear(fields.year, fields.era);\n      return _get(_getPrototypeOf(Japanese.prototype), \"dateFromFields\", this).call(this, _objectSpread2(_objectSpread2({}, fields), {}, {\n        year: isoYear\n      }), options, constructor);\n    }\n  }, {\n    key: \"yearMonthFromFields\",\n    value: function yearMonthFromFields(fields, options, constructor) {\n      // Intentionally alphabetical\n      fields = ES.ToRecord(fields, [['era'], ['month'], ['year']]);\n      var isoYear = jpn.isoYear(fields.year, fields.era);\n      return _get(_getPrototypeOf(Japanese.prototype), \"yearMonthFromFields\", this).call(this, _objectSpread2(_objectSpread2({}, fields), {}, {\n        year: isoYear\n      }), options, constructor);\n    }\n  }]);\n\n  return Japanese;\n}(ISO8601);\n\nvar BUILTIN_CALENDARS = {\n  gregory: Gregorian,\n  iso8601: ISO8601,\n  japanese: Japanese // To be filled in as builtin calendars are implemented\n\n};\n\nfunction GetBuiltinCalendar(id) {\n  if (!(id in BUILTIN_CALENDARS)) throw new RangeError(\"unknown calendar \".concat(id));\n  return new BUILTIN_CALENDARS[id]();\n}\n\nfunction GetDefaultCalendar() {\n  return GetBuiltinCalendar('iso8601');\n}\n\nvar ObjectAssign$1 = Object.assign;\nvar Date$1 = /*#__PURE__*/function () {\n  function Date(isoYear, isoMonth, isoDay) {\n    var calendar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    _classCallCheck(this, Date);\n\n    isoYear = ES.ToInteger(isoYear);\n    isoMonth = ES.ToInteger(isoMonth);\n    isoDay = ES.ToInteger(isoDay);\n    if (calendar === undefined) calendar = GetDefaultCalendar();\n    ES.RejectDate(isoYear, isoMonth, isoDay);\n    ES.RejectDateRange(isoYear, isoMonth, isoDay);\n    if (!calendar || _typeof(calendar) !== 'object') throw new RangeError('invalid calendar');\n    CreateSlots(this);\n    SetSlot(this, ISO_YEAR, isoYear);\n    SetSlot(this, ISO_MONTH, isoMonth);\n    SetSlot(this, ISO_DAY, isoDay);\n    SetSlot(this, CALENDAR, calendar);\n  }\n\n  _createClass(Date, [{\n    key: \"with\",\n    value: function _with() {\n      var temporalDateLike = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var source;\n      var calendar = temporalDateLike.calendar;\n\n      if (calendar) {\n        var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n        calendar = TemporalCalendar.from(calendar);\n        source = new Date(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n      } else {\n        calendar = GetSlot(this, CALENDAR);\n        source = this;\n      }\n\n      var props = ES.ToPartialRecord(temporalDateLike, ['day', 'era', 'month', 'year']);\n\n      if (!props) {\n        throw new RangeError('invalid date-like');\n      }\n\n      var fields = ES.ToTemporalDateRecord(source);\n      ObjectAssign$1(fields, props);\n      var Construct = ES.SpeciesConstructor(this, Date);\n      var result = calendar.dateFromFields(fields, options, Construct);\n      if (!ES.IsTemporalDate(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"withCalendar\",\n    value: function withCalendar(calendar) {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      calendar = TemporalCalendar.from(calendar);\n      var Construct = ES.SpeciesConstructor(this, Date);\n      var result = new Construct(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n      if (!ES.IsTemporalDate(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(temporalDurationLike, options) {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var _duration = duration,\n          years = _duration.years,\n          months = _duration.months,\n          weeks = _duration.weeks,\n          hours = _duration.hours,\n          minutes = _duration.minutes,\n          seconds = _duration.seconds,\n          milliseconds = _duration.milliseconds,\n          microseconds = _duration.microseconds,\n          nanoseconds = _duration.nanoseconds;\n\n      var _ES$BalanceDuration = ES.BalanceDuration(duration.days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days'),\n          days = _ES$BalanceDuration.days;\n\n      duration = {\n        years: years,\n        months: months,\n        weeks: weeks,\n        days: days\n      };\n      var Construct = ES.SpeciesConstructor(this, Date);\n      var result = GetSlot(this, CALENDAR).plus(this, duration, options, Construct);\n      if (!ES.IsTemporalDate(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(temporalDurationLike, options) {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var _duration2 = duration,\n          years = _duration2.years,\n          months = _duration2.months,\n          weeks = _duration2.weeks,\n          hours = _duration2.hours,\n          minutes = _duration2.minutes,\n          seconds = _duration2.seconds,\n          milliseconds = _duration2.milliseconds,\n          microseconds = _duration2.microseconds,\n          nanoseconds = _duration2.nanoseconds;\n\n      var _ES$BalanceDuration2 = ES.BalanceDuration(duration.days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days'),\n          days = _ES$BalanceDuration2.days;\n\n      duration = {\n        years: years,\n        months: months,\n        weeks: weeks,\n        days: days\n      };\n      var Construct = ES.SpeciesConstructor(this, Date);\n      var result = GetSlot(this, CALENDAR).minus(this, duration, options, Construct);\n      if (!ES.IsTemporalDate(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(other, options) {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalDate(other)) throw new TypeError('invalid Date object');\n      var calendar = GetSlot(this, CALENDAR);\n\n      if (calendar.id !== GetSlot(other, CALENDAR).id) {\n        other = new Date(GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), calendar);\n      }\n\n      var comparison = Date.compare(this, other);\n      if (comparison < 0) throw new RangeError('other instance cannot be larger than `this`');\n      return calendar.difference(other, this, options);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalDate(other)) throw new TypeError('invalid Date object');\n\n      for (var _i = 0, _arr = [ISO_YEAR, ISO_MONTH, ISO_DAY]; _i < _arr.length; _i++) {\n        var slot = _arr[_i];\n        var val1 = GetSlot(this, slot);\n        var val2 = GetSlot(other, slot);\n        if (val1 !== val2) return false;\n      }\n\n      return GetSlot(this, CALENDAR).id === GetSlot(other, CALENDAR).id;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var year = ES.ISOYearString(GetSlot(this, ISO_YEAR));\n      var month = ES.ISODateTimePartString(GetSlot(this, ISO_MONTH));\n      var day = ES.ISODateTimePartString(GetSlot(this, ISO_DAY));\n      var calendar = ES.FormatCalendarAnnotation(GetSlot(this, CALENDAR));\n      var resultString = \"\".concat(year, \"-\").concat(month, \"-\").concat(day).concat(calendar);\n      return resultString;\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _construct(Intl.DateTimeFormat, args).format(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('use compare() or equals() to compare Temporal.Date');\n    }\n  }, {\n    key: \"withTime\",\n    value: function withTime(temporalTime) {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalTime(temporalTime)) throw new TypeError('invalid Temporal.Time object');\n      var year = GetSlot(this, ISO_YEAR);\n      var month = GetSlot(this, ISO_MONTH);\n      var day = GetSlot(this, ISO_DAY);\n      var calendar = GetSlot(this, CALENDAR);\n      var hour = GetSlot(temporalTime, HOUR);\n      var minute = GetSlot(temporalTime, MINUTE);\n      var second = GetSlot(temporalTime, SECOND);\n      var millisecond = GetSlot(temporalTime, MILLISECOND);\n      var microsecond = GetSlot(temporalTime, MICROSECOND);\n      var nanosecond = GetSlot(temporalTime, NANOSECOND);\n      var DateTime = GetIntrinsic$1('%Temporal.DateTime%');\n      return new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n  }, {\n    key: \"getYearMonth\",\n    value: function getYearMonth() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var YearMonth = GetIntrinsic$1('%Temporal.YearMonth%');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalDateRecord(this);\n      return calendar.yearMonthFromFields(fields, {}, YearMonth);\n    }\n  }, {\n    key: \"getMonthDay\",\n    value: function getMonthDay() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      var MonthDay = GetIntrinsic$1('%Temporal.MonthDay%');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalDateRecord(this);\n      return calendar.monthDayFromFields(fields, {}, MonthDay);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = ES.ToTemporalDateRecord(this);\n      if (!fields) throw new TypeError('invalid receiver');\n      fields.calendar = GetSlot(this, CALENDAR);\n      return fields;\n    }\n  }, {\n    key: \"getISOCalendarFields\",\n    value: function getISOCalendarFields() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return {\n        year: GetSlot(this, ISO_YEAR),\n        month: GetSlot(this, ISO_MONTH),\n        day: GetSlot(this, ISO_DAY)\n      };\n    }\n  }, {\n    key: \"year\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).year(this);\n    }\n  }, {\n    key: \"month\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).month(this);\n    }\n  }, {\n    key: \"day\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).day(this);\n    }\n  }, {\n    key: \"calendar\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR);\n    }\n  }, {\n    key: \"era\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).era(this);\n    }\n  }, {\n    key: \"dayOfWeek\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).dayOfWeek(this);\n    }\n  }, {\n    key: \"dayOfYear\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).dayOfYear(this);\n    }\n  }, {\n    key: \"weekOfYear\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).weekOfYear(this);\n    }\n  }, {\n    key: \"daysInYear\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).daysInYear(this);\n    }\n  }, {\n    key: \"daysInMonth\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).daysInMonth(this);\n    }\n  }, {\n    key: \"isLeapYear\",\n    get: function get() {\n      if (!ES.IsTemporalDate(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).isLeapYear(this);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      var result;\n\n      if (_typeof(item) === 'object' && item) {\n        if (ES.IsTemporalDate(item)) {\n          var year = GetSlot(item, ISO_YEAR);\n          var month = GetSlot(item, ISO_MONTH);\n          var day = GetSlot(item, ISO_DAY);\n          var calendar = GetSlot(item, CALENDAR);\n          result = new this(year, month, day, calendar);\n        } else {\n          var _calendar = item.calendar;\n          if (_calendar === undefined) _calendar = GetDefaultCalendar();\n          _calendar = TemporalCalendar.from(_calendar);\n          result = _calendar.dateFromFields(item, options, this);\n        }\n      } else {\n        var _ES$ParseTemporalDate = ES.ParseTemporalDateString(ES.ToString(item)),\n            _year = _ES$ParseTemporalDate.year,\n            _month = _ES$ParseTemporalDate.month,\n            _day = _ES$ParseTemporalDate.day,\n            _calendar2 = _ES$ParseTemporalDate.calendar;\n\n        var _ES$RegulateDate = ES.RegulateDate(_year, _month, _day, disambiguation);\n\n        _year = _ES$RegulateDate.year;\n        _month = _ES$RegulateDate.month;\n        _day = _ES$RegulateDate.day;\n\n        var _ES$RegulateDateRange = ES.RegulateDateRange(_year, _month, _day, disambiguation);\n\n        _year = _ES$RegulateDateRange.year;\n        _month = _ES$RegulateDateRange.month;\n        _day = _ES$RegulateDateRange.day;\n        if (!_calendar2) _calendar2 = GetDefaultCalendar();\n        _calendar2 = TemporalCalendar.from(_calendar2);\n        result = new this(_year, _month, _day, _calendar2);\n      }\n\n      if (!ES.IsTemporalDate(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(one, two) {\n      if (!ES.IsTemporalDate(one) || !ES.IsTemporalDate(two)) throw new TypeError('invalid Date object');\n\n      for (var _i2 = 0, _arr2 = [ISO_YEAR, ISO_MONTH, ISO_DAY]; _i2 < _arr2.length; _i2++) {\n        var slot = _arr2[_i2];\n        var val1 = GetSlot(one, slot);\n        var val2 = GetSlot(two, slot);\n        if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n      }\n\n      var cal1 = GetSlot(one, CALENDAR).id;\n      var cal2 = GetSlot(two, CALENDAR).id;\n      return ES.ComparisonResult(cal1 < cal2 ? -1 : cal1 > cal2 ? 1 : 0);\n    }\n  }]);\n\n  return Date;\n}();\nDate$1.prototype.toJSON = Date$1.prototype.toString;\nMakeIntrinsicClass(Date$1, 'Temporal.Date');\n\nvar ObjectAssign$2 = Object.assign;\nvar DateTime = /*#__PURE__*/function () {\n  function DateTime(isoYear, isoMonth, isoDay) {\n    var hour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var minute = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var second = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var millisecond = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var microsecond = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var nanosecond = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    var calendar = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : undefined;\n\n    _classCallCheck(this, DateTime);\n\n    isoYear = ES.ToInteger(isoYear);\n    isoMonth = ES.ToInteger(isoMonth);\n    isoDay = ES.ToInteger(isoDay);\n    hour = ES.ToInteger(hour);\n    minute = ES.ToInteger(minute);\n    second = ES.ToInteger(second);\n    millisecond = ES.ToInteger(millisecond);\n    microsecond = ES.ToInteger(microsecond);\n    nanosecond = ES.ToInteger(nanosecond);\n    if (calendar === undefined) calendar = GetDefaultCalendar();\n    ES.RejectDateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond);\n    ES.RejectDateTimeRange(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (!calendar || _typeof(calendar) !== 'object') throw new RangeError('invalid calendar');\n    CreateSlots(this);\n    SetSlot(this, ISO_YEAR, isoYear);\n    SetSlot(this, ISO_MONTH, isoMonth);\n    SetSlot(this, ISO_DAY, isoDay);\n    SetSlot(this, HOUR, hour);\n    SetSlot(this, MINUTE, minute);\n    SetSlot(this, SECOND, second);\n    SetSlot(this, MILLISECOND, millisecond);\n    SetSlot(this, MICROSECOND, microsecond);\n    SetSlot(this, NANOSECOND, nanosecond);\n    SetSlot(this, CALENDAR, calendar);\n  }\n\n  _createClass(DateTime, [{\n    key: \"with\",\n    value: function _with(temporalDateTimeLike, options) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var source;\n      var calendar = temporalDateTimeLike.calendar;\n\n      if (calendar) {\n        var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n        calendar = TemporalCalendar.from(calendar);\n        source = new DateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, HOUR), GetSlot(this, MINUTE), GetSlot(this, SECOND), GetSlot(this, MILLISECOND), GetSlot(this, MICROSECOND), GetSlot(this, NANOSECOND), calendar);\n      } else {\n        calendar = GetSlot(this, CALENDAR);\n        source = this;\n      }\n\n      var props = ES.ToPartialRecord(temporalDateTimeLike, ['day', 'era', 'hour', 'microsecond', 'millisecond', 'minute', 'month', 'nanosecond', 'second', 'year']);\n\n      if (!props) {\n        throw new RangeError('invalid date-time-like');\n      }\n\n      var fields = ES.ToTemporalDateTimeRecord(source);\n      ObjectAssign$2(fields, props);\n      var date = calendar.dateFromFields(fields, options, GetIntrinsic$1('%Temporal.Date%'));\n      var year = GetSlot(date, ISO_YEAR);\n      var month = GetSlot(date, ISO_MONTH);\n      var day = GetSlot(date, ISO_DAY);\n      var hour = fields.hour,\n          minute = fields.minute,\n          second = fields.second,\n          millisecond = fields.millisecond,\n          microsecond = fields.microsecond,\n          nanosecond = fields.nanosecond;\n\n      var _ES$RegulateTime = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      hour = _ES$RegulateTime.hour;\n      minute = _ES$RegulateTime.minute;\n      second = _ES$RegulateTime.second;\n      millisecond = _ES$RegulateTime.millisecond;\n      microsecond = _ES$RegulateTime.microsecond;\n      nanosecond = _ES$RegulateTime.nanosecond;\n\n      var _ES$RegulateDateTimeR = ES.RegulateDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      year = _ES$RegulateDateTimeR.year;\n      month = _ES$RegulateDateTimeR.month;\n      day = _ES$RegulateDateTimeR.day;\n      hour = _ES$RegulateDateTimeR.hour;\n      minute = _ES$RegulateDateTimeR.minute;\n      second = _ES$RegulateDateTimeR.second;\n      millisecond = _ES$RegulateDateTimeR.millisecond;\n      microsecond = _ES$RegulateDateTimeR.microsecond;\n      nanosecond = _ES$RegulateDateTimeR.nanosecond;\n      var Construct = ES.SpeciesConstructor(this, DateTime);\n      var result = new Construct(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n      if (!ES.IsTemporalDateTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"withCalendar\",\n    value: function withCalendar(calendar) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      calendar = TemporalCalendar.from(calendar);\n      var Construct = ES.SpeciesConstructor(this, DateTime);\n      var result = new Construct(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, HOUR), GetSlot(this, MINUTE), GetSlot(this, SECOND), GetSlot(this, MILLISECOND), GetSlot(this, MICROSECOND), GetSlot(this, NANOSECOND), calendar);\n      if (!ES.IsTemporalDateTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(temporalDurationLike, options) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var _duration = duration,\n          years = _duration.years,\n          months = _duration.months,\n          days = _duration.days,\n          weeks = _duration.weeks,\n          hours = _duration.hours,\n          minutes = _duration.minutes,\n          seconds = _duration.seconds,\n          milliseconds = _duration.milliseconds,\n          microseconds = _duration.microseconds,\n          nanoseconds = _duration.nanoseconds;\n\n      var _ES$BalanceDuration = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days');\n\n      days = _ES$BalanceDuration.days;\n      hours = _ES$BalanceDuration.hours;\n      minutes = _ES$BalanceDuration.minutes;\n      seconds = _ES$BalanceDuration.seconds;\n      milliseconds = _ES$BalanceDuration.milliseconds;\n      microseconds = _ES$BalanceDuration.microseconds;\n      nanoseconds = _ES$BalanceDuration.nanoseconds;\n      duration = {\n        years: years,\n        months: months,\n        weeks: weeks,\n        days: days,\n        hours: hours,\n        minutes: minutes,\n        seconds: seconds,\n        milliseconds: milliseconds,\n        microseconds: microseconds,\n        nanoseconds: nanoseconds\n      }; // Add the time part\n\n      var hour = this.hour,\n          minute = this.minute,\n          second = this.second,\n          millisecond = this.millisecond,\n          microsecond = this.microsecond,\n          nanosecond = this.nanosecond;\n      var deltaDays = 0;\n\n      var _ES$AddTime = ES.AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n      deltaDays = _ES$AddTime.deltaDays;\n      hour = _ES$AddTime.hour;\n      minute = _ES$AddTime.minute;\n      second = _ES$AddTime.second;\n      millisecond = _ES$AddTime.millisecond;\n      microsecond = _ES$AddTime.microsecond;\n      nanosecond = _ES$AddTime.nanosecond;\n      duration.days += deltaDays; // Delegate the date part addition to the calendar\n\n      var calendar = GetSlot(this, CALENDAR);\n      var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n      var datePart = new TemporalDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n      var addedDate = calendar.plus(datePart, duration, options, TemporalDate);\n      var year = GetSlot(addedDate, ISO_YEAR);\n      var month = GetSlot(addedDate, ISO_MONTH);\n      var day = GetSlot(addedDate, ISO_DAY);\n\n      if (disambiguation === 'constrain') {\n        // Special case to determine if the date was clipped by dateFromFields\n        // and therefore the time possibly needs to be clipped too\n        try {\n          calendar.plus(datePart, duration, {\n            disambiguation: 'reject'\n          }, TemporalDate);\n        } catch (_unused) {\n          // Date was clipped\n          if (year === 275760 && month === 9 && day === 13) {\n            // Clipped at end of range\n            day += 1;\n          } else if (year === -271821 && month === 4 && day === 19) {\n            // Clipped at beginning of range\n            day -= 1;\n          }\n\n          var _ES$BalanceDate = ES.BalanceDate(year, month, day);\n\n          year = _ES$BalanceDate.year;\n          month = _ES$BalanceDate.month;\n          day = _ES$BalanceDate.day;\n        }\n      }\n\n      var _ES$RegulateDateTimeR2 = ES.RegulateDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      year = _ES$RegulateDateTimeR2.year;\n      month = _ES$RegulateDateTimeR2.month;\n      day = _ES$RegulateDateTimeR2.day;\n      hour = _ES$RegulateDateTimeR2.hour;\n      minute = _ES$RegulateDateTimeR2.minute;\n      second = _ES$RegulateDateTimeR2.second;\n      millisecond = _ES$RegulateDateTimeR2.millisecond;\n      microsecond = _ES$RegulateDateTimeR2.microsecond;\n      nanosecond = _ES$RegulateDateTimeR2.nanosecond;\n      var Construct = ES.SpeciesConstructor(this, DateTime);\n      var result = new Construct(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n      if (!ES.IsTemporalDateTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(temporalDurationLike, options) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var _duration2 = duration,\n          years = _duration2.years,\n          months = _duration2.months,\n          days = _duration2.days,\n          weeks = _duration2.weeks,\n          hours = _duration2.hours,\n          minutes = _duration2.minutes,\n          seconds = _duration2.seconds,\n          milliseconds = _duration2.milliseconds,\n          microseconds = _duration2.microseconds,\n          nanoseconds = _duration2.nanoseconds;\n\n      var _ES$BalanceDuration2 = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days');\n\n      days = _ES$BalanceDuration2.days;\n      hours = _ES$BalanceDuration2.hours;\n      minutes = _ES$BalanceDuration2.minutes;\n      seconds = _ES$BalanceDuration2.seconds;\n      milliseconds = _ES$BalanceDuration2.milliseconds;\n      microseconds = _ES$BalanceDuration2.microseconds;\n      nanoseconds = _ES$BalanceDuration2.nanoseconds;\n      duration = {\n        years: years,\n        months: months,\n        weeks: weeks,\n        days: days,\n        hours: hours,\n        minutes: minutes,\n        seconds: seconds,\n        milliseconds: milliseconds,\n        microseconds: microseconds,\n        nanoseconds: nanoseconds\n      }; // Subtract the time part\n\n      var hour = this.hour,\n          minute = this.minute,\n          second = this.second,\n          millisecond = this.millisecond,\n          microsecond = this.microsecond,\n          nanosecond = this.nanosecond;\n      var deltaDays = 0;\n\n      var _ES$SubtractTime = ES.SubtractTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n      deltaDays = _ES$SubtractTime.deltaDays;\n      hour = _ES$SubtractTime.hour;\n      minute = _ES$SubtractTime.minute;\n      second = _ES$SubtractTime.second;\n      millisecond = _ES$SubtractTime.millisecond;\n      microsecond = _ES$SubtractTime.microsecond;\n      nanosecond = _ES$SubtractTime.nanosecond;\n      duration.days -= deltaDays; // Delegate the date part subtraction to the calendar\n\n      var calendar = GetSlot(this, CALENDAR);\n      var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n      var datePart = new TemporalDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n      var addedDate = calendar.minus(datePart, duration, options, TemporalDate);\n      var year = GetSlot(addedDate, ISO_YEAR);\n      var month = GetSlot(addedDate, ISO_MONTH);\n      var day = GetSlot(addedDate, ISO_DAY);\n\n      if (disambiguation === 'constrain') {\n        // Special case to determine if the date was clipped by dateFromFields\n        // and therefore the time possibly needs to be clipped too\n        try {\n          calendar.minus(datePart, duration, {\n            disambiguation: 'reject'\n          }, TemporalDate);\n        } catch (_unused2) {\n          // Date was clipped\n          if (year === 275760 && month === 9 && day === 13) {\n            // Clipped at end of range\n            day += 1;\n          } else if (year === -271821 && month === 4 && day === 19) {\n            // Clipped at beginning of range\n            day -= 1;\n          }\n\n          var _ES$BalanceDate2 = ES.BalanceDate(year, month, day);\n\n          year = _ES$BalanceDate2.year;\n          month = _ES$BalanceDate2.month;\n          day = _ES$BalanceDate2.day;\n        }\n      }\n\n      var _ES$RegulateDateTimeR3 = ES.RegulateDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      year = _ES$RegulateDateTimeR3.year;\n      month = _ES$RegulateDateTimeR3.month;\n      day = _ES$RegulateDateTimeR3.day;\n      hour = _ES$RegulateDateTimeR3.hour;\n      minute = _ES$RegulateDateTimeR3.minute;\n      second = _ES$RegulateDateTimeR3.second;\n      millisecond = _ES$RegulateDateTimeR3.millisecond;\n      microsecond = _ES$RegulateDateTimeR3.microsecond;\n      nanosecond = _ES$RegulateDateTimeR3.nanosecond;\n      var Construct = ES.SpeciesConstructor(this, DateTime);\n      var result = new Construct(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n      if (!ES.IsTemporalDateTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(other, options) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalDateTime(other)) throw new TypeError('invalid DateTime object');\n      var calendar = GetSlot(this, CALENDAR);\n\n      if (calendar.id !== GetSlot(other, CALENDAR).id) {\n        other = new DateTime(GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, HOUR), GetSlot(other, MINUTE), GetSlot(other, SECOND), GetSlot(other, MILLISECOND), GetSlot(other, MICROSECOND), GetSlot(other, NANOSECOND), calendar);\n      }\n\n      var largestUnit = ES.ToLargestTemporalUnit(options, 'days');\n      var comparison = DateTime.compare(this, other);\n      if (comparison < 0) throw new RangeError('other instance cannot be larger than `this`');\n\n      var _ES$DifferenceTime = ES.DifferenceTime(other, this),\n          deltaDays = _ES$DifferenceTime.deltaDays,\n          hours = _ES$DifferenceTime.hours,\n          minutes = _ES$DifferenceTime.minutes,\n          seconds = _ES$DifferenceTime.seconds,\n          milliseconds = _ES$DifferenceTime.milliseconds,\n          microseconds = _ES$DifferenceTime.microseconds,\n          nanoseconds = _ES$DifferenceTime.nanoseconds;\n\n      var year = GetSlot(this, ISO_YEAR);\n      var month = GetSlot(this, ISO_MONTH);\n      var day = GetSlot(this, ISO_DAY) + deltaDays;\n\n      var _ES$BalanceDate3 = ES.BalanceDate(year, month, day);\n\n      year = _ES$BalanceDate3.year;\n      month = _ES$BalanceDate3.month;\n      day = _ES$BalanceDate3.day;\n      var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n      var adjustedLarger = new TemporalDate(year, month, day, GetSlot(this, CALENDAR));\n      var dateLargestUnit = 'days';\n\n      if (largestUnit === 'years' || largestUnit === 'months' || largestUnit === 'weeks') {\n        dateLargestUnit = largestUnit;\n      }\n\n      var dateOptions = ObjectAssign$2({}, options, {\n        largestUnit: dateLargestUnit\n      });\n      var dateDifference = calendar.difference(other, adjustedLarger, dateOptions);\n      var days;\n\n      var _ES$BalanceDuration3 = ES.BalanceDuration(dateDifference.days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit);\n\n      days = _ES$BalanceDuration3.days;\n      hours = _ES$BalanceDuration3.hours;\n      minutes = _ES$BalanceDuration3.minutes;\n      seconds = _ES$BalanceDuration3.seconds;\n      milliseconds = _ES$BalanceDuration3.milliseconds;\n      microseconds = _ES$BalanceDuration3.microseconds;\n      nanoseconds = _ES$BalanceDuration3.nanoseconds;\n      var Duration = GetIntrinsic$1('%Temporal.Duration%');\n      return new Duration(dateDifference.years, dateDifference.months, dateDifference.weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalDateTime(other)) throw new TypeError('invalid Date object');\n\n      for (var _i = 0, _arr = [ISO_YEAR, ISO_MONTH, ISO_DAY, HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND]; _i < _arr.length; _i++) {\n        var slot = _arr[_i];\n        var val1 = GetSlot(this, slot);\n        var val2 = GetSlot(other, slot);\n        if (val1 !== val2) return false;\n      }\n\n      return GetSlot(this, CALENDAR).id === GetSlot(other, CALENDAR).id;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var year = ES.ISOYearString(GetSlot(this, ISO_YEAR));\n      var month = ES.ISODateTimePartString(GetSlot(this, ISO_MONTH));\n      var day = ES.ISODateTimePartString(GetSlot(this, ISO_DAY));\n      var hour = ES.ISODateTimePartString(GetSlot(this, HOUR));\n      var minute = ES.ISODateTimePartString(GetSlot(this, MINUTE));\n      var second = ES.ISOSecondsString(GetSlot(this, SECOND), GetSlot(this, MILLISECOND), GetSlot(this, MICROSECOND), GetSlot(this, NANOSECOND));\n      var calendar = ES.FormatCalendarAnnotation(GetSlot(this, CALENDAR));\n      var resultString = \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute).concat(second ? \":\".concat(second) : '').concat(calendar);\n      return resultString;\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _construct(Intl.DateTimeFormat, args).format(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('use compare() or equals() to compare Temporal.DateTime');\n    }\n  }, {\n    key: \"inTimeZone\",\n    value: function inTimeZone(temporalTimeZoneLike, options) {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n      var timeZone = TemporalTimeZone.from(temporalTimeZoneLike);\n      var disambiguation = ES.ToTimeZoneTemporalDisambiguation(options);\n      if (typeof timeZone.getAbsoluteFor === 'function') return timeZone.getAbsoluteFor(this, {\n        disambiguation: disambiguation\n      });\n      return TemporalTimeZone.prototype.getAbsoluteFor.call(timeZone, this, {\n        disambiguation: disambiguation\n      });\n    }\n  }, {\n    key: \"getDate\",\n    value: function getDate() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var Date = GetIntrinsic$1('%Temporal.Date%');\n      return new Date(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, CALENDAR));\n    }\n  }, {\n    key: \"getYearMonth\",\n    value: function getYearMonth() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var YearMonth = GetIntrinsic$1('%Temporal.YearMonth%');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalDateTimeRecord(this);\n      return calendar.yearMonthFromFields(fields, {}, YearMonth);\n    }\n  }, {\n    key: \"getMonthDay\",\n    value: function getMonthDay() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var MonthDay = GetIntrinsic$1('%Temporal.MonthDay%');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalDateTimeRecord(this);\n      return calendar.monthDayFromFields(fields, {}, MonthDay);\n    }\n  }, {\n    key: \"getTime\",\n    value: function getTime() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      var Time = GetIntrinsic$1('%Temporal.Time%');\n      return new Time(GetSlot(this, HOUR), GetSlot(this, MINUTE), GetSlot(this, SECOND), GetSlot(this, MILLISECOND), GetSlot(this, MICROSECOND), GetSlot(this, NANOSECOND));\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = ES.ToTemporalDateTimeRecord(this);\n      if (!fields) throw new TypeError('invalid receiver');\n      fields.calendar = GetSlot(this, CALENDAR);\n      return fields;\n    }\n  }, {\n    key: \"getISOCalendarFields\",\n    value: function getISOCalendarFields() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return {\n        year: GetSlot(this, ISO_YEAR),\n        month: GetSlot(this, ISO_MONTH),\n        day: GetSlot(this, ISO_DAY),\n        hour: GetSlot(this, HOUR),\n        minute: GetSlot(this, MINUTE),\n        second: GetSlot(this, SECOND),\n        millisecond: GetSlot(this, MILLISECOND),\n        microsecond: GetSlot(this, MICROSECOND),\n        nanosecond: GetSlot(this, NANOSECOND)\n      };\n    }\n  }, {\n    key: \"year\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).year(this);\n    }\n  }, {\n    key: \"month\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).month(this);\n    }\n  }, {\n    key: \"day\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).day(this);\n    }\n  }, {\n    key: \"hour\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, HOUR);\n    }\n  }, {\n    key: \"minute\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MINUTE);\n    }\n  }, {\n    key: \"second\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, SECOND);\n    }\n  }, {\n    key: \"millisecond\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MILLISECOND);\n    }\n  }, {\n    key: \"microsecond\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MICROSECOND);\n    }\n  }, {\n    key: \"nanosecond\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, NANOSECOND);\n    }\n  }, {\n    key: \"calendar\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR);\n    }\n  }, {\n    key: \"era\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).era(this);\n    }\n  }, {\n    key: \"dayOfWeek\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).dayOfWeek(this);\n    }\n  }, {\n    key: \"dayOfYear\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).dayOfYear(this);\n    }\n  }, {\n    key: \"weekOfYear\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).weekOfYear(this);\n    }\n  }, {\n    key: \"daysInYear\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).daysInYear(this);\n    }\n  }, {\n    key: \"daysInMonth\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).daysInMonth(this);\n    }\n  }, {\n    key: \"isLeapYear\",\n    get: function get() {\n      if (!ES.IsTemporalDateTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).isLeapYear(this);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      var result;\n\n      if (_typeof(item) === 'object' && item) {\n        if (ES.IsTemporalDateTime(item)) {\n          var year = GetSlot(item, ISO_YEAR);\n          var month = GetSlot(item, ISO_MONTH);\n          var day = GetSlot(item, ISO_DAY);\n          var hour = GetSlot(item, HOUR);\n          var minute = GetSlot(item, MINUTE);\n          var second = GetSlot(item, SECOND);\n          var millisecond = GetSlot(item, MILLISECOND);\n          var microsecond = GetSlot(item, MICROSECOND);\n          var nanosecond = GetSlot(item, NANOSECOND);\n          var calendar = GetSlot(item, CALENDAR);\n          result = new this(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        } else {\n          var _calendar = item.calendar;\n          if (_calendar === undefined) _calendar = GetDefaultCalendar();\n          _calendar = TemporalCalendar.from(_calendar);\n          var fields = ES.ToTemporalDateTimeRecord(item);\n          var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n\n          var date = _calendar.dateFromFields(fields, options, TemporalDate);\n\n          var _year = GetSlot(date, ISO_YEAR);\n\n          var _month = GetSlot(date, ISO_MONTH);\n\n          var _day = GetSlot(date, ISO_DAY);\n\n          if (disambiguation === 'constrain') {\n            // Special case to determine if the date was clipped by dateFromFields\n            // and therefore the time possibly needs to be clipped too\n            try {\n              _calendar.dateFromFields(fields, {\n                disambiguation: 'reject'\n              }, TemporalDate);\n            } catch (_unused3) {\n              // Date was clipped\n              if (_year === 275760 && _month === 9 && _day === 13) {\n                // Clipped at end of range\n                _day += 1;\n              } else if (_year === -271821 && _month === 4 && _day === 19) {\n                // Clipped at beginning of range\n                _day -= 1;\n              }\n\n              var _ES$BalanceDate4 = ES.BalanceDate(_year, _month, _day);\n\n              _year = _ES$BalanceDate4.year;\n              _month = _ES$BalanceDate4.month;\n              _day = _ES$BalanceDate4.day;\n            }\n          }\n\n          var _hour = fields.hour,\n              _minute = fields.minute,\n              _second = fields.second,\n              _millisecond = fields.millisecond,\n              _microsecond = fields.microsecond,\n              _nanosecond = fields.nanosecond;\n\n          var _ES$RegulateTime2 = ES.RegulateTime(_hour, _minute, _second, _millisecond, _microsecond, _nanosecond, disambiguation);\n\n          _hour = _ES$RegulateTime2.hour;\n          _minute = _ES$RegulateTime2.minute;\n          _second = _ES$RegulateTime2.second;\n          _millisecond = _ES$RegulateTime2.millisecond;\n          _microsecond = _ES$RegulateTime2.microsecond;\n          _nanosecond = _ES$RegulateTime2.nanosecond;\n\n          var _ES$RegulateDateTimeR4 = ES.RegulateDateTimeRange(_year, _month, _day, _hour, _minute, _second, _millisecond, _microsecond, _nanosecond, disambiguation);\n\n          _year = _ES$RegulateDateTimeR4.year;\n          _month = _ES$RegulateDateTimeR4.month;\n          _day = _ES$RegulateDateTimeR4.day;\n          _hour = _ES$RegulateDateTimeR4.hour;\n          _minute = _ES$RegulateDateTimeR4.minute;\n          _second = _ES$RegulateDateTimeR4.second;\n          _millisecond = _ES$RegulateDateTimeR4.millisecond;\n          _microsecond = _ES$RegulateDateTimeR4.microsecond;\n          _nanosecond = _ES$RegulateDateTimeR4.nanosecond;\n          result = new this(_year, _month, _day, _hour, _minute, _second, _millisecond, _microsecond, _nanosecond, _calendar);\n        }\n      } else {\n        var _ES$ParseTemporalDate = ES.ParseTemporalDateTimeString(ES.ToString(item)),\n            _year2 = _ES$ParseTemporalDate.year,\n            _month2 = _ES$ParseTemporalDate.month,\n            _day2 = _ES$ParseTemporalDate.day,\n            _hour2 = _ES$ParseTemporalDate.hour,\n            _minute2 = _ES$ParseTemporalDate.minute,\n            _second2 = _ES$ParseTemporalDate.second,\n            _millisecond2 = _ES$ParseTemporalDate.millisecond,\n            _microsecond2 = _ES$ParseTemporalDate.microsecond,\n            _nanosecond2 = _ES$ParseTemporalDate.nanosecond,\n            _calendar2 = _ES$ParseTemporalDate.calendar;\n\n        var _ES$RegulateDateTimeR5 = ES.RegulateDateTimeRange(_year2, _month2, _day2, _hour2, _minute2, _second2, _millisecond2, _microsecond2, _nanosecond2, disambiguation);\n\n        _year2 = _ES$RegulateDateTimeR5.year;\n        _month2 = _ES$RegulateDateTimeR5.month;\n        _day2 = _ES$RegulateDateTimeR5.day;\n        _hour2 = _ES$RegulateDateTimeR5.hour;\n        _minute2 = _ES$RegulateDateTimeR5.minute;\n        _second2 = _ES$RegulateDateTimeR5.second;\n        _millisecond2 = _ES$RegulateDateTimeR5.millisecond;\n        _microsecond2 = _ES$RegulateDateTimeR5.microsecond;\n        _nanosecond2 = _ES$RegulateDateTimeR5.nanosecond;\n        if (!_calendar2) _calendar2 = GetDefaultCalendar();\n        _calendar2 = TemporalCalendar.from(_calendar2);\n        result = new this(_year2, _month2, _day2, _hour2, _minute2, _second2, _millisecond2, _microsecond2, _nanosecond2, _calendar2);\n      }\n\n      if (!ES.IsTemporalDateTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(one, two) {\n      if (!ES.IsTemporalDateTime(one) || !ES.IsTemporalDateTime(two)) throw new TypeError('invalid DateTime object');\n\n      for (var _i2 = 0, _arr2 = [ISO_YEAR, ISO_MONTH, ISO_DAY, HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND]; _i2 < _arr2.length; _i2++) {\n        var slot = _arr2[_i2];\n        var val1 = GetSlot(one, slot);\n        var val2 = GetSlot(two, slot);\n        if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n      }\n\n      var cal1 = GetSlot(one, CALENDAR).id;\n      var cal2 = GetSlot(two, CALENDAR).id;\n      return ES.ComparisonResult(cal1 < cal2 ? -1 : cal1 > cal2 ? 1 : 0);\n    }\n  }]);\n\n  return DateTime;\n}();\nDateTime.prototype.toJSON = DateTime.prototype.toString;\nMakeIntrinsicClass(DateTime, 'Temporal.DateTime');\n\nvar Duration = /*#__PURE__*/function () {\n  function Duration() {\n    var years = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var months = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var weeks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var days = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var hours = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var minutes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var seconds = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var milliseconds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var microseconds = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    var nanoseconds = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n\n    _classCallCheck(this, Duration);\n\n    years = ES.ToInteger(years);\n    months = ES.ToInteger(months);\n    weeks = ES.ToInteger(weeks);\n    days = ES.ToInteger(days);\n    hours = ES.ToInteger(hours);\n    minutes = ES.ToInteger(minutes);\n    seconds = ES.ToInteger(seconds);\n    milliseconds = ES.ToInteger(milliseconds);\n    microseconds = ES.ToInteger(microseconds);\n    nanoseconds = ES.ToInteger(nanoseconds);\n\n    for (var _i = 0, _arr = [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]; _i < _arr.length; _i++) {\n      var prop = _arr[_i];\n      if (prop < 0) throw new RangeError('negative values not allowed as duration fields');\n      if (!Number.isFinite(prop)) throw new RangeError('infinite values not allowed as duration fields');\n    }\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n  }\n\n  _createClass(Duration, [{\n    key: \"with\",\n    value: function _with(durationLike, options) {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToDurationTemporalDisambiguation(options);\n      var props = ES.ToPartialRecord(durationLike, ['days', 'hours', 'microseconds', 'milliseconds', 'minutes', 'months', 'nanoseconds', 'seconds', 'weeks', 'years']);\n\n      if (!props) {\n        throw new RangeError('invalid duration-like');\n      }\n\n      var _props$years = props.years,\n          years = _props$years === void 0 ? GetSlot(this, YEARS) : _props$years,\n          _props$months = props.months,\n          months = _props$months === void 0 ? GetSlot(this, MONTHS) : _props$months,\n          _props$weeks = props.weeks,\n          weeks = _props$weeks === void 0 ? GetSlot(this, WEEKS) : _props$weeks,\n          _props$days = props.days,\n          days = _props$days === void 0 ? GetSlot(this, DAYS) : _props$days,\n          _props$hours = props.hours,\n          hours = _props$hours === void 0 ? GetSlot(this, HOURS) : _props$hours,\n          _props$minutes = props.minutes,\n          minutes = _props$minutes === void 0 ? GetSlot(this, MINUTES) : _props$minutes,\n          _props$seconds = props.seconds,\n          seconds = _props$seconds === void 0 ? GetSlot(this, SECONDS) : _props$seconds,\n          _props$milliseconds = props.milliseconds,\n          milliseconds = _props$milliseconds === void 0 ? GetSlot(this, MILLISECONDS) : _props$milliseconds,\n          _props$microseconds = props.microseconds,\n          microseconds = _props$microseconds === void 0 ? GetSlot(this, MICROSECONDS) : _props$microseconds,\n          _props$nanoseconds = props.nanoseconds,\n          nanoseconds = _props$nanoseconds === void 0 ? GetSlot(this, NANOSECONDS) : _props$nanoseconds;\n\n      var _ES$RegulateDuration = ES.RegulateDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, disambiguation);\n\n      years = _ES$RegulateDuration.years;\n      months = _ES$RegulateDuration.months;\n      weeks = _ES$RegulateDuration.weeks;\n      days = _ES$RegulateDuration.days;\n      hours = _ES$RegulateDuration.hours;\n      minutes = _ES$RegulateDuration.minutes;\n      seconds = _ES$RegulateDuration.seconds;\n      milliseconds = _ES$RegulateDuration.milliseconds;\n      microseconds = _ES$RegulateDuration.microseconds;\n      nanoseconds = _ES$RegulateDuration.nanoseconds;\n      var Construct = ES.SpeciesConstructor(this, Duration);\n      var result = new Construct(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n      if (!ES.IsTemporalDuration(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(other, options) {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n\n      var _ES$ToLimitedTemporal = ES.ToLimitedTemporalDuration(other),\n          years = _ES$ToLimitedTemporal.years,\n          months = _ES$ToLimitedTemporal.months,\n          weeks = _ES$ToLimitedTemporal.weeks,\n          days = _ES$ToLimitedTemporal.days,\n          hours = _ES$ToLimitedTemporal.hours,\n          minutes = _ES$ToLimitedTemporal.minutes,\n          seconds = _ES$ToLimitedTemporal.seconds,\n          milliseconds = _ES$ToLimitedTemporal.milliseconds,\n          microseconds = _ES$ToLimitedTemporal.microseconds,\n          nanoseconds = _ES$ToLimitedTemporal.nanoseconds;\n\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n\n      var _ES$AddDuration = ES.AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, disambiguation);\n\n      years = _ES$AddDuration.years;\n      months = _ES$AddDuration.months;\n      weeks = _ES$AddDuration.weeks;\n      days = _ES$AddDuration.days;\n      hours = _ES$AddDuration.hours;\n      minutes = _ES$AddDuration.minutes;\n      seconds = _ES$AddDuration.seconds;\n      milliseconds = _ES$AddDuration.milliseconds;\n      microseconds = _ES$AddDuration.microseconds;\n      nanoseconds = _ES$AddDuration.nanoseconds;\n      var Construct = ES.SpeciesConstructor(this, Duration);\n      var result = new Construct(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n      if (!ES.IsTemporalDuration(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(other, options) {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n\n      var _ES$ToLimitedTemporal2 = ES.ToLimitedTemporalDuration(other),\n          years = _ES$ToLimitedTemporal2.years,\n          months = _ES$ToLimitedTemporal2.months,\n          weeks = _ES$ToLimitedTemporal2.weeks,\n          days = _ES$ToLimitedTemporal2.days,\n          hours = _ES$ToLimitedTemporal2.hours,\n          minutes = _ES$ToLimitedTemporal2.minutes,\n          seconds = _ES$ToLimitedTemporal2.seconds,\n          milliseconds = _ES$ToLimitedTemporal2.milliseconds,\n          microseconds = _ES$ToLimitedTemporal2.microseconds,\n          nanoseconds = _ES$ToLimitedTemporal2.nanoseconds;\n\n      var disambiguation = ES.ToDurationSubtractionTemporalDisambiguation(options);\n\n      var _ES$SubtractDuration = ES.SubtractDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, disambiguation);\n\n      years = _ES$SubtractDuration.years;\n      months = _ES$SubtractDuration.months;\n      weeks = _ES$SubtractDuration.weeks;\n      days = _ES$SubtractDuration.days;\n      hours = _ES$SubtractDuration.hours;\n      minutes = _ES$SubtractDuration.minutes;\n      seconds = _ES$SubtractDuration.seconds;\n      milliseconds = _ES$SubtractDuration.milliseconds;\n      microseconds = _ES$SubtractDuration.microseconds;\n      nanoseconds = _ES$SubtractDuration.nanoseconds;\n      var Construct = ES.SpeciesConstructor(this, Duration);\n      var result = new Construct(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n      if (!ES.IsTemporalDuration(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = ES.ToRecord(this, [['days'], ['hours'], ['microseconds'], ['milliseconds'], ['minutes'], ['months'], ['nanoseconds'], ['seconds'], ['weeks'], ['years']]);\n      if (!fields) throw new TypeError('invalid receiver');\n      return fields;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return ES.TemporalDurationToString(this);\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n\n      if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return _construct(Intl.DurationFormat, args).format(this);\n      }\n\n      console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n      return ES.TemporalDurationToString(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('not possible to compare Temporal.Duration');\n    }\n  }, {\n    key: \"years\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, YEARS);\n    }\n  }, {\n    key: \"months\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MONTHS);\n    }\n  }, {\n    key: \"weeks\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, WEEKS);\n    }\n  }, {\n    key: \"days\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, DAYS);\n    }\n  }, {\n    key: \"hours\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, HOURS);\n    }\n  }, {\n    key: \"minutes\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MINUTES);\n    }\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, SECONDS);\n    }\n  }, {\n    key: \"milliseconds\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MILLISECONDS);\n    }\n  }, {\n    key: \"microseconds\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MICROSECONDS);\n    }\n  }, {\n    key: \"nanoseconds\",\n    get: function get() {\n      if (!ES.IsTemporalDuration(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, NANOSECONDS);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var disambiguation = ES.ToDurationTemporalDisambiguation(options);\n      var years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n\n      if (_typeof(item) === 'object' && item) {\n        var _ES$ToTemporalDuratio = ES.ToTemporalDurationRecord(item);\n\n        years = _ES$ToTemporalDuratio.years;\n        months = _ES$ToTemporalDuratio.months;\n        weeks = _ES$ToTemporalDuratio.weeks;\n        days = _ES$ToTemporalDuratio.days;\n        hours = _ES$ToTemporalDuratio.hours;\n        minutes = _ES$ToTemporalDuratio.minutes;\n        seconds = _ES$ToTemporalDuratio.seconds;\n        milliseconds = _ES$ToTemporalDuratio.milliseconds;\n        microseconds = _ES$ToTemporalDuratio.microseconds;\n        nanoseconds = _ES$ToTemporalDuratio.nanoseconds;\n      } else {\n        var _ES$ParseTemporalDura = ES.ParseTemporalDurationString(ES.ToString(item));\n\n        years = _ES$ParseTemporalDura.years;\n        months = _ES$ParseTemporalDura.months;\n        weeks = _ES$ParseTemporalDura.weeks;\n        days = _ES$ParseTemporalDura.days;\n        hours = _ES$ParseTemporalDura.hours;\n        minutes = _ES$ParseTemporalDura.minutes;\n        seconds = _ES$ParseTemporalDura.seconds;\n        milliseconds = _ES$ParseTemporalDura.milliseconds;\n        microseconds = _ES$ParseTemporalDura.microseconds;\n        nanoseconds = _ES$ParseTemporalDura.nanoseconds;\n      }\n\n      var _ES$RegulateDuration2 = ES.RegulateDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, disambiguation);\n\n      years = _ES$RegulateDuration2.years;\n      months = _ES$RegulateDuration2.months;\n      weeks = _ES$RegulateDuration2.weeks;\n      days = _ES$RegulateDuration2.days;\n      hours = _ES$RegulateDuration2.hours;\n      minutes = _ES$RegulateDuration2.minutes;\n      seconds = _ES$RegulateDuration2.seconds;\n      milliseconds = _ES$RegulateDuration2.milliseconds;\n      microseconds = _ES$RegulateDuration2.microseconds;\n      nanoseconds = _ES$RegulateDuration2.nanoseconds;\n      var result = new this(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n      if (!ES.IsTemporalDuration(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }]);\n\n  return Duration;\n}();\nDuration.prototype.toJSON = Duration.prototype.toString;\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n\nvar ObjectAssign$3 = Object.assign;\nvar MonthDay = /*#__PURE__*/function () {\n  function MonthDay(isoMonth, isoDay) {\n    var calendar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var refISOYear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1972;\n\n    _classCallCheck(this, MonthDay);\n\n    isoMonth = ES.ToInteger(isoMonth);\n    isoDay = ES.ToInteger(isoDay);\n    if (calendar === undefined) calendar = GetDefaultCalendar();\n    refISOYear = ES.ToInteger(refISOYear);\n    ES.RejectDate(refISOYear, isoMonth, isoDay);\n    ES.RejectDateRange(refISOYear, isoMonth, isoDay);\n    if (!calendar || _typeof(calendar) !== 'object') throw new RangeError('invalid calendar');\n    CreateSlots(this);\n    SetSlot(this, ISO_MONTH, isoMonth);\n    SetSlot(this, ISO_DAY, isoDay);\n    SetSlot(this, REF_ISO_YEAR, refISOYear);\n    SetSlot(this, CALENDAR, calendar);\n  }\n\n  _createClass(MonthDay, [{\n    key: \"with\",\n    value: function _with(temporalMonthDayLike, options) {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n\n      if ('calendar' in temporalMonthDayLike) {\n        throw new RangeError('invalid calendar property in month-day-like');\n      }\n\n      var props = ES.ToPartialRecord(temporalMonthDayLike, ['day', 'month']);\n\n      if (!props) {\n        throw new RangeError('invalid month-day-like');\n      }\n\n      var fields = ES.ToTemporalMonthDayRecord(this);\n      ObjectAssign$3(fields, props);\n      var Construct = ES.SpeciesConstructor(this, MonthDay);\n      var result = GetSlot(this, CALENDAR).monthDayFromFields(fields, options, Construct);\n      if (!ES.IsTemporalMonthDay(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalMonthDay(other)) throw new TypeError('invalid MonthDay object');\n\n      for (var _i = 0, _arr = [ISO_MONTH, ISO_DAY, REF_ISO_YEAR]; _i < _arr.length; _i++) {\n        var slot = _arr[_i];\n        var val1 = GetSlot(this, slot);\n        var val2 = GetSlot(other, slot);\n        if (val1 !== val2) return false;\n      }\n\n      return GetSlot(this, CALENDAR).id === GetSlot(other, CALENDAR).id;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      var month = ES.ISODateTimePartString(GetSlot(this, ISO_MONTH));\n      var day = ES.ISODateTimePartString(GetSlot(this, ISO_DAY));\n      var resultString = \"\".concat(month, \"-\").concat(day);\n      var calendar = ES.FormatCalendarAnnotation(GetSlot(this, CALENDAR));\n\n      if (calendar) {\n        var year = ES.ISOYearString(GetSlot(this, REF_ISO_YEAR));\n        resultString = \"\".concat(year, \"-\").concat(resultString).concat(calendar);\n      }\n\n      return resultString;\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _construct(Intl.DateTimeFormat, args).format(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('use equals() to compare Temporal.MonthDay');\n    }\n  }, {\n    key: \"withYear\",\n    value: function withYear(item) {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      var era, year;\n\n      if (_typeof(item) === 'object' && item !== null) {\n        var _ES$ToRecord = ES.ToRecord(item, [['era', undefined], ['year']]);\n\n        era = _ES$ToRecord.era;\n        year = _ES$ToRecord.year;\n      } else {\n        year = ES.ToInteger(item);\n      }\n\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalMonthDayRecord(this);\n      var Date = GetIntrinsic$1('%Temporal.Date%');\n      return calendar.dateFromFields(_objectSpread2(_objectSpread2({}, fields), {}, {\n        era: era,\n        year: year\n      }), {\n        disambiguation: 'reject'\n      }, Date);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = ES.ToTemporalMonthDayRecord(this);\n      if (!fields) throw new TypeError('invalid receiver');\n      fields.calendar = GetSlot(this, CALENDAR);\n      return fields;\n    }\n  }, {\n    key: \"getISOCalendarFields\",\n    value: function getISOCalendarFields() {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      return {\n        year: GetSlot(this, REF_ISO_YEAR),\n        month: GetSlot(this, ISO_MONTH),\n        day: GetSlot(this, ISO_DAY)\n      };\n    }\n  }, {\n    key: \"month\",\n    get: function get() {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).month(this);\n    }\n  }, {\n    key: \"day\",\n    get: function get() {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).day(this);\n    }\n  }, {\n    key: \"calendar\",\n    get: function get() {\n      if (!ES.IsTemporalMonthDay(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      var result;\n\n      if (_typeof(item) === 'object' && item) {\n        if (ES.IsTemporalMonthDay(item)) {\n          var month = GetSlot(item, ISO_MONTH);\n          var day = GetSlot(item, ISO_DAY);\n          var calendar = GetSlot(item, CALENDAR);\n          var refISOYear = GetSlot(item, REF_ISO_YEAR);\n          result = new this(month, day, calendar, refISOYear);\n        } else {\n          var _calendar = item.calendar;\n          if (_calendar === undefined) _calendar = GetDefaultCalendar();\n          _calendar = TemporalCalendar.from(_calendar);\n          result = _calendar.monthDayFromFields(item, options, this);\n        }\n      } else {\n        var _ES$ParseTemporalMont = ES.ParseTemporalMonthDayString(ES.ToString(item)),\n            _month = _ES$ParseTemporalMont.month,\n            _day = _ES$ParseTemporalMont.day,\n            _refISOYear = _ES$ParseTemporalMont.refISOYear,\n            _calendar2 = _ES$ParseTemporalMont.calendar;\n\n        var _ES$RegulateMonthDay = ES.RegulateMonthDay(_month, _day, disambiguation);\n\n        _month = _ES$RegulateMonthDay.month;\n        _day = _ES$RegulateMonthDay.day;\n        if (!_calendar2) _calendar2 = GetDefaultCalendar();\n        _calendar2 = TemporalCalendar.from(_calendar2);\n        if (_refISOYear === undefined) _refISOYear = 1972;\n        result = new this(_month, _day, _calendar2, _refISOYear);\n      }\n\n      if (!ES.IsTemporalMonthDay(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }]);\n\n  return MonthDay;\n}();\nMonthDay.prototype.toJSON = MonthDay.prototype.toString;\nMakeIntrinsicClass(MonthDay, 'Temporal.MonthDay');\n\nvar now = {\n  absolute: absolute$1,\n  dateTime: dateTime,\n  date: date,\n  time: time$1,\n  timeZone: timeZone\n};\n\nfunction absolute$1() {\n  var Absolute = GetIntrinsic$1('%Temporal.Absolute%');\n  return new Absolute(ES.SystemUTCEpochNanoSeconds());\n}\n\nfunction dateTime() {\n  var temporalTimeZoneLike = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timeZone();\n  var calendar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  return function () {\n    var TemporalTimeZone = GetIntrinsic$1('%Temporal.TimeZone%');\n    var timeZone = TemporalTimeZone.from(temporalTimeZoneLike);\n    var abs = absolute$1();\n    if (typeof timeZone.getDateTimeFor === 'function') return timeZone.getDateTimeFor(abs, calendar);\n    return TemporalTimeZone.prototype.getDateTimeFor.call(timeZone, abs, calendar);\n  }();\n}\n\nfunction date(temporalTimeZoneLike) {\n  var calendar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  return dateTime(temporalTimeZoneLike, calendar).getDate();\n}\n\nfunction time$1(temporalTimeZoneLike) {\n  return dateTime(temporalTimeZoneLike).getTime();\n}\n\nfunction timeZone() {\n  return ES.SystemTimeZone();\n}\n\nvar Time = /*#__PURE__*/function () {\n  function Time() {\n    var hour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var minute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var second = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var millisecond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var microsecond = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var nanosecond = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Time);\n\n    hour = ES.ToInteger(hour);\n    minute = ES.ToInteger(minute);\n    second = ES.ToInteger(second);\n    millisecond = ES.ToInteger(millisecond);\n    microsecond = ES.ToInteger(microsecond);\n    nanosecond = ES.ToInteger(nanosecond);\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    CreateSlots(this);\n    SetSlot(this, HOUR, hour);\n    SetSlot(this, MINUTE, minute);\n    SetSlot(this, SECOND, second);\n    SetSlot(this, MILLISECOND, millisecond);\n    SetSlot(this, MICROSECOND, microsecond);\n    SetSlot(this, NANOSECOND, nanosecond);\n  }\n\n  _createClass(Time, [{\n    key: \"with\",\n    value: function _with() {\n      var temporalTimeLike = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var props = ES.ToPartialRecord(temporalTimeLike, ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second']);\n\n      if (!props) {\n        throw new RangeError('invalid time-like');\n      }\n\n      var _props$hour = props.hour,\n          hour = _props$hour === void 0 ? GetSlot(this, HOUR) : _props$hour,\n          _props$minute = props.minute,\n          minute = _props$minute === void 0 ? GetSlot(this, MINUTE) : _props$minute,\n          _props$second = props.second,\n          second = _props$second === void 0 ? GetSlot(this, SECOND) : _props$second,\n          _props$millisecond = props.millisecond,\n          millisecond = _props$millisecond === void 0 ? GetSlot(this, MILLISECOND) : _props$millisecond,\n          _props$microsecond = props.microsecond,\n          microsecond = _props$microsecond === void 0 ? GetSlot(this, MICROSECOND) : _props$microsecond,\n          _props$nanosecond = props.nanosecond,\n          nanosecond = _props$nanosecond === void 0 ? GetSlot(this, NANOSECOND) : _props$nanosecond;\n\n      var _ES$RegulateTime = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      hour = _ES$RegulateTime.hour;\n      minute = _ES$RegulateTime.minute;\n      second = _ES$RegulateTime.second;\n      millisecond = _ES$RegulateTime.millisecond;\n      microsecond = _ES$RegulateTime.microsecond;\n      nanosecond = _ES$RegulateTime.nanosecond;\n      var Construct = ES.SpeciesConstructor(this, Time);\n      var result = new Construct(hour, minute, second, millisecond, microsecond, nanosecond);\n      if (!ES.IsTemporalTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(temporalDurationLike, options) {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      var hour = this.hour,\n          minute = this.minute,\n          second = this.second,\n          millisecond = this.millisecond,\n          microsecond = this.microsecond,\n          nanosecond = this.nanosecond;\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var hours = duration.hours,\n          minutes = duration.minutes,\n          seconds = duration.seconds,\n          milliseconds = duration.milliseconds,\n          microseconds = duration.microseconds,\n          nanoseconds = duration.nanoseconds;\n\n      var _ES$AddTime = ES.AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n      hour = _ES$AddTime.hour;\n      minute = _ES$AddTime.minute;\n      second = _ES$AddTime.second;\n      millisecond = _ES$AddTime.millisecond;\n      microsecond = _ES$AddTime.microsecond;\n      nanosecond = _ES$AddTime.nanosecond;\n\n      var _ES$RegulateTime2 = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      hour = _ES$RegulateTime2.hour;\n      minute = _ES$RegulateTime2.minute;\n      second = _ES$RegulateTime2.second;\n      millisecond = _ES$RegulateTime2.millisecond;\n      microsecond = _ES$RegulateTime2.microsecond;\n      nanosecond = _ES$RegulateTime2.nanosecond;\n      var Construct = ES.SpeciesConstructor(this, Time);\n      var result = new Construct(hour, minute, second, millisecond, microsecond, nanosecond);\n      if (!ES.IsTemporalTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(temporalDurationLike, options) {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      var hour = this.hour,\n          minute = this.minute,\n          second = this.second,\n          millisecond = this.millisecond,\n          microsecond = this.microsecond,\n          nanosecond = this.nanosecond;\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var hours = duration.hours,\n          minutes = duration.minutes,\n          seconds = duration.seconds,\n          milliseconds = duration.milliseconds,\n          microseconds = duration.microseconds,\n          nanoseconds = duration.nanoseconds;\n\n      var _ES$SubtractTime = ES.SubtractTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n      hour = _ES$SubtractTime.hour;\n      minute = _ES$SubtractTime.minute;\n      second = _ES$SubtractTime.second;\n      millisecond = _ES$SubtractTime.millisecond;\n      microsecond = _ES$SubtractTime.microsecond;\n      nanosecond = _ES$SubtractTime.nanosecond;\n\n      var _ES$RegulateTime3 = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      hour = _ES$RegulateTime3.hour;\n      minute = _ES$RegulateTime3.minute;\n      second = _ES$RegulateTime3.second;\n      millisecond = _ES$RegulateTime3.millisecond;\n      microsecond = _ES$RegulateTime3.microsecond;\n      nanosecond = _ES$RegulateTime3.nanosecond;\n      var Construct = ES.SpeciesConstructor(this, Time);\n      var result = new Construct(hour, minute, second, millisecond, microsecond, nanosecond);\n      if (!ES.IsTemporalTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(other, options) {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalTime(other)) throw new TypeError('invalid Time object');\n      var largestUnit = ES.ToLargestTemporalUnit(options, 'hours');\n      var comparison = Time.compare(this, other);\n      if (comparison < 0) throw new RangeError('other instance cannot be larger than `this`');\n\n      var _ES$DifferenceTime = ES.DifferenceTime(other, this),\n          hours = _ES$DifferenceTime.hours,\n          minutes = _ES$DifferenceTime.minutes,\n          seconds = _ES$DifferenceTime.seconds,\n          milliseconds = _ES$DifferenceTime.milliseconds,\n          microseconds = _ES$DifferenceTime.microseconds,\n          nanoseconds = _ES$DifferenceTime.nanoseconds;\n\n      var _ES$BalanceDuration = ES.BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit);\n\n      hours = _ES$BalanceDuration.hours;\n      minutes = _ES$BalanceDuration.minutes;\n      seconds = _ES$BalanceDuration.seconds;\n      milliseconds = _ES$BalanceDuration.milliseconds;\n      microseconds = _ES$BalanceDuration.microseconds;\n      nanoseconds = _ES$BalanceDuration.nanoseconds;\n      var Duration = GetIntrinsic$1('%Temporal.Duration%');\n      return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalTime(other)) throw new TypeError('invalid Time object');\n\n      for (var _i = 0, _arr = [HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND]; _i < _arr.length; _i++) {\n        var slot = _arr[_i];\n        var val1 = GetSlot(this, slot);\n        var val2 = GetSlot(other, slot);\n        if (val1 !== val2) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      var hour = ES.ISODateTimePartString(GetSlot(this, HOUR));\n      var minute = ES.ISODateTimePartString(GetSlot(this, MINUTE));\n      var seconds = ES.ISOSecondsString(GetSlot(this, SECOND), GetSlot(this, MILLISECOND), GetSlot(this, MICROSECOND), GetSlot(this, NANOSECOND));\n      var resultString = \"\".concat(hour, \":\").concat(minute).concat(seconds ? \":\".concat(seconds) : '');\n      return resultString;\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _construct(Intl.DateTimeFormat, args).format(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('use compare() or equals() to compare Temporal.Time');\n    }\n  }, {\n    key: \"withDate\",\n    value: function withDate(temporalDate) {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalDate(temporalDate)) throw new TypeError('invalid Temporal.Date object');\n      var year = GetSlot(temporalDate, ISO_YEAR);\n      var month = GetSlot(temporalDate, ISO_MONTH);\n      var day = GetSlot(temporalDate, ISO_DAY);\n      var hour = GetSlot(this, HOUR);\n      var minute = GetSlot(this, MINUTE);\n      var second = GetSlot(this, SECOND);\n      var millisecond = GetSlot(this, MILLISECOND);\n      var microsecond = GetSlot(this, MICROSECOND);\n      var nanosecond = GetSlot(this, NANOSECOND);\n      var calendar = GetSlot(temporalDate, CALENDAR);\n      var DateTime = GetIntrinsic$1('%Temporal.DateTime%');\n      return new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = ES.ToTemporalTimeRecord(this);\n      if (!fields) throw new TypeError('invalid receiver');\n      return fields;\n    }\n  }, {\n    key: \"hour\",\n    get: function get() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, HOUR);\n    }\n  }, {\n    key: \"minute\",\n    get: function get() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MINUTE);\n    }\n  }, {\n    key: \"second\",\n    get: function get() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, SECOND);\n    }\n  }, {\n    key: \"millisecond\",\n    get: function get() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MILLISECOND);\n    }\n  }, {\n    key: \"microsecond\",\n    get: function get() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, MICROSECOND);\n    }\n  }, {\n    key: \"nanosecond\",\n    get: function get() {\n      if (!ES.IsTemporalTime(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, NANOSECOND);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var hour, minute, second, millisecond, microsecond, nanosecond;\n\n      if (_typeof(item) === 'object' && item) {\n        if (ES.IsTemporalTime(item)) {\n          minute = GetSlot(item, MINUTE);\n          second = GetSlot(item, SECOND);\n          millisecond = GetSlot(item, MILLISECOND);\n          microsecond = GetSlot(item, MICROSECOND);\n          nanosecond = GetSlot(item, NANOSECOND);\n        } else {\n          // Intentionally alphabetical\n          var _ES$ToTemporalTimeRec = ES.ToTemporalTimeRecord(item);\n\n          hour = _ES$ToTemporalTimeRec.hour;\n          minute = _ES$ToTemporalTimeRec.minute;\n          second = _ES$ToTemporalTimeRec.second;\n          millisecond = _ES$ToTemporalTimeRec.millisecond;\n          microsecond = _ES$ToTemporalTimeRec.microsecond;\n          nanosecond = _ES$ToTemporalTimeRec.nanosecond;\n        }\n      } else {\n        var _ES$ParseTemporalTime = ES.ParseTemporalTimeString(ES.ToString(item));\n\n        hour = _ES$ParseTemporalTime.hour;\n        minute = _ES$ParseTemporalTime.minute;\n        second = _ES$ParseTemporalTime.second;\n        millisecond = _ES$ParseTemporalTime.millisecond;\n        microsecond = _ES$ParseTemporalTime.microsecond;\n        nanosecond = _ES$ParseTemporalTime.nanosecond;\n      }\n\n      var _ES$RegulateTime4 = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, disambiguation);\n\n      hour = _ES$RegulateTime4.hour;\n      minute = _ES$RegulateTime4.minute;\n      second = _ES$RegulateTime4.second;\n      millisecond = _ES$RegulateTime4.millisecond;\n      microsecond = _ES$RegulateTime4.microsecond;\n      nanosecond = _ES$RegulateTime4.nanosecond;\n      var result = new this(hour, minute, second, millisecond, microsecond, nanosecond);\n      if (!ES.IsTemporalTime(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(one, two) {\n      if (!ES.IsTemporalTime(one) || !ES.IsTemporalTime(two)) throw new TypeError('invalid Time object');\n\n      for (var _i2 = 0, _arr2 = [HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, NANOSECOND]; _i2 < _arr2.length; _i2++) {\n        var slot = _arr2[_i2];\n        var val1 = GetSlot(one, slot);\n        var val2 = GetSlot(two, slot);\n        if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n      }\n\n      return ES.ComparisonResult(0);\n    }\n  }]);\n\n  return Time;\n}();\nTime.prototype.toJSON = Time.prototype.toString;\nMakeIntrinsicClass(Time, 'Temporal.Time');\n\nvar OFFSET$1 = new RegExp(\"^\".concat(offset.source, \"$\"));\n\nfunction parseOffsetString$1(string) {\n  var match = OFFSET$1.exec(String(string));\n  if (!match) return null;\n  var sign = match[1] === '-' ? -1 : +1;\n  var hours = +match[2];\n  var minutes = +(match[3] || 0);\n  return sign * (hours * 60 + minutes) * 60 * 1e9;\n}\n\nvar TimeZone = /*#__PURE__*/function () {\n  function TimeZone(timeZoneIdentifier) {\n    _classCallCheck(this, TimeZone);\n\n    if ((this instanceof TimeZone ? this.constructor : void 0) === TimeZone) {\n      timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifier);\n    }\n\n    CreateSlots(this);\n    SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n  }\n\n  _createClass(TimeZone, [{\n    key: \"getOffsetNanosecondsFor\",\n    value: function getOffsetNanosecondsFor(absolute) {\n      if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalAbsolute(absolute)) throw new TypeError('invalid Absolute object');\n      var id = GetSlot(this, TIMEZONE_ID);\n      var offsetNs = parseOffsetString$1(id);\n      if (offsetNs !== null) return offsetNs;\n      return ES.GetIANATimeZoneOffsetNanoseconds(GetSlot(absolute, EPOCHNANOSECONDS), id);\n    }\n  }, {\n    key: \"getOffsetStringFor\",\n    value: function getOffsetStringFor(absolute) {\n      var offsetNs = this.getOffsetNanosecondsFor(absolute);\n\n      if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n      }\n\n      if (!Number.isInteger(offsetNs) || Math.abs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n      }\n\n      return ES.FormatTimeZoneOffsetString(offsetNs);\n    }\n  }, {\n    key: \"getDateTimeFor\",\n    value: function getDateTimeFor(absolute) {\n      var calendar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'iso8601';\n      if (!ES.IsTemporalAbsolute(absolute)) throw new TypeError('invalid Absolute object');\n      var ns = GetSlot(absolute, EPOCHNANOSECONDS);\n      var offsetNs = this.getOffsetNanosecondsFor(absolute);\n\n      if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n      }\n\n      if (!Number.isInteger(offsetNs) || Math.abs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n      }\n\n      var _ES$GetPartsFromEpoch = ES.GetPartsFromEpoch(ns),\n          year = _ES$GetPartsFromEpoch.year,\n          month = _ES$GetPartsFromEpoch.month,\n          day = _ES$GetPartsFromEpoch.day,\n          hour = _ES$GetPartsFromEpoch.hour,\n          minute = _ES$GetPartsFromEpoch.minute,\n          second = _ES$GetPartsFromEpoch.second,\n          millisecond = _ES$GetPartsFromEpoch.millisecond,\n          microsecond = _ES$GetPartsFromEpoch.microsecond,\n          nanosecond = _ES$GetPartsFromEpoch.nanosecond;\n\n      var _ES$BalanceDateTime = ES.BalanceDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs);\n\n      year = _ES$BalanceDateTime.year;\n      month = _ES$BalanceDateTime.month;\n      day = _ES$BalanceDateTime.day;\n      hour = _ES$BalanceDateTime.hour;\n      minute = _ES$BalanceDateTime.minute;\n      second = _ES$BalanceDateTime.second;\n      millisecond = _ES$BalanceDateTime.millisecond;\n      microsecond = _ES$BalanceDateTime.microsecond;\n      nanosecond = _ES$BalanceDateTime.nanosecond;\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      calendar = TemporalCalendar.from(calendar);\n      var DateTime = GetIntrinsic$1('%Temporal.DateTime%');\n      return new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n  }, {\n    key: \"getAbsoluteFor\",\n    value: function getAbsoluteFor(dateTime, options) {\n      if (!ES.IsTemporalDateTime(dateTime)) throw new TypeError('invalid DateTime object');\n      var disambiguation = ES.ToTimeZoneTemporalDisambiguation(options);\n      var Absolute = GetIntrinsic$1('%Temporal.Absolute%');\n      var possibleAbsolutes = this.getPossibleAbsolutesFor(dateTime);\n\n      if (!Array.isArray(possibleAbsolutes)) {\n        throw new TypeError('bad return from getPossibleAbsolutesFor');\n      }\n\n      var numAbsolutes = possibleAbsolutes.length;\n\n      function validateAbsolute(absolute) {\n        if (!ES.IsTemporalAbsolute(absolute)) {\n          throw new TypeError('bad return from getPossibleAbsolutesFor');\n        }\n\n        return absolute;\n      }\n\n      if (numAbsolutes === 1) return validateAbsolute(possibleAbsolutes[0]);\n\n      if (numAbsolutes) {\n        switch (disambiguation) {\n          case 'compatible': // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n\n          case 'earlier':\n            return validateAbsolute(possibleAbsolutes[0]);\n\n          case 'later':\n            return validateAbsolute(possibleAbsolutes[numAbsolutes - 1]);\n\n          case 'reject':\n            {\n              throw new RangeError('multiple absolute found');\n            }\n        }\n      }\n\n      var utcns = ES.GetEpochFromParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, HOUR), GetSlot(dateTime, MINUTE), GetSlot(dateTime, SECOND), GetSlot(dateTime, MILLISECOND), GetSlot(dateTime, MICROSECOND), GetSlot(dateTime, NANOSECOND));\n      if (utcns === null) throw new RangeError('DateTime outside of supported range');\n      var dayBefore = new Absolute(utcns.minus(86400e9));\n      var dayAfter = new Absolute(utcns.plus(86400e9));\n      var offsetBefore = this.getOffsetNanosecondsFor(dayBefore);\n      var offsetAfter = this.getOffsetNanosecondsFor(dayAfter);\n      var nanoseconds = offsetAfter - offsetBefore;\n      var diff = ES.ToTemporalDurationRecord({\n        nanoseconds: nanoseconds\n      }, 'reject');\n\n      switch (disambiguation) {\n        case 'earlier':\n          {\n            var earlier = dateTime.minus(diff);\n            return this.getPossibleAbsolutesFor(earlier)[0];\n          }\n\n        case 'compatible': // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n\n        case 'later':\n          {\n            var later = dateTime.plus(diff);\n            var possible = this.getPossibleAbsolutesFor(later);\n            return possible[possible.length - 1];\n          }\n\n        case 'reject':\n          {\n            throw new RangeError('no such absolute found');\n          }\n      }\n    }\n  }, {\n    key: \"getPossibleAbsolutesFor\",\n    value: function getPossibleAbsolutesFor(dateTime) {\n      if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalDateTime(dateTime)) throw new TypeError('invalid DateTime object');\n      var Absolute = GetIntrinsic$1('%Temporal.Absolute%');\n      var id = GetSlot(this, TIMEZONE_ID);\n      var offsetNs = parseOffsetString$1(id);\n\n      if (offsetNs !== null) {\n        var epochNs = ES.GetEpochFromParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, HOUR), GetSlot(dateTime, MINUTE), GetSlot(dateTime, SECOND), GetSlot(dateTime, MILLISECOND), GetSlot(dateTime, MICROSECOND), GetSlot(dateTime, NANOSECOND));\n        return [new Absolute(epochNs.minus(offsetNs))];\n      }\n\n      var possibleEpochNs = ES.GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, HOUR), GetSlot(dateTime, MINUTE), GetSlot(dateTime, SECOND), GetSlot(dateTime, MILLISECOND), GetSlot(dateTime, MICROSECOND), GetSlot(dateTime, NANOSECOND));\n      return possibleEpochNs.map(function (ns) {\n        return new Absolute(ns);\n      });\n    }\n  }, {\n    key: \"getNextTransition\",\n    value: function getNextTransition(startingPoint) {\n      if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalAbsolute(startingPoint)) throw new TypeError('invalid Absolute object');\n      var id = GetSlot(this, TIMEZONE_ID); // Offset time zones or UTC have no transitions\n\n      if (parseOffsetString$1(id) !== null || id === 'UTC') {\n        return null;\n      }\n\n      var epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n      var Absolute = GetIntrinsic$1('%Temporal.Absolute%');\n      epochNanoseconds = ES.GetIANATimeZoneNextTransition(epochNanoseconds, id);\n      return epochNanoseconds === null ? null : new Absolute(epochNanoseconds);\n    }\n  }, {\n    key: \"getPreviousTransition\",\n    value: function getPreviousTransition(startingPoint) {\n      if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalAbsolute(startingPoint)) throw new TypeError('invalid Absolute object');\n      var id = GetSlot(this, TIMEZONE_ID); // Offset time zones or UTC have no transitions\n\n      if (parseOffsetString$1(id) !== null || id === 'UTC') {\n        return null;\n      }\n\n      var epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n      var Absolute = GetIntrinsic$1('%Temporal.Absolute%');\n      epochNanoseconds = ES.GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n      return epochNanoseconds === null ? null : new Absolute(epochNanoseconds);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n      return this.name;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      if (!ES.IsTemporalTimeZone(this)) throw new TypeError('invalid receiver');\n      return String(GetSlot(this, TIMEZONE_ID));\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      if (ES.IsTemporalTimeZone(item) || _typeof(item) === 'object' && item) return item;\n      var timeZone = ES.TemporalTimeZoneFromString(ES.ToString(item));\n      var result = new this(timeZone);\n      if (!ES.IsTemporalTimeZone(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }]);\n\n  return TimeZone;\n}();\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n\nvar ObjectAssign$4 = Object.assign;\nvar YearMonth = /*#__PURE__*/function () {\n  function YearMonth(isoYear, isoMonth) {\n    var calendar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var refISODay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    _classCallCheck(this, YearMonth);\n\n    isoYear = ES.ToInteger(isoYear);\n    isoMonth = ES.ToInteger(isoMonth);\n    if (calendar === undefined) calendar = GetDefaultCalendar();\n    refISODay = ES.ToInteger(refISODay);\n    ES.RejectDate(isoYear, isoMonth, refISODay);\n    ES.RejectYearMonthRange(isoYear, isoMonth);\n    if (!calendar || _typeof(calendar) !== 'object') throw new RangeError('invalid calendar');\n    CreateSlots(this);\n    SetSlot(this, ISO_YEAR, isoYear);\n    SetSlot(this, ISO_MONTH, isoMonth);\n    SetSlot(this, REF_ISO_DAY, refISODay);\n    SetSlot(this, CALENDAR, calendar);\n  }\n\n  _createClass(YearMonth, [{\n    key: \"with\",\n    value: function _with() {\n      var temporalYearMonthLike = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n\n      if ('calendar' in temporalYearMonthLike) {\n        throw new RangeError('invalid calendar property in year-month-like');\n      }\n\n      var props = ES.ToPartialRecord(temporalYearMonthLike, ['era', 'month', 'year']);\n\n      if (!props) {\n        throw new RangeError('invalid year-month-like');\n      }\n\n      var fields = ES.ToTemporalYearMonthRecord(this);\n      ObjectAssign$4(fields, props);\n      var Construct = ES.SpeciesConstructor(this, YearMonth);\n      var result = GetSlot(this, CALENDAR).yearMonthFromFields(fields, options, Construct);\n      if (!ES.IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(temporalDurationLike, options) {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var hours = duration.hours,\n          minutes = duration.minutes,\n          seconds = duration.seconds,\n          milliseconds = duration.milliseconds,\n          microseconds = duration.microseconds,\n          nanoseconds = duration.nanoseconds;\n\n      var _ES$BalanceDuration = ES.BalanceDuration(duration.days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days'),\n          days = _ES$BalanceDuration.days;\n\n      var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalYearMonthRecord(this);\n      var firstOfCalendarMonth = calendar.dateFromFields(_objectSpread2(_objectSpread2({}, fields), {}, {\n        day: 1\n      }), {}, TemporalDate);\n      var addedDate = calendar.plus(firstOfCalendarMonth, _objectSpread2(_objectSpread2({}, duration), {}, {\n        days: days\n      }), options, TemporalDate);\n      var Construct = ES.SpeciesConstructor(this, YearMonth);\n      var result = calendar.yearMonthFromFields(addedDate, options, Construct);\n      if (!ES.IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(temporalDurationLike, options) {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      var duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n      var hours = duration.hours,\n          minutes = duration.minutes,\n          seconds = duration.seconds,\n          milliseconds = duration.milliseconds,\n          microseconds = duration.microseconds,\n          nanoseconds = duration.nanoseconds;\n\n      var _ES$BalanceDuration2 = ES.BalanceDuration(duration.days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'days'),\n          days = _ES$BalanceDuration2.days;\n\n      var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalYearMonthRecord(this);\n      var lastDay = calendar.daysInMonth(this);\n      var lastOfCalendarMonth = calendar.dateFromFields(_objectSpread2(_objectSpread2({}, fields), {}, {\n        day: lastDay\n      }), {}, TemporalDate);\n      var subtractedDate = calendar.minus(lastOfCalendarMonth, _objectSpread2(_objectSpread2({}, duration), {}, {\n        days: days\n      }), options, TemporalDate);\n      var Construct = ES.SpeciesConstructor(this, YearMonth);\n      var result = calendar.yearMonthFromFields(subtractedDate, options, Construct);\n      if (!ES.IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(other, options) {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalYearMonth(other)) throw new TypeError('invalid YearMonth object');\n      var calendar = GetSlot(this, CALENDAR);\n\n      if (calendar.id !== GetSlot(other, CALENDAR).id) {\n        other = new Date(GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), calendar, GetSlot(other, REF_ISO_DAY));\n      }\n\n      var largestUnit = ES.ToLargestTemporalUnit(options, 'years', ['weeks', 'days', 'hours', 'minutes', 'seconds']);\n      var comparison = YearMonth.compare(this, other);\n      if (comparison < 0) throw new RangeError('other instance cannot be larger than `this`');\n      var smallerFields = ES.ToTemporalYearMonthRecord(other);\n      var largerFields = ES.ToTemporalYearMonthRecord(this);\n      var TemporalDate = GetIntrinsic$1('%Temporal.Date%');\n      var smaller = calendar.dateFromFields(_objectSpread2(_objectSpread2({}, smallerFields), {}, {\n        day: 1\n      }), {}, TemporalDate);\n      var larger = calendar.dateFromFields(_objectSpread2(_objectSpread2({}, largerFields), {}, {\n        day: 1\n      }), {}, TemporalDate);\n      return calendar.difference(smaller, larger, _objectSpread2(_objectSpread2({}, options), {}, {\n        largestUnit: largestUnit\n      }));\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      if (!ES.IsTemporalYearMonth(other)) throw new TypeError('invalid YearMonth object');\n\n      for (var _i = 0, _arr = [ISO_YEAR, ISO_MONTH, REF_ISO_DAY]; _i < _arr.length; _i++) {\n        var slot = _arr[_i];\n        var val1 = GetSlot(this, slot);\n        var val2 = GetSlot(other, slot);\n        if (val1 !== val2) return false;\n      }\n\n      return GetSlot(this, CALENDAR).id === GetSlot(other, CALENDAR).id;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      var year = ES.ISOYearString(GetSlot(this, ISO_YEAR));\n      var month = ES.ISODateTimePartString(GetSlot(this, ISO_MONTH));\n      var resultString = \"\".concat(year, \"-\").concat(month);\n      var calendar = ES.FormatCalendarAnnotation(GetSlot(this, CALENDAR));\n\n      if (calendar) {\n        var day = ES.ISODateTimePartString(GetSlot(this, REF_ISO_DAY));\n        resultString = \"\".concat(resultString, \"-\").concat(day).concat(calendar);\n      }\n\n      return resultString;\n    }\n  }, {\n    key: \"toLocaleString\",\n    value: function toLocaleString() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _construct(Intl.DateTimeFormat, args).format(this);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      throw new TypeError('use compare() or equals() to compare Temporal.YearMonth');\n    }\n  }, {\n    key: \"withDay\",\n    value: function withDay(day) {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      var calendar = GetSlot(this, CALENDAR);\n      var fields = ES.ToTemporalYearMonthRecord(this);\n      var Date = GetIntrinsic$1('%Temporal.Date%');\n      return calendar.dateFromFields(_objectSpread2(_objectSpread2({}, fields), {}, {\n        day: day\n      }), {\n        disambiguation: 'reject'\n      }, Date);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      var fields = ES.ToTemporalYearMonthRecord(this);\n      if (!fields) throw new TypeError('invalid receiver');\n      fields.calendar = GetSlot(this, CALENDAR);\n      return fields;\n    }\n  }, {\n    key: \"getISOCalendarFields\",\n    value: function getISOCalendarFields() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return {\n        year: GetSlot(this, ISO_YEAR),\n        month: GetSlot(this, ISO_MONTH),\n        day: GetSlot(this, REF_ISO_DAY)\n      };\n    }\n  }, {\n    key: \"year\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).year(this);\n    }\n  }, {\n    key: \"month\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).month(this);\n    }\n  }, {\n    key: \"calendar\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR);\n    }\n  }, {\n    key: \"era\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).era(this);\n    }\n  }, {\n    key: \"daysInMonth\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).daysInMonth(this);\n    }\n  }, {\n    key: \"daysInYear\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).daysInYear(this);\n    }\n  }, {\n    key: \"isLeapYear\",\n    get: function get() {\n      if (!ES.IsTemporalYearMonth(this)) throw new TypeError('invalid receiver');\n      return GetSlot(this, CALENDAR).isLeapYear(this);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var disambiguation = ES.ToTemporalDisambiguation(options);\n      var TemporalCalendar = GetIntrinsic$1('%Temporal.Calendar%');\n      var result;\n\n      if (_typeof(item) === 'object' && item) {\n        if (ES.IsTemporalYearMonth(item)) {\n          var year = GetSlot(item, ISO_YEAR);\n          var month = GetSlot(item, ISO_MONTH);\n          var calendar = GetSlot(item, CALENDAR);\n          var refISODay = GetSlot(item, REF_ISO_DAY);\n          result = new this(year, month, calendar, refISODay);\n        } else {\n          var _calendar = item.calendar;\n          if (_calendar === undefined) _calendar = GetDefaultCalendar();\n          _calendar = TemporalCalendar.from(_calendar);\n          result = _calendar.yearMonthFromFields(item, options, this);\n        }\n      } else {\n        var _ES$ParseTemporalYear = ES.ParseTemporalYearMonthString(ES.ToString(item)),\n            _year = _ES$ParseTemporalYear.year,\n            _month = _ES$ParseTemporalYear.month,\n            _refISODay = _ES$ParseTemporalYear.refISODay,\n            _calendar2 = _ES$ParseTemporalYear.calendar;\n\n        var _ES$RegulateYearMonth = ES.RegulateYearMonth(_year, _month, disambiguation);\n\n        _year = _ES$RegulateYearMonth.year;\n        _month = _ES$RegulateYearMonth.month;\n\n        var _ES$RegulateYearMonth2 = ES.RegulateYearMonthRange(_year, _month, disambiguation);\n\n        _year = _ES$RegulateYearMonth2.year;\n        _month = _ES$RegulateYearMonth2.month;\n        if (!_calendar2) _calendar2 = GetDefaultCalendar();\n        _calendar2 = TemporalCalendar.from(_calendar2);\n        if (_refISODay === undefined) _refISODay = 1;\n        result = new this(_year, _month, _calendar2, _refISODay);\n      }\n\n      if (!ES.IsTemporalYearMonth(result)) throw new TypeError('invalid result');\n      return result;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(one, two) {\n      if (!ES.IsTemporalYearMonth(one) || !ES.IsTemporalYearMonth(two)) throw new TypeError('invalid YearMonth object');\n\n      for (var _i2 = 0, _arr2 = [ISO_YEAR, ISO_MONTH, REF_ISO_DAY]; _i2 < _arr2.length; _i2++) {\n        var slot = _arr2[_i2];\n        var val1 = GetSlot(one, slot);\n        var val2 = GetSlot(two, slot);\n        if (val1 !== val2) return ES.ComparisonResult(val1 - val2);\n      }\n\n      var cal1 = GetSlot(one, CALENDAR).id;\n      var cal2 = GetSlot(two, CALENDAR).id;\n      return ES.ComparisonResult(cal1 < cal2 ? -1 : cal1 > cal2 ? 1 : 0);\n    }\n  }]);\n\n  return YearMonth;\n}();\nYearMonth.prototype.toJSON = YearMonth.prototype.toString;\nMakeIntrinsicClass(YearMonth, 'Temporal.YearMonth');\n\nvar Temporal = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Absolute: Absolute,\n  Calendar: Calendar,\n  Date: Date$1,\n  DateTime: DateTime,\n  Duration: Duration,\n  MonthDay: MonthDay,\n  now: now,\n  Time: Time,\n  TimeZone: TimeZone,\n  YearMonth: YearMonth\n});\n\nvar DATE = Symbol('date');\nvar YM = Symbol('ym');\nvar MD = Symbol('md');\nvar TIME = Symbol('time');\nvar DATETIME = Symbol('datetime');\nvar ORIGINAL = Symbol('original');\nvar TIMEZONE = Symbol('timezone');\n\nvar descriptor = function descriptor(value) {\n  return {\n    value: value,\n    enumerable: true,\n    writable: false,\n    configurable: true\n  };\n};\n\nvar IntlDateTimeFormat$1 = Intl.DateTimeFormat;\nvar ObjectAssign$5 = Object.assign;\nfunction DateTimeFormat() {\n  var locale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : IntlDateTimeFormat$1().resolvedOptions().locale;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!(this instanceof DateTimeFormat)) return new DateTimeFormat(locale, options);\n  this[ORIGINAL] = new IntlDateTimeFormat$1(locale, options);\n  this[TIMEZONE] = new TimeZone(this.resolvedOptions().timeZone);\n  this[DATE] = new IntlDateTimeFormat$1(locale, dateAmend(options));\n  this[YM] = new IntlDateTimeFormat$1(locale, yearMonthAmend(options));\n  this[MD] = new IntlDateTimeFormat$1(locale, monthDayAmend(options));\n  this[TIME] = new IntlDateTimeFormat$1(locale, timeAmend(options));\n  this[DATETIME] = new IntlDateTimeFormat$1(locale, datetimeAmend(options));\n}\n\nDateTimeFormat.supportedLocalesOf = function () {\n  return IntlDateTimeFormat$1.supportedLocalesOf.apply(IntlDateTimeFormat$1, arguments);\n};\n\nvar properties = {\n  resolvedOptions: descriptor(resolvedOptions),\n  format: descriptor(format),\n  formatRange: descriptor(formatRange)\n};\n\nif ('formatToParts' in IntlDateTimeFormat$1.prototype) {\n  properties.formatToParts = descriptor(formatToParts);\n}\n\nif ('formatRangeToParts' in IntlDateTimeFormat$1.prototype) {\n  properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\n\nDateTimeFormat.prototype = Object.create(IntlDateTimeFormat$1.prototype, properties);\n\nfunction resolvedOptions() {\n  return this[ORIGINAL].resolvedOptions();\n}\n\nfunction adjustFormatterCalendar(formatter, calendar) {\n  var options = formatter.resolvedOptions();\n  if (!calendar || calendar === options.calendar || calendar === 'gregory' || calendar === 'iso8601') return formatter;\n  var locale = \"\".concat(options.locale, \"-u-ca-\").concat(calendar);\n  return new IntlDateTimeFormat$1(locale, options);\n}\n\nfunction pickRangeCalendar(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  if (a === b) return a;\n  if (a === 'iso8601' || a === 'gregory') return b;\n  if (b === 'iso8601' || b === 'gregory') return a;\n  throw new RangeError(\"cannot format range between two dates of \".concat(a, \" and \").concat(b, \" calendars\"));\n}\n\nfunction format(datetime) {\n  var _this$ORIGINAL;\n\n  var _extractOverrides = extractOverrides(datetime, this),\n      absolute = _extractOverrides.absolute,\n      formatter = _extractOverrides.formatter,\n      calendar = _extractOverrides.calendar;\n\n  if (absolute && formatter) {\n    return adjustFormatterCalendar(formatter, calendar).format(absolute.getEpochMilliseconds());\n  }\n\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n\n  return (_this$ORIGINAL = this[ORIGINAL]).format.apply(_this$ORIGINAL, [datetime].concat(rest));\n}\n\nfunction formatToParts(datetime) {\n  var _this$ORIGINAL2;\n\n  var _extractOverrides2 = extractOverrides(datetime, this),\n      absolute = _extractOverrides2.absolute,\n      formatter = _extractOverrides2.formatter,\n      calendar = _extractOverrides2.calendar;\n\n  if (absolute && formatter) {\n    return adjustFormatterCalendar(formatter, calendar).formatToParts(absolute.getEpochMilliseconds());\n  }\n\n  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    rest[_key2 - 1] = arguments[_key2];\n  }\n\n  return (_this$ORIGINAL2 = this[ORIGINAL]).formatToParts.apply(_this$ORIGINAL2, [datetime].concat(rest));\n}\n\nfunction formatRange(a, b) {\n  if ('object' === _typeof(a) && 'object' === _typeof(b) && a && b) {\n    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n      throw new TypeError('Intl.DateTimeFormat accepts two values of the same type');\n    }\n\n    var _extractOverrides3 = extractOverrides(a, this),\n        aa = _extractOverrides3.absolute,\n        aformatter = _extractOverrides3.formatter,\n        acalendar = _extractOverrides3.calendar;\n\n    var _extractOverrides4 = extractOverrides(b, this),\n        bb = _extractOverrides4.absolute,\n        bformatter = _extractOverrides4.formatter,\n        bcalendar = _extractOverrides4.calendar;\n\n    var calendar = pickRangeCalendar(acalendar, bcalendar);\n\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      var formatter = adjustFormatterCalendar(aformatter, calendar);\n      return formatter.formatRange(aa.getEpochMilliseconds(), bb.getEpochMilliseconds());\n    }\n  }\n\n  return this[ORIGINAL].formatRange(a, b);\n}\n\nfunction formatRangeToParts(a, b) {\n  if ('object' === _typeof(a) && 'object' === _typeof(b) && a && b) {\n    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n      throw new TypeError('Intl.DateTimeFormat accepts two values of the same type');\n    }\n\n    var _extractOverrides5 = extractOverrides(a, this),\n        aa = _extractOverrides5.absolute,\n        aformatter = _extractOverrides5.formatter,\n        acalendar = _extractOverrides5.calendar;\n\n    var _extractOverrides6 = extractOverrides(b, this),\n        bb = _extractOverrides6.absolute,\n        bformatter = _extractOverrides6.formatter,\n        bcalendar = _extractOverrides6.calendar;\n\n    var calendar = pickRangeCalendar(acalendar, bcalendar);\n\n    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n      var formatter = adjustFormatterCalendar(aformatter, calendar);\n      return formatter.formatRangeToParts(aa.getEpochMilliseconds(), bb.getEpochMilliseconds());\n    }\n  }\n\n  return this[ORIGINAL].formatRangeToParts(a, b);\n}\n\nfunction amend() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var amended = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = ObjectAssign$5({}, options);\n\n  for (var _i = 0, _arr = ['year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName']; _i < _arr.length; _i++) {\n    var opt = _arr[_i];\n    options[opt] = opt in amended ? amended[opt] : options[opt];\n    if (options[opt] === false || options[opt] === undefined) delete options[opt];\n  }\n\n  return options;\n}\n\nfunction timeAmend(options) {\n  options = amend(options, {\n    year: false,\n    month: false,\n    day: false,\n    timeZoneName: false\n  });\n\n  if (!hasTimeOptions(options)) {\n    options = ObjectAssign$5(options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction yearMonthAmend(options) {\n  options = amend(options, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    timeZoneName: false\n  });\n\n  if (!('year' in options || 'month' in options)) {\n    options = ObjectAssign$5(options, {\n      year: 'numeric',\n      month: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction monthDayAmend(options) {\n  options = amend(options, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    timeZoneName: false\n  });\n\n  if (!('month' in options || 'day' in options)) {\n    options = ObjectAssign$5(options, {\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction dateAmend(options) {\n  options = amend(options, {\n    hour: false,\n    minute: false,\n    second: false,\n    timeZoneName: false\n  });\n\n  if (!hasDateOptions(options)) {\n    options = ObjectAssign$5(options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction datetimeAmend(options) {\n  options = amend(options, {\n    timeZoneName: false\n  });\n\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    ObjectAssign$5(options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n\n  return options;\n}\n\nfunction hasDateOptions(options) {\n  return 'year' in options || 'month' in options || 'day' in options;\n}\n\nfunction hasTimeOptions(options) {\n  return 'hour' in options || 'minute' in options || 'second' in options;\n}\n\nfunction extractOverrides(datetime, main) {\n  var formatter, calendar;\n  var Absolute = GetIntrinsic$1('%Temporal.Absolute%');\n  var Date = GetIntrinsic$1('%Temporal.Date%');\n  var DateTime = GetIntrinsic$1('%Temporal.DateTime%');\n  var MonthDay = GetIntrinsic$1('%Temporal.MonthDay%');\n  var Time = GetIntrinsic$1('%Temporal.Time%');\n  var YearMonth = GetIntrinsic$1('%Temporal.YearMonth%');\n\n  if (datetime instanceof Time) {\n    datetime = datetime.withDate(new Date(1970, 1, 1));\n    formatter = main[TIME];\n  }\n\n  if (datetime instanceof YearMonth) {\n    calendar = datetime.calendar.id;\n\n    var _datetime$getISOCalen = datetime.getISOCalendarFields(),\n        year = _datetime$getISOCalen.year,\n        month = _datetime$getISOCalen.month,\n        day = _datetime$getISOCalen.day;\n\n    datetime = new Date(year, month, day, datetime.calendar);\n    formatter = main[YM];\n  }\n\n  if (datetime instanceof MonthDay) {\n    calendar = datetime.calendar.id;\n\n    var _datetime$getISOCalen2 = datetime.getISOCalendarFields(),\n        _year = _datetime$getISOCalen2.year,\n        _month = _datetime$getISOCalen2.month,\n        _day = _datetime$getISOCalen2.day;\n\n    datetime = new Date(_year, _month, _day, datetime.calendar);\n    formatter = main[MD];\n  }\n\n  if (datetime instanceof Date) {\n    calendar = calendar || datetime.calendar.id;\n    datetime = datetime.withTime(new Time(12, 0));\n    formatter = formatter || main[DATE];\n  }\n\n  if (datetime instanceof DateTime) {\n    calendar = calendar || datetime.calendar.id;\n    formatter = formatter || main[DATETIME];\n    datetime = main[TIMEZONE].getAbsoluteFor(datetime);\n  }\n\n  if (datetime instanceof Absolute) {\n    formatter = formatter || main[DATETIME];\n    return {\n      absolute: datetime,\n      formatter: formatter,\n      calendar: calendar\n    };\n  } else {\n    return {};\n  }\n}\n\nvar Intl$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  DateTimeFormat: DateTimeFormat\n});\n\nObject.defineProperty(globalThis, 'Temporal', {\n  value: {},\n  writable: true,\n  enumerable: false,\n  configurable: true\n});\ncopy(globalThis.Temporal, Temporal);\ncopy(globalThis.Intl, Intl$1);\n\nfunction copy(target, source) {\n  var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(source)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var prop = _step.value;\n      Object.defineProperty(target, prop, {\n        value: source[prop],\n        writable: true,\n        enumerable: false,\n        configurable: true\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nexports.Intl = Intl$1;\nexports.Temporal = Temporal;\n//# sourceMappingURL=index.js.map\n","import { Temporal } from 'proposal-temporal'\n\n/**\n * \n * @param {Temporal.Duration} duration \n */\nfunction temporal_duration_to_human (duration) {\n    window.last_duration = duration\n    let result = []\n    const daysRequired = (!duration.hours && !duration.minutes)\n    const hoursRequired = (!duration.days && !duration.minutes)\n    const minutesRequired = (!duration.days && !duration.hours)\n    if (!duration.days && daysRequired) {\n        return 'now'\n    }\n    if (!!duration.days || daysRequired) {\n        const plural_day = duration.days != 1 ? \"s\" : \"\"\n        result.push(`${duration.days} day${plural_day}`)\n    }\n    if (!!duration.hours || hoursRequired) {\n        const plural_hour = duration.hours != 1 ? \"s\" : \"\"\n        result.push(`${duration.hours} hour${plural_hour}`)\n    }\n    if (!!duration.minutes || minutesRequired) {\n        const plural_minute = duration.minutes != 1 ? \"s\" : \"\"\n        result.push(`${duration.minutes} minute${plural_minute}`)\n    }\n    if (result.length > 1) {\n        const last = result.pop()\n        return `${result.join(', ')} and ${last}`\n    }\n    return result[0]\n}\n\nfunction add_relative_time (domNode) {\n    const start = Temporal.Absolute.from(domNode.dataset.start)\n    const end = Temporal.Absolute.from(domNode.dataset.end)\n    const preStart = domNode.dataset.preStartText\n    const preEnd = domNode.dataset.preEndText\n    const postEnd = domNode.dataset.postEndText\n    const now = Temporal.now.absolute()\n\n    if(Temporal.Absolute.compare(now, start) < 0) {\n        // Hasn't started yet\n        const diff = start.difference(now, {largestUnit: 'days'})\n        domNode.innerHTML = preStart.replace('DURATION', temporal_duration_to_human(diff))\n    } else if (Temporal.Absolute.compare(now, end) < 0) {\n        // Has started already but hasn't ended\n        const diff = now.difference(start, {largestUnit: 'days'})\n        domNode.innerHTML = preEnd.replace('DURATION', temporal_duration_to_human(diff))\n    } else {\n        // Has ended\n        const diff = now.difference(end, {largestUnit: 'days'})\n        domNode.innerHTML = postEnd.replace('DURATION', temporal_duration_to_human(diff))\n    }\n}\n\nfunction update_all_relative_times () {\n    Array.from(document.querySelectorAll(\".relative-when\")).forEach(node => {\n        add_relative_time(node)\n    })\n}\n\nexport function relativeTime () {\n    window.update_all_relative_times = update_all_relative_times\n    \n    document.addEventListener(\"DOMContentLoaded\", update_all_relative_times);\n    setInterval(update_all_relative_times, 30000);\n}\n","import { relativeTime } from './relativeTime'\n\nexport function automatic () {\n  relativeTime()\n}\n","import { Temporal } from 'proposal-temporal'\nimport talks from '../content/_data/2020/talks.json'\nimport findLastIndex from 'lodash.findlastindex'\nsortTalks(talks)\n\nfunction sortTalks (talks) {\n  talks.sort((a, b) => {\n    return a.slot.start < b.slot.start\n  })\n  return talks\n}\n\nfunction currentTalkIndex (now) {\n  return talks.findIndex(e => {\n    const dt = Temporal.Absolute.from(e.slot.start)\n    return Temporal.Absolute.compare(dt, now) >= 0\n  })\n}\n\nfunction displayForTime(now) {\n  console.log(\"----- TIME: \", now.toString())\n  const currentIndex = currentTalkIndex(talks, now)\n  console.log(\"Current talk\", currentIndex, talks[currentIndex])\n}\n\nfunction getRenderState (time) {\n  findLastIndex(talks, e => {\n    const end = Temporal.Absolute.from(e.slot.end)\n    return Temporal.Absolute.compare(end, now) < 0\n  })\n\n  const previousTalk = null || {}\n  const currentTalk = null || {}\n  const nextTalk = null || {}\n  const isInBreak = previousTalk !== null && currentTalk == null && nextTalk !== null\n  const isAfterEvent = currentTalk == null && nextTalk == null\n  const isBeforeEvent = previousTalk === null && currentTalk == null\n  return {\n    isBeforeEvent,\n    previousTalk,\n    currentTalk,\n    nextTalk,\n    isInBreak,\n    isAfterEvent\n  }\n}\n\n\nconst timeBeforeEvent = Temporal.Absolute.from(\"2020-07-30T16:20:00+02:00\")\nconst timeDuringFirstSession = Temporal.Absolute.from(\"2020-07-30T17:01:00+02:00\")\nconst timeBetweenFirstAndSecondSession = Temporal.Absolute.from(\"2020-07-30T18:05:00+02:00\")\nconst timeDuringSecondSession = Temporal.Absolute.from(\"2020-07-30T18:16:00+02:00\")\nconst timeAfterEvent = Temporal.Absolute.from(\"2020-07-31T23:25:00+02:00\")\n\nexport function live () {\n  const output = document.getElementById('output')\n\n  const beforeEvent = getRenderState(timeBeforeEvent)\n  const duringFirstSession = getRenderState(timeDuringFirstSession)\n  const betweenFirstAndSecondSession = getRenderState(timeBetweenFirstAndSecondSession)\n  const duringSecondSession = getRenderState(timeDuringSecondSession)\n  const afterEvent = getRenderState(timeAfterEvent)\n\n  setInterval(() => {\n    output.innerHTML = `\n      ${new Date().toLocaleString()}\n    `\n  }, 80)\n}\n"],"names":["temporal_duration_to_human","duration","window","last_duration","result","daysRequired","hours","minutes","hoursRequired","days","minutesRequired","plural_day","push","plural_hour","plural_minute","length","last","pop","join","add_relative_time","domNode","start","Temporal","Absolute","from","dataset","end","preStart","preStartText","preEnd","preEndText","postEnd","postEndText","now","absolute","compare","diff","difference","largestUnit","innerHTML","replace","update_all_relative_times","Array","document","querySelectorAll","forEach","node","relativeTime","addEventListener","setInterval","automatic","sortTalks","talks","sort","a","b","slot","getRenderState","time","findLastIndex","e","previousTalk","currentTalk","nextTalk","isInBreak","isAfterEvent","isBeforeEvent","timeBeforeEvent","timeDuringFirstSession","timeBetweenFirstAndSecondSession","timeDuringSecondSession","timeAfterEvent","live","output","getElementById","beforeEvent","duringFirstSession","betweenFirstAndSecondSession","duringSecondSession","afterEvent","Date","toLocaleString"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;;;AACA,MAAA,KAAA,GAAA,SAAA,UAAA,GAAA;;;;;;;;;;AAKA,QAAA,GAAA,GAAA,MAAA,CAAA,MAAA,CAAA;;;QAEK,UAAA;;;;AAEL,QAAA,MAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,GAAA,MAAA,iBAAA,EAAA;AAAA,aAAA,KAAA;AAAA;;AACA,QAAA,MAAA,CAAA,SAAA,CAAA,QAAA,CAAA,IAAA,CAAA,MAAA,MAAA,iBAAA,EAAA;AAAA,aAAA,KAAA;AAAA,KAVA;AAaA;AACA;AACA;;;;;;AAMA,IAAA,GAAA,CAAA,GAAA,CAAA,GAAA,MAAA;;;;KArBA;;;AAuBA,QAAA,OAAA,MAAA,CAAA,IAAA,KAAA,UAAA,IAAA,MAAA,CAAA,IAAA,CAAA,GAAA,EAAA,MAAA,KAAA,CAAA,EAAA;AAAA,aAAA,KAAA;AAAA;;;;;;;;AAKA,QAAA,IAAA,CAAA,MAAA,KAAA,CAAA,IAAA,IAAA,CAAA,CAAA,CAAA,KAAA,GAAA,EAAA;AAAA,aAAA,KAAA;AAAA;;AAEA,6DAAA;;;;AAEA,6DAAA;AACA,UAAA,UAAA,GAAA,MAAA,CAAA,wBAAA,CAAA,GAAA,EAAA,GAAA,CAAA;;;;;;;;GAjCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDCDA;;;;;AAIA,SAASA,0BAAT,CAAqCC,QAArC,EAA+C;AAC3CC,EAAAA,MAAM,CAACC,aAAP,GAAuBF,QAAvB;AACA,MAAIG,MAAM,GAAG,EAAb;AACA,QAAMC,YAAY,GAAI,CAACJ,QAAQ,CAACK,KAAV,IAAmB,CAACL,QAAQ,CAACM,OAAnD;AACA,QAAMC,aAAa,GAAI,CAACP,QAAQ,CAACQ,IAAV,IAAkB,CAACR,QAAQ,CAACM,OAAnD;AACA,QAAMG,eAAe,GAAI,CAACT,QAAQ,CAACQ,IAAV,IAAkB,CAACR,QAAQ,CAACK,KAArD;;AACA,MAAI,CAACL,QAAQ,CAACQ,IAAV,IAAkBJ,YAAtB,EAAoC;AAChC,WAAO,KAAP;AACH;;AACD,MAAI,CAAC,CAACJ,QAAQ,CAACQ,IAAX,IAAmBJ,YAAvB,EAAqC;AACjC,UAAMM,UAAU,GAAGV,QAAQ,CAACQ,IAAT,IAAiB,CAAjB,GAAqB,GAArB,GAA2B,EAA9C;AACAL,IAAAA,MAAM,CAACQ,IAAP,CAAa,GAAEX,QAAQ,CAACQ,IAAK,OAAME,UAAW,EAA9C;AACH;;AACD,MAAI,CAAC,CAACV,QAAQ,CAACK,KAAX,IAAoBE,aAAxB,EAAuC;AACnC,UAAMK,WAAW,GAAGZ,QAAQ,CAACK,KAAT,IAAkB,CAAlB,GAAsB,GAAtB,GAA4B,EAAhD;AACAF,IAAAA,MAAM,CAACQ,IAAP,CAAa,GAAEX,QAAQ,CAACK,KAAM,QAAOO,WAAY,EAAjD;AACH;;AACD,MAAI,CAAC,CAACZ,QAAQ,CAACM,OAAX,IAAsBG,eAA1B,EAA2C;AACvC,UAAMI,aAAa,GAAGb,QAAQ,CAACM,OAAT,IAAoB,CAApB,GAAwB,GAAxB,GAA8B,EAApD;AACAH,IAAAA,MAAM,CAACQ,IAAP,CAAa,GAAEX,QAAQ,CAACM,OAAQ,UAASO,aAAc,EAAvD;AACH;;AACD,MAAIV,MAAM,CAACW,MAAP,GAAgB,CAApB,EAAuB;AACnB,UAAMC,IAAI,GAAGZ,MAAM,CAACa,GAAP,EAAb;AACA,WAAQ,GAAEb,MAAM,CAACc,IAAP,CAAY,IAAZ,CAAkB,QAAOF,IAAK,EAAxC;AACH;;AACD,SAAOZ,MAAM,CAAC,CAAD,CAAb;AACH;;AAED,SAASe,iBAAT,CAA4BC,OAA5B,EAAqC;AACjC,QAAMC,KAAK,GAAGC,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuBJ,OAAO,CAACK,OAAR,CAAgBJ,KAAvC,CAAd;AACA,QAAMK,GAAG,GAAGJ,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuBJ,OAAO,CAACK,OAAR,CAAgBC,GAAvC,CAAZ;AACA,QAAMC,QAAQ,GAAGP,OAAO,CAACK,OAAR,CAAgBG,YAAjC;AACA,QAAMC,MAAM,GAAGT,OAAO,CAACK,OAAR,CAAgBK,UAA/B;AACA,QAAMC,OAAO,GAAGX,OAAO,CAACK,OAAR,CAAgBO,WAAhC;AACA,QAAMC,GAAG,GAAGX,cAAQ,CAACW,GAAT,CAAaC,QAAb,EAAZ;;AAEA,MAAGZ,cAAQ,CAACC,QAAT,CAAkBY,OAAlB,CAA0BF,GAA1B,EAA+BZ,KAA/B,IAAwC,CAA3C,EAA8C;AAC1C;AACA,UAAMe,IAAI,GAAGf,KAAK,CAACgB,UAAN,CAAiBJ,GAAjB,EAAsB;AAACK,MAAAA,WAAW,EAAE;AAAd,KAAtB,CAAb;AACAlB,IAAAA,OAAO,CAACmB,SAAR,GAAoBZ,QAAQ,CAACa,OAAT,CAAiB,UAAjB,EAA6BxC,0BAA0B,CAACoC,IAAD,CAAvD,CAApB;AACH,GAJD,MAIO,IAAId,cAAQ,CAACC,QAAT,CAAkBY,OAAlB,CAA0BF,GAA1B,EAA+BP,GAA/B,IAAsC,CAA1C,EAA6C;AAChD;AACA,UAAMU,IAAI,GAAGH,GAAG,CAACI,UAAJ,CAAehB,KAAf,EAAsB;AAACiB,MAAAA,WAAW,EAAE;AAAd,KAAtB,CAAb;AACAlB,IAAAA,OAAO,CAACmB,SAAR,GAAoBV,MAAM,CAACW,OAAP,CAAe,UAAf,EAA2BxC,0BAA0B,CAACoC,IAAD,CAArD,CAApB;AACH,GAJM,MAIA;AACH;AACA,UAAMA,IAAI,GAAGH,GAAG,CAACI,UAAJ,CAAeX,GAAf,EAAoB;AAACY,MAAAA,WAAW,EAAE;AAAd,KAApB,CAAb;AACAlB,IAAAA,OAAO,CAACmB,SAAR,GAAoBR,OAAO,CAACS,OAAR,CAAgB,UAAhB,EAA4BxC,0BAA0B,CAACoC,IAAD,CAAtD,CAApB;AACH;AACJ;;AAED,SAASK,yBAAT,GAAsC;AAClCC,EAAAA,KAAK,CAAClB,IAAN,CAAWmB,QAAQ,CAACC,gBAAT,CAA0B,gBAA1B,CAAX,EAAwDC,OAAxD,CAAgEC,IAAI,IAAI;AACpE3B,IAAAA,iBAAiB,CAAC2B,IAAD,CAAjB;AACH,GAFD;AAGH;;AAEM,SAASC,YAAT,GAAyB;AAC5B7C,EAAAA,MAAM,CAACuC,yBAAP,GAAmCA,yBAAnC;AAEAE,EAAAA,QAAQ,CAACK,gBAAT,CAA0B,kBAA1B,EAA8CP,yBAA9C;AACAQ,EAAAA,WAAW,CAACR,yBAAD,EAA4B,KAA5B,CAAX;AACH,CClEM,SAASS,SAAT,GAAsB;AAC3BH,EAAAA,YAAY;AACb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECDDI,SAAS,CAACC,KAAD,CAAT;;AAEA,SAASD,SAAT,CAAoBC,KAApB,EAA2B;AACzBA,EAAAA,KAAK,CAACC,IAAN,CAAW,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACnB,WAAOD,CAAC,CAACE,IAAF,CAAOnC,KAAP,GAAekC,CAAC,CAACC,IAAF,CAAOnC,KAA7B;AACD,GAFD;AAGA,SAAO+B,KAAP;AACD;;AAeD,SAASK,cAAT,CAAyBC,IAAzB,EAA+B;AAC7BC,EAAAA,aAAa,CAACP,KAAD,EAAQQ,CAAC,IAAI;AACxB,UAAMlC,GAAG,GAAGJ,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuBoC,CAAC,CAACJ,IAAF,CAAO9B,GAA9B,CAAZ;AACA,WAAOJ,cAAQ,CAACC,QAAT,CAAkBY,OAAlB,CAA0BT,GAA1B,EAA+BO,GAA/B,IAAsC,CAA7C;AACD,GAHY,CAAb;AAKA,QAAM4B,YAAY,IAAW,EAA7B;AACA,QAAMC,WAAW,IAAW,EAA5B;AACA,QAAMC,QAAQ,IAAW,EAAzB;AACA,QAAMC,SAAS,GAAGH,YAAY,KAAK,IAAjB,IAAyBC,WAAW,IAAI,IAAxC,IAAgDC,QAAQ,KAAK,IAA/E;AACA,QAAME,YAAY,GAAGH,WAAW,IAAI,IAAf,IAAuBC,QAAQ,IAAI,IAAxD;AACA,QAAMG,aAAa,GAAGL,YAAY,KAAK,IAAjB,IAAyBC,WAAW,IAAI,IAA9D;AACA,SAAO;AACLI,IAAAA,aADK;AAELL,IAAAA,YAFK;AAGLC,IAAAA,WAHK;AAILC,IAAAA,QAJK;AAKLC,IAAAA,SALK;AAMLC,IAAAA;AANK,GAAP;AAQD;;AAGD,MAAME,eAAe,GAAG7C,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuB,2BAAvB,CAAxB;AACA,MAAM4C,sBAAsB,GAAG9C,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuB,2BAAvB,CAA/B;AACA,MAAM6C,gCAAgC,GAAG/C,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuB,2BAAvB,CAAzC;AACA,MAAM8C,uBAAuB,GAAGhD,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuB,2BAAvB,CAAhC;AACA,MAAM+C,cAAc,GAAGjD,cAAQ,CAACC,QAAT,CAAkBC,IAAlB,CAAuB,2BAAvB,CAAvB;AAEO,SAASgD,IAAT,GAAiB;AACtB,QAAMC,MAAM,GAAG9B,QAAQ,CAAC+B,cAAT,CAAwB,QAAxB,CAAf;AAEA,QAAMC,WAAW,GAAGlB,cAAc,CAAA,CAAlC;AACA,QAAMmB,kBAAkB,GAAGnB,cAAc,CAAA,CAAzC;AACA,QAAMoB,4BAA4B,GAAGpB,cAAc,CAAA,CAAnD;AACA,QAAMqB,mBAAmB,GAAGrB,cAAc,CAAA,CAA1C;AACA,QAAMsB,UAAU,GAAGtB,cAAc,CAAA,CAAjC;AAEAR,EAAAA,WAAW,CAAC,MAAM;AAChBwB,IAAAA,MAAM,CAAClC,SAAP,GAAoB;QAChB,IAAIyC,IAAJ,GAAWC,cAAX,EAA4B;KADhC;AAGD,GAJU,EAIR,EAJQ,CAAX;AAKD"}